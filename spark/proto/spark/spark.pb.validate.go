// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: spark.proto

package spark

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	common "github.com/lightsparkdev/spark-go/proto/common"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = common.SignatureIntent(0)
)

// define the regex for a UUID once up-front
var _spark_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on DepositAddressProof with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DepositAddressProof) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DepositAddressProof with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DepositAddressProofMultiError, or nil if none found.
func (m *DepositAddressProof) ValidateAll() error {
	return m.validate(true)
}

func (m *DepositAddressProof) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AddressSignatures

	// no validation rules for ProofOfPossessionSignature

	if len(errors) > 0 {
		return DepositAddressProofMultiError(errors)
	}

	return nil
}

// DepositAddressProofMultiError is an error wrapping multiple validation
// errors returned by DepositAddressProof.ValidateAll() if the designated
// constraints aren't met.
type DepositAddressProofMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DepositAddressProofMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DepositAddressProofMultiError) AllErrors() []error { return m }

// DepositAddressProofValidationError is the validation error returned by
// DepositAddressProof.Validate if the designated constraints aren't met.
type DepositAddressProofValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DepositAddressProofValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DepositAddressProofValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DepositAddressProofValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DepositAddressProofValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DepositAddressProofValidationError) ErrorName() string {
	return "DepositAddressProofValidationError"
}

// Error satisfies the builtin error interface
func (e DepositAddressProofValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDepositAddressProof.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DepositAddressProofValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DepositAddressProofValidationError{}

// Validate checks the field values on GenerateDepositAddressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateDepositAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateDepositAddressRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GenerateDepositAddressRequestMultiError, or nil if none found.
func (m *GenerateDepositAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateDepositAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SigningPublicKey

	// no validation rules for IdentityPublicKey

	// no validation rules for Network

	if len(errors) > 0 {
		return GenerateDepositAddressRequestMultiError(errors)
	}

	return nil
}

// GenerateDepositAddressRequestMultiError is an error wrapping multiple
// validation errors returned by GenerateDepositAddressRequest.ValidateAll()
// if the designated constraints aren't met.
type GenerateDepositAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateDepositAddressRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateDepositAddressRequestMultiError) AllErrors() []error { return m }

// GenerateDepositAddressRequestValidationError is the validation error
// returned by GenerateDepositAddressRequest.Validate if the designated
// constraints aren't met.
type GenerateDepositAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateDepositAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateDepositAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateDepositAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateDepositAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateDepositAddressRequestValidationError) ErrorName() string {
	return "GenerateDepositAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateDepositAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateDepositAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateDepositAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateDepositAddressRequestValidationError{}

// Validate checks the field values on Address with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Address) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Address with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AddressMultiError, or nil if none found.
func (m *Address) ValidateAll() error {
	return m.validate(true)
}

func (m *Address) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	// no validation rules for VerifyingKey

	if all {
		switch v := interface{}(m.GetDepositAddressProof()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddressValidationError{
					field:  "DepositAddressProof",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddressValidationError{
					field:  "DepositAddressProof",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDepositAddressProof()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddressValidationError{
				field:  "DepositAddressProof",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddressMultiError(errors)
	}

	return nil
}

// AddressMultiError is an error wrapping multiple validation errors returned
// by Address.ValidateAll() if the designated constraints aren't met.
type AddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressMultiError) AllErrors() []error { return m }

// AddressValidationError is the validation error returned by Address.Validate
// if the designated constraints aren't met.
type AddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressValidationError) ErrorName() string { return "AddressValidationError" }

// Error satisfies the builtin error interface
func (e AddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressValidationError{}

// Validate checks the field values on GenerateDepositAddressResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GenerateDepositAddressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenerateDepositAddressResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GenerateDepositAddressResponseMultiError, or nil if none found.
func (m *GenerateDepositAddressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GenerateDepositAddressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDepositAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenerateDepositAddressResponseValidationError{
					field:  "DepositAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenerateDepositAddressResponseValidationError{
					field:  "DepositAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDepositAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenerateDepositAddressResponseValidationError{
				field:  "DepositAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GenerateDepositAddressResponseMultiError(errors)
	}

	return nil
}

// GenerateDepositAddressResponseMultiError is an error wrapping multiple
// validation errors returned by GenerateDepositAddressResponse.ValidateAll()
// if the designated constraints aren't met.
type GenerateDepositAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenerateDepositAddressResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenerateDepositAddressResponseMultiError) AllErrors() []error { return m }

// GenerateDepositAddressResponseValidationError is the validation error
// returned by GenerateDepositAddressResponse.Validate if the designated
// constraints aren't met.
type GenerateDepositAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenerateDepositAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenerateDepositAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenerateDepositAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenerateDepositAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenerateDepositAddressResponseValidationError) ErrorName() string {
	return "GenerateDepositAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GenerateDepositAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenerateDepositAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenerateDepositAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenerateDepositAddressResponseValidationError{}

// Validate checks the field values on UTXO with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *UTXO) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UTXO with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UTXOMultiError, or nil if none found.
func (m *UTXO) ValidateAll() error {
	return m.validate(true)
}

func (m *UTXO) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RawTx

	// no validation rules for Vout

	// no validation rules for Network

	if len(errors) > 0 {
		return UTXOMultiError(errors)
	}

	return nil
}

// UTXOMultiError is an error wrapping multiple validation errors returned by
// UTXO.ValidateAll() if the designated constraints aren't met.
type UTXOMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UTXOMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UTXOMultiError) AllErrors() []error { return m }

// UTXOValidationError is the validation error returned by UTXO.Validate if the
// designated constraints aren't met.
type UTXOValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UTXOValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UTXOValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UTXOValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UTXOValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UTXOValidationError) ErrorName() string { return "UTXOValidationError" }

// Error satisfies the builtin error interface
func (e UTXOValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUTXO.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UTXOValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UTXOValidationError{}

// Validate checks the field values on NodeOutput with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeOutput with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeOutputMultiError, or
// nil if none found.
func (m *NodeOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeId

	// no validation rules for Vout

	if len(errors) > 0 {
		return NodeOutputMultiError(errors)
	}

	return nil
}

// NodeOutputMultiError is an error wrapping multiple validation errors
// returned by NodeOutput.ValidateAll() if the designated constraints aren't met.
type NodeOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeOutputMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeOutputMultiError) AllErrors() []error { return m }

// NodeOutputValidationError is the validation error returned by
// NodeOutput.Validate if the designated constraints aren't met.
type NodeOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeOutputValidationError) ErrorName() string { return "NodeOutputValidationError" }

// Error satisfies the builtin error interface
func (e NodeOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeOutputValidationError{}

// Validate checks the field values on SigningJob with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SigningJob) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SigningJob with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SigningJobMultiError, or
// nil if none found.
func (m *SigningJob) ValidateAll() error {
	return m.validate(true)
}

func (m *SigningJob) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SigningPublicKey

	// no validation rules for RawTx

	if all {
		switch v := interface{}(m.GetSigningNonceCommitment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SigningJobValidationError{
					field:  "SigningNonceCommitment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SigningJobValidationError{
					field:  "SigningNonceCommitment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSigningNonceCommitment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SigningJobValidationError{
				field:  "SigningNonceCommitment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SigningJobMultiError(errors)
	}

	return nil
}

// SigningJobMultiError is an error wrapping multiple validation errors
// returned by SigningJob.ValidateAll() if the designated constraints aren't met.
type SigningJobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SigningJobMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SigningJobMultiError) AllErrors() []error { return m }

// SigningJobValidationError is the validation error returned by
// SigningJob.Validate if the designated constraints aren't met.
type SigningJobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SigningJobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SigningJobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SigningJobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SigningJobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SigningJobValidationError) ErrorName() string { return "SigningJobValidationError" }

// Error satisfies the builtin error interface
func (e SigningJobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSigningJob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SigningJobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SigningJobValidationError{}

// Validate checks the field values on SigningKeyshare with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SigningKeyshare) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SigningKeyshare with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SigningKeyshareMultiError, or nil if none found.
func (m *SigningKeyshare) ValidateAll() error {
	return m.validate(true)
}

func (m *SigningKeyshare) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Threshold

	if len(errors) > 0 {
		return SigningKeyshareMultiError(errors)
	}

	return nil
}

// SigningKeyshareMultiError is an error wrapping multiple validation errors
// returned by SigningKeyshare.ValidateAll() if the designated constraints
// aren't met.
type SigningKeyshareMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SigningKeyshareMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SigningKeyshareMultiError) AllErrors() []error { return m }

// SigningKeyshareValidationError is the validation error returned by
// SigningKeyshare.Validate if the designated constraints aren't met.
type SigningKeyshareValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SigningKeyshareValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SigningKeyshareValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SigningKeyshareValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SigningKeyshareValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SigningKeyshareValidationError) ErrorName() string { return "SigningKeyshareValidationError" }

// Error satisfies the builtin error interface
func (e SigningKeyshareValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSigningKeyshare.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SigningKeyshareValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SigningKeyshareValidationError{}

// Validate checks the field values on SigningResult with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SigningResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SigningResult with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SigningResultMultiError, or
// nil if none found.
func (m *SigningResult) ValidateAll() error {
	return m.validate(true)
}

func (m *SigningResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PublicKeys

	{
		sorted_keys := make([]string, len(m.GetSigningNonceCommitments()))
		i := 0
		for key := range m.GetSigningNonceCommitments() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSigningNonceCommitments()[key]
			_ = val

			// no validation rules for SigningNonceCommitments[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SigningResultValidationError{
							field:  fmt.Sprintf("SigningNonceCommitments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SigningResultValidationError{
							field:  fmt.Sprintf("SigningNonceCommitments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SigningResultValidationError{
						field:  fmt.Sprintf("SigningNonceCommitments[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for SignatureShares

	if all {
		switch v := interface{}(m.GetSigningKeyshare()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SigningResultValidationError{
					field:  "SigningKeyshare",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SigningResultValidationError{
					field:  "SigningKeyshare",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSigningKeyshare()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SigningResultValidationError{
				field:  "SigningKeyshare",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SigningResultMultiError(errors)
	}

	return nil
}

// SigningResultMultiError is an error wrapping multiple validation errors
// returned by SigningResult.ValidateAll() if the designated constraints
// aren't met.
type SigningResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SigningResultMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SigningResultMultiError) AllErrors() []error { return m }

// SigningResultValidationError is the validation error returned by
// SigningResult.Validate if the designated constraints aren't met.
type SigningResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SigningResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SigningResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SigningResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SigningResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SigningResultValidationError) ErrorName() string { return "SigningResultValidationError" }

// Error satisfies the builtin error interface
func (e SigningResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSigningResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SigningResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SigningResultValidationError{}

// Validate checks the field values on NodeSignatureShares with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NodeSignatureShares) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeSignatureShares with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NodeSignatureSharesMultiError, or nil if none found.
func (m *NodeSignatureShares) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeSignatureShares) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeId

	if all {
		switch v := interface{}(m.GetNodeTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeSignatureSharesValidationError{
					field:  "NodeTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeSignatureSharesValidationError{
					field:  "NodeTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeSignatureSharesValidationError{
				field:  "NodeTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefundTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NodeSignatureSharesValidationError{
					field:  "RefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NodeSignatureSharesValidationError{
					field:  "RefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NodeSignatureSharesValidationError{
				field:  "RefundTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for VerifyingKey

	if len(errors) > 0 {
		return NodeSignatureSharesMultiError(errors)
	}

	return nil
}

// NodeSignatureSharesMultiError is an error wrapping multiple validation
// errors returned by NodeSignatureShares.ValidateAll() if the designated
// constraints aren't met.
type NodeSignatureSharesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeSignatureSharesMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeSignatureSharesMultiError) AllErrors() []error { return m }

// NodeSignatureSharesValidationError is the validation error returned by
// NodeSignatureShares.Validate if the designated constraints aren't met.
type NodeSignatureSharesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeSignatureSharesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeSignatureSharesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeSignatureSharesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeSignatureSharesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeSignatureSharesValidationError) ErrorName() string {
	return "NodeSignatureSharesValidationError"
}

// Error satisfies the builtin error interface
func (e NodeSignatureSharesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeSignatureShares.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeSignatureSharesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeSignatureSharesValidationError{}

// Validate checks the field values on NodeSignatures with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NodeSignatures) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NodeSignatures with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NodeSignaturesMultiError,
// or nil if none found.
func (m *NodeSignatures) ValidateAll() error {
	return m.validate(true)
}

func (m *NodeSignatures) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeId

	// no validation rules for NodeTxSignature

	// no validation rules for RefundTxSignature

	if len(errors) > 0 {
		return NodeSignaturesMultiError(errors)
	}

	return nil
}

// NodeSignaturesMultiError is an error wrapping multiple validation errors
// returned by NodeSignatures.ValidateAll() if the designated constraints
// aren't met.
type NodeSignaturesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NodeSignaturesMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NodeSignaturesMultiError) AllErrors() []error { return m }

// NodeSignaturesValidationError is the validation error returned by
// NodeSignatures.Validate if the designated constraints aren't met.
type NodeSignaturesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NodeSignaturesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NodeSignaturesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NodeSignaturesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NodeSignaturesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NodeSignaturesValidationError) ErrorName() string { return "NodeSignaturesValidationError" }

// Error satisfies the builtin error interface
func (e NodeSignaturesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNodeSignatures.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NodeSignaturesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NodeSignaturesValidationError{}

// Validate checks the field values on StartTreeCreationRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartTreeCreationRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartTreeCreationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartTreeCreationRequestMultiError, or nil if none found.
func (m *StartTreeCreationRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartTreeCreationRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IdentityPublicKey

	if all {
		switch v := interface{}(m.GetOnChainUtxo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTreeCreationRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTreeCreationRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOnChainUtxo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTreeCreationRequestValidationError{
				field:  "OnChainUtxo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRootTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTreeCreationRequestValidationError{
					field:  "RootTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTreeCreationRequestValidationError{
					field:  "RootTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRootTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTreeCreationRequestValidationError{
				field:  "RootTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTreeCreationRequestValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTreeCreationRequestValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTreeCreationRequestValidationError{
				field:  "RefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartTreeCreationRequestMultiError(errors)
	}

	return nil
}

// StartTreeCreationRequestMultiError is an error wrapping multiple validation
// errors returned by StartTreeCreationRequest.ValidateAll() if the designated
// constraints aren't met.
type StartTreeCreationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartTreeCreationRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartTreeCreationRequestMultiError) AllErrors() []error { return m }

// StartTreeCreationRequestValidationError is the validation error returned by
// StartTreeCreationRequest.Validate if the designated constraints aren't met.
type StartTreeCreationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartTreeCreationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartTreeCreationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartTreeCreationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartTreeCreationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartTreeCreationRequestValidationError) ErrorName() string {
	return "StartTreeCreationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StartTreeCreationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartTreeCreationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartTreeCreationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartTreeCreationRequestValidationError{}

// Validate checks the field values on StartTreeCreationResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartTreeCreationResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartTreeCreationResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartTreeCreationResponseMultiError, or nil if none found.
func (m *StartTreeCreationResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StartTreeCreationResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TreeId

	if all {
		switch v := interface{}(m.GetRootNodeSignatureShares()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTreeCreationResponseValidationError{
					field:  "RootNodeSignatureShares",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTreeCreationResponseValidationError{
					field:  "RootNodeSignatureShares",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRootNodeSignatureShares()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTreeCreationResponseValidationError{
				field:  "RootNodeSignatureShares",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartTreeCreationResponseMultiError(errors)
	}

	return nil
}

// StartTreeCreationResponseMultiError is an error wrapping multiple validation
// errors returned by StartTreeCreationResponse.ValidateAll() if the
// designated constraints aren't met.
type StartTreeCreationResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartTreeCreationResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartTreeCreationResponseMultiError) AllErrors() []error { return m }

// StartTreeCreationResponseValidationError is the validation error returned by
// StartTreeCreationResponse.Validate if the designated constraints aren't met.
type StartTreeCreationResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartTreeCreationResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartTreeCreationResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartTreeCreationResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartTreeCreationResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartTreeCreationResponseValidationError) ErrorName() string {
	return "StartTreeCreationResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StartTreeCreationResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartTreeCreationResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartTreeCreationResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartTreeCreationResponseValidationError{}

// Validate checks the field values on TokenLeafToSpend with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TokenLeafToSpend) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenLeafToSpend with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenLeafToSpendMultiError, or nil if none found.
func (m *TokenLeafToSpend) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenLeafToSpend) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetPrevTokenTransactionHash()) != 32 {
		err := TokenLeafToSpendValidationError{
			field:  "PrevTokenTransactionHash",
			reason: "value length must be 32 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PrevTokenTransactionLeafVout

	if len(errors) > 0 {
		return TokenLeafToSpendMultiError(errors)
	}

	return nil
}

// TokenLeafToSpendMultiError is an error wrapping multiple validation errors
// returned by TokenLeafToSpend.ValidateAll() if the designated constraints
// aren't met.
type TokenLeafToSpendMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenLeafToSpendMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenLeafToSpendMultiError) AllErrors() []error { return m }

// TokenLeafToSpendValidationError is the validation error returned by
// TokenLeafToSpend.Validate if the designated constraints aren't met.
type TokenLeafToSpendValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenLeafToSpendValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenLeafToSpendValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenLeafToSpendValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenLeafToSpendValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenLeafToSpendValidationError) ErrorName() string { return "TokenLeafToSpendValidationError" }

// Error satisfies the builtin error interface
func (e TokenLeafToSpendValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenLeafToSpend.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenLeafToSpendValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenLeafToSpendValidationError{}

// Validate checks the field values on TransferInput with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TransferInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransferInput with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransferInputMultiError, or
// nil if none found.
func (m *TransferInput) ValidateAll() error {
	return m.validate(true)
}

func (m *TransferInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLeavesToSpend() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransferInputValidationError{
						field:  fmt.Sprintf("LeavesToSpend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransferInputValidationError{
						field:  fmt.Sprintf("LeavesToSpend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransferInputValidationError{
					field:  fmt.Sprintf("LeavesToSpend[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TransferInputMultiError(errors)
	}

	return nil
}

// TransferInputMultiError is an error wrapping multiple validation errors
// returned by TransferInput.ValidateAll() if the designated constraints
// aren't met.
type TransferInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferInputMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferInputMultiError) AllErrors() []error { return m }

// TransferInputValidationError is the validation error returned by
// TransferInput.Validate if the designated constraints aren't met.
type TransferInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferInputValidationError) ErrorName() string { return "TransferInputValidationError" }

// Error satisfies the builtin error interface
func (e TransferInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferInputValidationError{}

// Validate checks the field values on MintInput with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MintInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MintInput with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MintInputMultiError, or nil
// if none found.
func (m *MintInput) ValidateAll() error {
	return m.validate(true)
}

func (m *MintInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetIssuerPublicKey()) != 33 {
		err := MintInputValidationError{
			field:  "IssuerPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IssuerProvidedTimestamp

	if len(errors) > 0 {
		return MintInputMultiError(errors)
	}

	return nil
}

// MintInputMultiError is an error wrapping multiple validation errors returned
// by MintInput.ValidateAll() if the designated constraints aren't met.
type MintInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MintInputMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MintInputMultiError) AllErrors() []error { return m }

// MintInputValidationError is the validation error returned by
// MintInput.Validate if the designated constraints aren't met.
type MintInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MintInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MintInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MintInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MintInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MintInputValidationError) ErrorName() string { return "MintInputValidationError" }

// Error satisfies the builtin error interface
func (e MintInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMintInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MintInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MintInputValidationError{}

// Validate checks the field values on TokenLeafOutput with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TokenLeafOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenLeafOutput with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenLeafOutputMultiError, or nil if none found.
func (m *TokenLeafOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenLeafOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetOwnerPublicKey()) != 33 {
		err := TokenLeafOutputValidationError{
			field:  "OwnerPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetTokenPublicKey()) != 33 {
		err := TokenLeafOutputValidationError{
			field:  "TokenPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetTokenAmount()) != 16 {
		err := TokenLeafOutputValidationError{
			field:  "TokenAmount",
			reason: "value length must be 16 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Id != nil {

		if err := m._validateUuid(m.GetId()); err != nil {
			err = TokenLeafOutputValidationError{
				field:  "Id",
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.RevocationPublicKey != nil {

		if len(m.GetRevocationPublicKey()) != 33 {
			err := TokenLeafOutputValidationError{
				field:  "RevocationPublicKey",
				reason: "value length must be 33 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.WithdrawBondSats != nil {
		// no validation rules for WithdrawBondSats
	}

	if m.WithdrawRelativeBlockLocktime != nil {
		// no validation rules for WithdrawRelativeBlockLocktime
	}

	if len(errors) > 0 {
		return TokenLeafOutputMultiError(errors)
	}

	return nil
}

func (m *TokenLeafOutput) _validateUuid(uuid string) error {
	if matched := _spark_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// TokenLeafOutputMultiError is an error wrapping multiple validation errors
// returned by TokenLeafOutput.ValidateAll() if the designated constraints
// aren't met.
type TokenLeafOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenLeafOutputMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenLeafOutputMultiError) AllErrors() []error { return m }

// TokenLeafOutputValidationError is the validation error returned by
// TokenLeafOutput.Validate if the designated constraints aren't met.
type TokenLeafOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenLeafOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenLeafOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenLeafOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenLeafOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenLeafOutputValidationError) ErrorName() string { return "TokenLeafOutputValidationError" }

// Error satisfies the builtin error interface
func (e TokenLeafOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenLeafOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenLeafOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenLeafOutputValidationError{}

// Validate checks the field values on TokenTransaction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TokenTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenTransactionMultiError, or nil if none found.
func (m *TokenTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOutputLeaves() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenTransactionValidationError{
						field:  fmt.Sprintf("OutputLeaves[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenTransactionValidationError{
						field:  fmt.Sprintf("OutputLeaves[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenTransactionValidationError{
					field:  fmt.Sprintf("OutputLeaves[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSparkOperatorIdentityPublicKeys() {
		_, _ = idx, item

		if len(item) != 33 {
			err := TokenTransactionValidationError{
				field:  fmt.Sprintf("SparkOperatorIdentityPublicKeys[%v]", idx),
				reason: "value length must be 33 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for Network

	switch v := m.TokenInput.(type) {
	case *TokenTransaction_MintInput:
		if v == nil {
			err := TokenTransactionValidationError{
				field:  "TokenInput",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMintInput()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenTransactionValidationError{
						field:  "MintInput",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenTransactionValidationError{
						field:  "MintInput",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMintInput()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenTransactionValidationError{
					field:  "MintInput",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TokenTransaction_TransferInput:
		if v == nil {
			err := TokenTransactionValidationError{
				field:  "TokenInput",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTransferInput()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TokenTransactionValidationError{
						field:  "TransferInput",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TokenTransactionValidationError{
						field:  "TransferInput",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTransferInput()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TokenTransactionValidationError{
					field:  "TransferInput",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return TokenTransactionMultiError(errors)
	}

	return nil
}

// TokenTransactionMultiError is an error wrapping multiple validation errors
// returned by TokenTransaction.ValidateAll() if the designated constraints
// aren't met.
type TokenTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenTransactionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenTransactionMultiError) AllErrors() []error { return m }

// TokenTransactionValidationError is the validation error returned by
// TokenTransaction.Validate if the designated constraints aren't met.
type TokenTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenTransactionValidationError) ErrorName() string { return "TokenTransactionValidationError" }

// Error satisfies the builtin error interface
func (e TokenTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenTransactionValidationError{}

// Validate checks the field values on TokenTransactionWithStatus with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenTransactionWithStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenTransactionWithStatus with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenTransactionWithStatusMultiError, or nil if none found.
func (m *TokenTransactionWithStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenTransactionWithStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TokenTransactionWithStatusValidationError{
					field:  "TokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TokenTransactionWithStatusValidationError{
					field:  "TokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TokenTransactionWithStatusValidationError{
				field:  "TokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	if len(errors) > 0 {
		return TokenTransactionWithStatusMultiError(errors)
	}

	return nil
}

// TokenTransactionWithStatusMultiError is an error wrapping multiple
// validation errors returned by TokenTransactionWithStatus.ValidateAll() if
// the designated constraints aren't met.
type TokenTransactionWithStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenTransactionWithStatusMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenTransactionWithStatusMultiError) AllErrors() []error { return m }

// TokenTransactionWithStatusValidationError is the validation error returned
// by TokenTransactionWithStatus.Validate if the designated constraints aren't met.
type TokenTransactionWithStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenTransactionWithStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenTransactionWithStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenTransactionWithStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenTransactionWithStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenTransactionWithStatusValidationError) ErrorName() string {
	return "TokenTransactionWithStatusValidationError"
}

// Error satisfies the builtin error interface
func (e TokenTransactionWithStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenTransactionWithStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenTransactionWithStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenTransactionWithStatusValidationError{}

// Validate checks the field values on TokenTransactionSignatures with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenTransactionSignatures) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenTransactionSignatures with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenTransactionSignaturesMultiError, or nil if none found.
func (m *TokenTransactionSignatures) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenTransactionSignatures) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOwnerSignatures() {
		_, _ = idx, item

		if l := len(item); l < 64 || l > 73 {
			err := TokenTransactionSignaturesValidationError{
				field:  fmt.Sprintf("OwnerSignatures[%v]", idx),
				reason: "value length must be between 64 and 73 bytes, inclusive",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return TokenTransactionSignaturesMultiError(errors)
	}

	return nil
}

// TokenTransactionSignaturesMultiError is an error wrapping multiple
// validation errors returned by TokenTransactionSignatures.ValidateAll() if
// the designated constraints aren't met.
type TokenTransactionSignaturesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenTransactionSignaturesMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenTransactionSignaturesMultiError) AllErrors() []error { return m }

// TokenTransactionSignaturesValidationError is the validation error returned
// by TokenTransactionSignatures.Validate if the designated constraints aren't met.
type TokenTransactionSignaturesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenTransactionSignaturesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenTransactionSignaturesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenTransactionSignaturesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenTransactionSignaturesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenTransactionSignaturesValidationError) ErrorName() string {
	return "TokenTransactionSignaturesValidationError"
}

// Error satisfies the builtin error interface
func (e TokenTransactionSignaturesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenTransactionSignatures.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenTransactionSignaturesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenTransactionSignaturesValidationError{}

// Validate checks the field values on StartTokenTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartTokenTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartTokenTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartTokenTransactionRequestMultiError, or nil if none found.
func (m *StartTokenTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartTokenTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetIdentityPublicKey()) != 33 {
		err := StartTokenTransactionRequestValidationError{
			field:  "IdentityPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPartialTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTokenTransactionRequestValidationError{
					field:  "PartialTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTokenTransactionRequestValidationError{
					field:  "PartialTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPartialTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTokenTransactionRequestValidationError{
				field:  "PartialTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTokenTransactionSignatures()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTokenTransactionRequestValidationError{
					field:  "TokenTransactionSignatures",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTokenTransactionRequestValidationError{
					field:  "TokenTransactionSignatures",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTokenTransactionSignatures()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTokenTransactionRequestValidationError{
				field:  "TokenTransactionSignatures",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartTokenTransactionRequestMultiError(errors)
	}

	return nil
}

// StartTokenTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by StartTokenTransactionRequest.ValidateAll() if
// the designated constraints aren't met.
type StartTokenTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartTokenTransactionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartTokenTransactionRequestMultiError) AllErrors() []error { return m }

// StartTokenTransactionRequestValidationError is the validation error returned
// by StartTokenTransactionRequest.Validate if the designated constraints
// aren't met.
type StartTokenTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartTokenTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartTokenTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartTokenTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartTokenTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartTokenTransactionRequestValidationError) ErrorName() string {
	return "StartTokenTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StartTokenTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartTokenTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartTokenTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartTokenTransactionRequestValidationError{}

// Validate checks the field values on StartTokenTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartTokenTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartTokenTransactionResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// StartTokenTransactionResponseMultiError, or nil if none found.
func (m *StartTokenTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StartTokenTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTokenTransactionResponseValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTokenTransactionResponseValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTokenTransactionResponseValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetKeyshareInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartTokenTransactionResponseValidationError{
					field:  "KeyshareInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartTokenTransactionResponseValidationError{
					field:  "KeyshareInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKeyshareInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartTokenTransactionResponseValidationError{
				field:  "KeyshareInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartTokenTransactionResponseMultiError(errors)
	}

	return nil
}

// StartTokenTransactionResponseMultiError is an error wrapping multiple
// validation errors returned by StartTokenTransactionResponse.ValidateAll()
// if the designated constraints aren't met.
type StartTokenTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartTokenTransactionResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartTokenTransactionResponseMultiError) AllErrors() []error { return m }

// StartTokenTransactionResponseValidationError is the validation error
// returned by StartTokenTransactionResponse.Validate if the designated
// constraints aren't met.
type StartTokenTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartTokenTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartTokenTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartTokenTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartTokenTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartTokenTransactionResponseValidationError) ErrorName() string {
	return "StartTokenTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StartTokenTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartTokenTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartTokenTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartTokenTransactionResponseValidationError{}

// Validate checks the field values on
// OperatorSpecificTokenTransactionSignablePayload with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OperatorSpecificTokenTransactionSignablePayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// OperatorSpecificTokenTransactionSignablePayload with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// OperatorSpecificTokenTransactionSignablePayloadMultiError, or nil if none found.
func (m *OperatorSpecificTokenTransactionSignablePayload) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorSpecificTokenTransactionSignablePayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetFinalTokenTransactionHash()) != 32 {
		err := OperatorSpecificTokenTransactionSignablePayloadValidationError{
			field:  "FinalTokenTransactionHash",
			reason: "value length must be 32 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetOperatorIdentityPublicKey()) != 33 {
		err := OperatorSpecificTokenTransactionSignablePayloadValidationError{
			field:  "OperatorIdentityPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return OperatorSpecificTokenTransactionSignablePayloadMultiError(errors)
	}

	return nil
}

// OperatorSpecificTokenTransactionSignablePayloadMultiError is an error
// wrapping multiple validation errors returned by
// OperatorSpecificTokenTransactionSignablePayload.ValidateAll() if the
// designated constraints aren't met.
type OperatorSpecificTokenTransactionSignablePayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorSpecificTokenTransactionSignablePayloadMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorSpecificTokenTransactionSignablePayloadMultiError) AllErrors() []error { return m }

// OperatorSpecificTokenTransactionSignablePayloadValidationError is the
// validation error returned by
// OperatorSpecificTokenTransactionSignablePayload.Validate if the designated
// constraints aren't met.
type OperatorSpecificTokenTransactionSignablePayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorSpecificTokenTransactionSignablePayloadValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e OperatorSpecificTokenTransactionSignablePayloadValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e OperatorSpecificTokenTransactionSignablePayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorSpecificTokenTransactionSignablePayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorSpecificTokenTransactionSignablePayloadValidationError) ErrorName() string {
	return "OperatorSpecificTokenTransactionSignablePayloadValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorSpecificTokenTransactionSignablePayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorSpecificTokenTransactionSignablePayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorSpecificTokenTransactionSignablePayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorSpecificTokenTransactionSignablePayloadValidationError{}

// Validate checks the field values on
// OperatorSpecificTokenTransactionSignature with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OperatorSpecificTokenTransactionSignature) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// OperatorSpecificTokenTransactionSignature with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// OperatorSpecificTokenTransactionSignatureMultiError, or nil if none found.
func (m *OperatorSpecificTokenTransactionSignature) ValidateAll() error {
	return m.validate(true)
}

func (m *OperatorSpecificTokenTransactionSignature) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetOwnerPublicKey()) != 33 {
		err := OperatorSpecificTokenTransactionSignatureValidationError{
			field:  "OwnerPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := len(m.GetOwnerSignature()); l < 64 || l > 73 {
		err := OperatorSpecificTokenTransactionSignatureValidationError{
			field:  "OwnerSignature",
			reason: "value length must be between 64 and 73 bytes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPayload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperatorSpecificTokenTransactionSignatureValidationError{
					field:  "Payload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperatorSpecificTokenTransactionSignatureValidationError{
					field:  "Payload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperatorSpecificTokenTransactionSignatureValidationError{
				field:  "Payload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OperatorSpecificTokenTransactionSignatureMultiError(errors)
	}

	return nil
}

// OperatorSpecificTokenTransactionSignatureMultiError is an error wrapping
// multiple validation errors returned by
// OperatorSpecificTokenTransactionSignature.ValidateAll() if the designated
// constraints aren't met.
type OperatorSpecificTokenTransactionSignatureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperatorSpecificTokenTransactionSignatureMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperatorSpecificTokenTransactionSignatureMultiError) AllErrors() []error { return m }

// OperatorSpecificTokenTransactionSignatureValidationError is the validation
// error returned by OperatorSpecificTokenTransactionSignature.Validate if the
// designated constraints aren't met.
type OperatorSpecificTokenTransactionSignatureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperatorSpecificTokenTransactionSignatureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperatorSpecificTokenTransactionSignatureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperatorSpecificTokenTransactionSignatureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperatorSpecificTokenTransactionSignatureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperatorSpecificTokenTransactionSignatureValidationError) ErrorName() string {
	return "OperatorSpecificTokenTransactionSignatureValidationError"
}

// Error satisfies the builtin error interface
func (e OperatorSpecificTokenTransactionSignatureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperatorSpecificTokenTransactionSignature.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperatorSpecificTokenTransactionSignatureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperatorSpecificTokenTransactionSignatureValidationError{}

// Validate checks the field values on SignTokenTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignTokenTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignTokenTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignTokenTransactionRequestMultiError, or nil if none found.
func (m *SignTokenTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SignTokenTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SignTokenTransactionRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SignTokenTransactionRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SignTokenTransactionRequestValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetOperatorSpecificSignatures() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignTokenTransactionRequestValidationError{
						field:  fmt.Sprintf("OperatorSpecificSignatures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignTokenTransactionRequestValidationError{
						field:  fmt.Sprintf("OperatorSpecificSignatures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignTokenTransactionRequestValidationError{
					field:  fmt.Sprintf("OperatorSpecificSignatures[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(m.GetIdentityPublicKey()) != 33 {
		err := SignTokenTransactionRequestValidationError{
			field:  "IdentityPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SignTokenTransactionRequestMultiError(errors)
	}

	return nil
}

// SignTokenTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by SignTokenTransactionRequest.ValidateAll() if
// the designated constraints aren't met.
type SignTokenTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignTokenTransactionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignTokenTransactionRequestMultiError) AllErrors() []error { return m }

// SignTokenTransactionRequestValidationError is the validation error returned
// by SignTokenTransactionRequest.Validate if the designated constraints
// aren't met.
type SignTokenTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignTokenTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignTokenTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignTokenTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignTokenTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignTokenTransactionRequestValidationError) ErrorName() string {
	return "SignTokenTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SignTokenTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignTokenTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignTokenTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignTokenTransactionRequestValidationError{}

// Validate checks the field values on SignTokenTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignTokenTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignTokenTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignTokenTransactionResponseMultiError, or nil if none found.
func (m *SignTokenTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SignTokenTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := len(m.GetSparkOperatorSignature()); l < 64 || l > 73 {
		err := SignTokenTransactionResponseValidationError{
			field:  "SparkOperatorSignature",
			reason: "value length must be between 64 and 73 bytes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTokenTransactionRevocationKeyshares() {
		_, _ = idx, item

		if len(item) != 32 {
			err := SignTokenTransactionResponseValidationError{
				field:  fmt.Sprintf("TokenTransactionRevocationKeyshares[%v]", idx),
				reason: "value length must be 32 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return SignTokenTransactionResponseMultiError(errors)
	}

	return nil
}

// SignTokenTransactionResponseMultiError is an error wrapping multiple
// validation errors returned by SignTokenTransactionResponse.ValidateAll() if
// the designated constraints aren't met.
type SignTokenTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignTokenTransactionResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignTokenTransactionResponseMultiError) AllErrors() []error { return m }

// SignTokenTransactionResponseValidationError is the validation error returned
// by SignTokenTransactionResponse.Validate if the designated constraints
// aren't met.
type SignTokenTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignTokenTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignTokenTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignTokenTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignTokenTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignTokenTransactionResponseValidationError) ErrorName() string {
	return "SignTokenTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SignTokenTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignTokenTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignTokenTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignTokenTransactionResponseValidationError{}

// Validate checks the field values on FinalizeTokenTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinalizeTokenTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeTokenTransactionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// FinalizeTokenTransactionRequestMultiError, or nil if none found.
func (m *FinalizeTokenTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeTokenTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FinalizeTokenTransactionRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FinalizeTokenTransactionRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FinalizeTokenTransactionRequestValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLeafToSpendRevocationKeys() {
		_, _ = idx, item

		if len(item) != 32 {
			err := FinalizeTokenTransactionRequestValidationError{
				field:  fmt.Sprintf("LeafToSpendRevocationKeys[%v]", idx),
				reason: "value length must be 32 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(m.GetIdentityPublicKey()) != 33 {
		err := FinalizeTokenTransactionRequestValidationError{
			field:  "IdentityPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return FinalizeTokenTransactionRequestMultiError(errors)
	}

	return nil
}

// FinalizeTokenTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by FinalizeTokenTransactionRequest.ValidateAll()
// if the designated constraints aren't met.
type FinalizeTokenTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeTokenTransactionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeTokenTransactionRequestMultiError) AllErrors() []error { return m }

// FinalizeTokenTransactionRequestValidationError is the validation error
// returned by FinalizeTokenTransactionRequest.Validate if the designated
// constraints aren't met.
type FinalizeTokenTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeTokenTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeTokenTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeTokenTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeTokenTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeTokenTransactionRequestValidationError) ErrorName() string {
	return "FinalizeTokenTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeTokenTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeTokenTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeTokenTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeTokenTransactionRequestValidationError{}

// Validate checks the field values on FreezeTokensPayload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FreezeTokensPayload) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FreezeTokensPayload with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FreezeTokensPayloadMultiError, or nil if none found.
func (m *FreezeTokensPayload) ValidateAll() error {
	return m.validate(true)
}

func (m *FreezeTokensPayload) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetOwnerPublicKey()) != 33 {
		err := FreezeTokensPayloadValidationError{
			field:  "OwnerPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetTokenPublicKey()) != 33 {
		err := FreezeTokensPayloadValidationError{
			field:  "TokenPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for IssuerProvidedTimestamp

	if len(m.GetOperatorIdentityPublicKey()) != 33 {
		err := FreezeTokensPayloadValidationError{
			field:  "OperatorIdentityPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ShouldUnfreeze

	if len(errors) > 0 {
		return FreezeTokensPayloadMultiError(errors)
	}

	return nil
}

// FreezeTokensPayloadMultiError is an error wrapping multiple validation
// errors returned by FreezeTokensPayload.ValidateAll() if the designated
// constraints aren't met.
type FreezeTokensPayloadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FreezeTokensPayloadMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FreezeTokensPayloadMultiError) AllErrors() []error { return m }

// FreezeTokensPayloadValidationError is the validation error returned by
// FreezeTokensPayload.Validate if the designated constraints aren't met.
type FreezeTokensPayloadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FreezeTokensPayloadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FreezeTokensPayloadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FreezeTokensPayloadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FreezeTokensPayloadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FreezeTokensPayloadValidationError) ErrorName() string {
	return "FreezeTokensPayloadValidationError"
}

// Error satisfies the builtin error interface
func (e FreezeTokensPayloadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFreezeTokensPayload.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FreezeTokensPayloadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FreezeTokensPayloadValidationError{}

// Validate checks the field values on FreezeTokensRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FreezeTokensRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FreezeTokensRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FreezeTokensRequestMultiError, or nil if none found.
func (m *FreezeTokensRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FreezeTokensRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFreezeTokensPayload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FreezeTokensRequestValidationError{
					field:  "FreezeTokensPayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FreezeTokensRequestValidationError{
					field:  "FreezeTokensPayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFreezeTokensPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FreezeTokensRequestValidationError{
				field:  "FreezeTokensPayload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if l := len(m.GetIssuerSignature()); l < 64 || l > 73 {
		err := FreezeTokensRequestValidationError{
			field:  "IssuerSignature",
			reason: "value length must be between 64 and 73 bytes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return FreezeTokensRequestMultiError(errors)
	}

	return nil
}

// FreezeTokensRequestMultiError is an error wrapping multiple validation
// errors returned by FreezeTokensRequest.ValidateAll() if the designated
// constraints aren't met.
type FreezeTokensRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FreezeTokensRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FreezeTokensRequestMultiError) AllErrors() []error { return m }

// FreezeTokensRequestValidationError is the validation error returned by
// FreezeTokensRequest.Validate if the designated constraints aren't met.
type FreezeTokensRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FreezeTokensRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FreezeTokensRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FreezeTokensRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FreezeTokensRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FreezeTokensRequestValidationError) ErrorName() string {
	return "FreezeTokensRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FreezeTokensRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFreezeTokensRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FreezeTokensRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FreezeTokensRequestValidationError{}

// Validate checks the field values on FreezeTokensResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FreezeTokensResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FreezeTokensResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FreezeTokensResponseMultiError, or nil if none found.
func (m *FreezeTokensResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FreezeTokensResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetImpactedLeafIds() {
		_, _ = idx, item

		if err := m._validateUuid(item); err != nil {
			err = FreezeTokensResponseValidationError{
				field:  fmt.Sprintf("ImpactedLeafIds[%v]", idx),
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for ImpactedTokenAmount

	if len(errors) > 0 {
		return FreezeTokensResponseMultiError(errors)
	}

	return nil
}

func (m *FreezeTokensResponse) _validateUuid(uuid string) error {
	if matched := _spark_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// FreezeTokensResponseMultiError is an error wrapping multiple validation
// errors returned by FreezeTokensResponse.ValidateAll() if the designated
// constraints aren't met.
type FreezeTokensResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FreezeTokensResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FreezeTokensResponseMultiError) AllErrors() []error { return m }

// FreezeTokensResponseValidationError is the validation error returned by
// FreezeTokensResponse.Validate if the designated constraints aren't met.
type FreezeTokensResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FreezeTokensResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FreezeTokensResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FreezeTokensResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FreezeTokensResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FreezeTokensResponseValidationError) ErrorName() string {
	return "FreezeTokensResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FreezeTokensResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFreezeTokensResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FreezeTokensResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FreezeTokensResponseValidationError{}

// Validate checks the field values on GetOwnedTokenLeavesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOwnedTokenLeavesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOwnedTokenLeavesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOwnedTokenLeavesRequestMultiError, or nil if none found.
func (m *GetOwnedTokenLeavesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOwnedTokenLeavesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetOwnerPublicKeys() {
		_, _ = idx, item

		if len(item) != 33 {
			err := GetOwnedTokenLeavesRequestValidationError{
				field:  fmt.Sprintf("OwnerPublicKeys[%v]", idx),
				reason: "value length must be 33 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetTokenPublicKeys() {
		_, _ = idx, item

		if len(item) != 33 {
			err := GetOwnedTokenLeavesRequestValidationError{
				field:  fmt.Sprintf("TokenPublicKeys[%v]", idx),
				reason: "value length must be 33 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return GetOwnedTokenLeavesRequestMultiError(errors)
	}

	return nil
}

// GetOwnedTokenLeavesRequestMultiError is an error wrapping multiple
// validation errors returned by GetOwnedTokenLeavesRequest.ValidateAll() if
// the designated constraints aren't met.
type GetOwnedTokenLeavesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOwnedTokenLeavesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOwnedTokenLeavesRequestMultiError) AllErrors() []error { return m }

// GetOwnedTokenLeavesRequestValidationError is the validation error returned
// by GetOwnedTokenLeavesRequest.Validate if the designated constraints aren't met.
type GetOwnedTokenLeavesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOwnedTokenLeavesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOwnedTokenLeavesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOwnedTokenLeavesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOwnedTokenLeavesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOwnedTokenLeavesRequestValidationError) ErrorName() string {
	return "GetOwnedTokenLeavesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetOwnedTokenLeavesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOwnedTokenLeavesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOwnedTokenLeavesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOwnedTokenLeavesRequestValidationError{}

// Validate checks the field values on QueryTokenTransactionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryTokenTransactionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryTokenTransactionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// QueryTokenTransactionsRequestMultiError, or nil if none found.
func (m *QueryTokenTransactionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryTokenTransactionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLeafIds() {
		_, _ = idx, item

		if err := m._validateUuid(item); err != nil {
			err = QueryTokenTransactionsRequestValidationError{
				field:  fmt.Sprintf("LeafIds[%v]", idx),
				reason: "value must be a valid UUID",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetOwnerPublicKeys() {
		_, _ = idx, item

		if len(item) != 33 {
			err := QueryTokenTransactionsRequestValidationError{
				field:  fmt.Sprintf("OwnerPublicKeys[%v]", idx),
				reason: "value length must be 33 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetTokenPublicKeys() {
		_, _ = idx, item

		if len(item) != 33 {
			err := QueryTokenTransactionsRequestValidationError{
				field:  fmt.Sprintf("TokenPublicKeys[%v]", idx),
				reason: "value length must be 33 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetTokenTransactionHashes() {
		_, _ = idx, item

		if len(item) != 32 {
			err := QueryTokenTransactionsRequestValidationError{
				field:  fmt.Sprintf("TokenTransactionHashes[%v]", idx),
				reason: "value length must be 32 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for Limit

	// no validation rules for Offset

	if len(errors) > 0 {
		return QueryTokenTransactionsRequestMultiError(errors)
	}

	return nil
}

func (m *QueryTokenTransactionsRequest) _validateUuid(uuid string) error {
	if matched := _spark_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// QueryTokenTransactionsRequestMultiError is an error wrapping multiple
// validation errors returned by QueryTokenTransactionsRequest.ValidateAll()
// if the designated constraints aren't met.
type QueryTokenTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryTokenTransactionsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryTokenTransactionsRequestMultiError) AllErrors() []error { return m }

// QueryTokenTransactionsRequestValidationError is the validation error
// returned by QueryTokenTransactionsRequest.Validate if the designated
// constraints aren't met.
type QueryTokenTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryTokenTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryTokenTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryTokenTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryTokenTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryTokenTransactionsRequestValidationError) ErrorName() string {
	return "QueryTokenTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryTokenTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryTokenTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryTokenTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryTokenTransactionsRequestValidationError{}

// Validate checks the field values on QueryTokenTransactionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryTokenTransactionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryTokenTransactionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// QueryTokenTransactionsResponseMultiError, or nil if none found.
func (m *QueryTokenTransactionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryTokenTransactionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTokenTransactionsWithStatus() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryTokenTransactionsResponseValidationError{
						field:  fmt.Sprintf("TokenTransactionsWithStatus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryTokenTransactionsResponseValidationError{
						field:  fmt.Sprintf("TokenTransactionsWithStatus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryTokenTransactionsResponseValidationError{
					field:  fmt.Sprintf("TokenTransactionsWithStatus[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Offset

	if len(errors) > 0 {
		return QueryTokenTransactionsResponseMultiError(errors)
	}

	return nil
}

// QueryTokenTransactionsResponseMultiError is an error wrapping multiple
// validation errors returned by QueryTokenTransactionsResponse.ValidateAll()
// if the designated constraints aren't met.
type QueryTokenTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryTokenTransactionsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryTokenTransactionsResponseMultiError) AllErrors() []error { return m }

// QueryTokenTransactionsResponseValidationError is the validation error
// returned by QueryTokenTransactionsResponse.Validate if the designated
// constraints aren't met.
type QueryTokenTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryTokenTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryTokenTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryTokenTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryTokenTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryTokenTransactionsResponseValidationError) ErrorName() string {
	return "QueryTokenTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryTokenTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryTokenTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryTokenTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryTokenTransactionsResponseValidationError{}

// Validate checks the field values on LeafWithPreviousTransactionData with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LeafWithPreviousTransactionData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeafWithPreviousTransactionData with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// LeafWithPreviousTransactionDataMultiError, or nil if none found.
func (m *LeafWithPreviousTransactionData) ValidateAll() error {
	return m.validate(true)
}

func (m *LeafWithPreviousTransactionData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLeaf()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeafWithPreviousTransactionDataValidationError{
					field:  "Leaf",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeafWithPreviousTransactionDataValidationError{
					field:  "Leaf",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLeaf()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeafWithPreviousTransactionDataValidationError{
				field:  "Leaf",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetPreviousTransactionHash()) != 32 {
		err := LeafWithPreviousTransactionDataValidationError{
			field:  "PreviousTransactionHash",
			reason: "value length must be 32 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for PreviousTransactionVout

	if len(errors) > 0 {
		return LeafWithPreviousTransactionDataMultiError(errors)
	}

	return nil
}

// LeafWithPreviousTransactionDataMultiError is an error wrapping multiple
// validation errors returned by LeafWithPreviousTransactionData.ValidateAll()
// if the designated constraints aren't met.
type LeafWithPreviousTransactionDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeafWithPreviousTransactionDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeafWithPreviousTransactionDataMultiError) AllErrors() []error { return m }

// LeafWithPreviousTransactionDataValidationError is the validation error
// returned by LeafWithPreviousTransactionData.Validate if the designated
// constraints aren't met.
type LeafWithPreviousTransactionDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeafWithPreviousTransactionDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeafWithPreviousTransactionDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeafWithPreviousTransactionDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeafWithPreviousTransactionDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeafWithPreviousTransactionDataValidationError) ErrorName() string {
	return "LeafWithPreviousTransactionDataValidationError"
}

// Error satisfies the builtin error interface
func (e LeafWithPreviousTransactionDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeafWithPreviousTransactionData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeafWithPreviousTransactionDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeafWithPreviousTransactionDataValidationError{}

// Validate checks the field values on GetOwnedTokenLeavesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetOwnedTokenLeavesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetOwnedTokenLeavesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetOwnedTokenLeavesResponseMultiError, or nil if none found.
func (m *GetOwnedTokenLeavesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetOwnedTokenLeavesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLeavesWithPreviousTransactionData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetOwnedTokenLeavesResponseValidationError{
						field:  fmt.Sprintf("LeavesWithPreviousTransactionData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetOwnedTokenLeavesResponseValidationError{
						field:  fmt.Sprintf("LeavesWithPreviousTransactionData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetOwnedTokenLeavesResponseValidationError{
					field:  fmt.Sprintf("LeavesWithPreviousTransactionData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetOwnedTokenLeavesResponseMultiError(errors)
	}

	return nil
}

// GetOwnedTokenLeavesResponseMultiError is an error wrapping multiple
// validation errors returned by GetOwnedTokenLeavesResponse.ValidateAll() if
// the designated constraints aren't met.
type GetOwnedTokenLeavesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetOwnedTokenLeavesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetOwnedTokenLeavesResponseMultiError) AllErrors() []error { return m }

// GetOwnedTokenLeavesResponseValidationError is the validation error returned
// by GetOwnedTokenLeavesResponse.Validate if the designated constraints
// aren't met.
type GetOwnedTokenLeavesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetOwnedTokenLeavesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetOwnedTokenLeavesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetOwnedTokenLeavesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetOwnedTokenLeavesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetOwnedTokenLeavesResponseValidationError) ErrorName() string {
	return "GetOwnedTokenLeavesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetOwnedTokenLeavesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetOwnedTokenLeavesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetOwnedTokenLeavesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetOwnedTokenLeavesResponseValidationError{}

// Validate checks the field values on CancelSignedTokenTransactionRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CancelSignedTokenTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelSignedTokenTransactionRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CancelSignedTokenTransactionRequestMultiError, or nil if none found.
func (m *CancelSignedTokenTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelSignedTokenTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CancelSignedTokenTransactionRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CancelSignedTokenTransactionRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CancelSignedTokenTransactionRequestValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetSenderIdentityPublicKey()) != 33 {
		err := CancelSignedTokenTransactionRequestValidationError{
			field:  "SenderIdentityPublicKey",
			reason: "value length must be 33 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CancelSignedTokenTransactionRequestMultiError(errors)
	}

	return nil
}

// CancelSignedTokenTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by
// CancelSignedTokenTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type CancelSignedTokenTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelSignedTokenTransactionRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelSignedTokenTransactionRequestMultiError) AllErrors() []error { return m }

// CancelSignedTokenTransactionRequestValidationError is the validation error
// returned by CancelSignedTokenTransactionRequest.Validate if the designated
// constraints aren't met.
type CancelSignedTokenTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelSignedTokenTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelSignedTokenTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelSignedTokenTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelSignedTokenTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelSignedTokenTransactionRequestValidationError) ErrorName() string {
	return "CancelSignedTokenTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CancelSignedTokenTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelSignedTokenTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelSignedTokenTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelSignedTokenTransactionRequestValidationError{}

// Validate checks the field values on TreeNode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TreeNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TreeNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TreeNodeMultiError, or nil
// if none found.
func (m *TreeNode) ValidateAll() error {
	return m.validate(true)
}

func (m *TreeNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for TreeId

	// no validation rules for Value

	// no validation rules for NodeTx

	// no validation rules for RefundTx

	// no validation rules for Vout

	// no validation rules for VerifyingPublicKey

	// no validation rules for OwnerIdentityPublicKey

	if all {
		switch v := interface{}(m.GetSigningKeyshare()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TreeNodeValidationError{
					field:  "SigningKeyshare",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TreeNodeValidationError{
					field:  "SigningKeyshare",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSigningKeyshare()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TreeNodeValidationError{
				field:  "SigningKeyshare",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Status

	// no validation rules for Network

	if m.ParentNodeId != nil {
		// no validation rules for ParentNodeId
	}

	if len(errors) > 0 {
		return TreeNodeMultiError(errors)
	}

	return nil
}

// TreeNodeMultiError is an error wrapping multiple validation errors returned
// by TreeNode.ValidateAll() if the designated constraints aren't met.
type TreeNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TreeNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TreeNodeMultiError) AllErrors() []error { return m }

// TreeNodeValidationError is the validation error returned by
// TreeNode.Validate if the designated constraints aren't met.
type TreeNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TreeNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TreeNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TreeNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TreeNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TreeNodeValidationError) ErrorName() string { return "TreeNodeValidationError" }

// Error satisfies the builtin error interface
func (e TreeNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTreeNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TreeNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TreeNodeValidationError{}

// Validate checks the field values on FinalizeNodeSignaturesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinalizeNodeSignaturesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeNodeSignaturesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// FinalizeNodeSignaturesRequestMultiError, or nil if none found.
func (m *FinalizeNodeSignaturesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeNodeSignaturesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Intent

	for idx, item := range m.GetNodeSignatures() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FinalizeNodeSignaturesRequestValidationError{
						field:  fmt.Sprintf("NodeSignatures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FinalizeNodeSignaturesRequestValidationError{
						field:  fmt.Sprintf("NodeSignatures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FinalizeNodeSignaturesRequestValidationError{
					field:  fmt.Sprintf("NodeSignatures[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FinalizeNodeSignaturesRequestMultiError(errors)
	}

	return nil
}

// FinalizeNodeSignaturesRequestMultiError is an error wrapping multiple
// validation errors returned by FinalizeNodeSignaturesRequest.ValidateAll()
// if the designated constraints aren't met.
type FinalizeNodeSignaturesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeNodeSignaturesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeNodeSignaturesRequestMultiError) AllErrors() []error { return m }

// FinalizeNodeSignaturesRequestValidationError is the validation error
// returned by FinalizeNodeSignaturesRequest.Validate if the designated
// constraints aren't met.
type FinalizeNodeSignaturesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeNodeSignaturesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeNodeSignaturesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeNodeSignaturesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeNodeSignaturesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeNodeSignaturesRequestValidationError) ErrorName() string {
	return "FinalizeNodeSignaturesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeNodeSignaturesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeNodeSignaturesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeNodeSignaturesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeNodeSignaturesRequestValidationError{}

// Validate checks the field values on FinalizeNodeSignaturesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinalizeNodeSignaturesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinalizeNodeSignaturesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// FinalizeNodeSignaturesResponseMultiError, or nil if none found.
func (m *FinalizeNodeSignaturesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FinalizeNodeSignaturesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNodes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FinalizeNodeSignaturesResponseValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FinalizeNodeSignaturesResponseValidationError{
						field:  fmt.Sprintf("Nodes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FinalizeNodeSignaturesResponseValidationError{
					field:  fmt.Sprintf("Nodes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FinalizeNodeSignaturesResponseMultiError(errors)
	}

	return nil
}

// FinalizeNodeSignaturesResponseMultiError is an error wrapping multiple
// validation errors returned by FinalizeNodeSignaturesResponse.ValidateAll()
// if the designated constraints aren't met.
type FinalizeNodeSignaturesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinalizeNodeSignaturesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinalizeNodeSignaturesResponseMultiError) AllErrors() []error { return m }

// FinalizeNodeSignaturesResponseValidationError is the validation error
// returned by FinalizeNodeSignaturesResponse.Validate if the designated
// constraints aren't met.
type FinalizeNodeSignaturesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinalizeNodeSignaturesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinalizeNodeSignaturesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinalizeNodeSignaturesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinalizeNodeSignaturesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinalizeNodeSignaturesResponseValidationError) ErrorName() string {
	return "FinalizeNodeSignaturesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FinalizeNodeSignaturesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinalizeNodeSignaturesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinalizeNodeSignaturesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinalizeNodeSignaturesResponseValidationError{}

// Validate checks the field values on SecretShare with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SecretShare) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecretShare with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SecretShareMultiError, or
// nil if none found.
func (m *SecretShare) ValidateAll() error {
	return m.validate(true)
}

func (m *SecretShare) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SecretShare

	if len(errors) > 0 {
		return SecretShareMultiError(errors)
	}

	return nil
}

// SecretShareMultiError is an error wrapping multiple validation errors
// returned by SecretShare.ValidateAll() if the designated constraints aren't met.
type SecretShareMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecretShareMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecretShareMultiError) AllErrors() []error { return m }

// SecretShareValidationError is the validation error returned by
// SecretShare.Validate if the designated constraints aren't met.
type SecretShareValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecretShareValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecretShareValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecretShareValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecretShareValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecretShareValidationError) ErrorName() string { return "SecretShareValidationError" }

// Error satisfies the builtin error interface
func (e SecretShareValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecretShare.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecretShareValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecretShareValidationError{}

// Validate checks the field values on SecretProof with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SecretProof) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecretProof with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SecretProofMultiError, or
// nil if none found.
func (m *SecretProof) ValidateAll() error {
	return m.validate(true)
}

func (m *SecretProof) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SecretProofMultiError(errors)
	}

	return nil
}

// SecretProofMultiError is an error wrapping multiple validation errors
// returned by SecretProof.ValidateAll() if the designated constraints aren't met.
type SecretProofMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecretProofMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecretProofMultiError) AllErrors() []error { return m }

// SecretProofValidationError is the validation error returned by
// SecretProof.Validate if the designated constraints aren't met.
type SecretProofValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecretProofValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecretProofValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecretProofValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecretProofValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecretProofValidationError) ErrorName() string { return "SecretProofValidationError" }

// Error satisfies the builtin error interface
func (e SecretProofValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecretProof.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecretProofValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecretProofValidationError{}

// Validate checks the field values on LeafRefundTxSigningJob with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LeafRefundTxSigningJob) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeafRefundTxSigningJob with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LeafRefundTxSigningJobMultiError, or nil if none found.
func (m *LeafRefundTxSigningJob) ValidateAll() error {
	return m.validate(true)
}

func (m *LeafRefundTxSigningJob) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeafId

	if all {
		switch v := interface{}(m.GetRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeafRefundTxSigningJobValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeafRefundTxSigningJobValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeafRefundTxSigningJobValidationError{
				field:  "RefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LeafRefundTxSigningJobMultiError(errors)
	}

	return nil
}

// LeafRefundTxSigningJobMultiError is an error wrapping multiple validation
// errors returned by LeafRefundTxSigningJob.ValidateAll() if the designated
// constraints aren't met.
type LeafRefundTxSigningJobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeafRefundTxSigningJobMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeafRefundTxSigningJobMultiError) AllErrors() []error { return m }

// LeafRefundTxSigningJobValidationError is the validation error returned by
// LeafRefundTxSigningJob.Validate if the designated constraints aren't met.
type LeafRefundTxSigningJobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeafRefundTxSigningJobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeafRefundTxSigningJobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeafRefundTxSigningJobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeafRefundTxSigningJobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeafRefundTxSigningJobValidationError) ErrorName() string {
	return "LeafRefundTxSigningJobValidationError"
}

// Error satisfies the builtin error interface
func (e LeafRefundTxSigningJobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeafRefundTxSigningJob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeafRefundTxSigningJobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeafRefundTxSigningJobValidationError{}

// Validate checks the field values on LeafRefundTxSigningResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LeafRefundTxSigningResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeafRefundTxSigningResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LeafRefundTxSigningResultMultiError, or nil if none found.
func (m *LeafRefundTxSigningResult) ValidateAll() error {
	return m.validate(true)
}

func (m *LeafRefundTxSigningResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeafId

	if all {
		switch v := interface{}(m.GetRefundTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeafRefundTxSigningResultValidationError{
					field:  "RefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeafRefundTxSigningResultValidationError{
					field:  "RefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeafRefundTxSigningResultValidationError{
				field:  "RefundTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for VerifyingKey

	if len(errors) > 0 {
		return LeafRefundTxSigningResultMultiError(errors)
	}

	return nil
}

// LeafRefundTxSigningResultMultiError is an error wrapping multiple validation
// errors returned by LeafRefundTxSigningResult.ValidateAll() if the
// designated constraints aren't met.
type LeafRefundTxSigningResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeafRefundTxSigningResultMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeafRefundTxSigningResultMultiError) AllErrors() []error { return m }

// LeafRefundTxSigningResultValidationError is the validation error returned by
// LeafRefundTxSigningResult.Validate if the designated constraints aren't met.
type LeafRefundTxSigningResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeafRefundTxSigningResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeafRefundTxSigningResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeafRefundTxSigningResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeafRefundTxSigningResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeafRefundTxSigningResultValidationError) ErrorName() string {
	return "LeafRefundTxSigningResultValidationError"
}

// Error satisfies the builtin error interface
func (e LeafRefundTxSigningResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeafRefundTxSigningResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeafRefundTxSigningResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeafRefundTxSigningResultValidationError{}

// Validate checks the field values on StartSendTransferRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartSendTransferRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartSendTransferRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartSendTransferRequestMultiError, or nil if none found.
func (m *StartSendTransferRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartSendTransferRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	// no validation rules for OwnerIdentityPublicKey

	for idx, item := range m.GetLeavesToSend() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StartSendTransferRequestValidationError{
						field:  fmt.Sprintf("LeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StartSendTransferRequestValidationError{
						field:  fmt.Sprintf("LeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StartSendTransferRequestValidationError{
					field:  fmt.Sprintf("LeavesToSend[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ReceiverIdentityPublicKey

	if all {
		switch v := interface{}(m.GetExpiryTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartSendTransferRequestValidationError{
					field:  "ExpiryTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartSendTransferRequestValidationError{
					field:  "ExpiryTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiryTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartSendTransferRequestValidationError{
				field:  "ExpiryTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetKeyTweakProofs()))
		i := 0
		for key := range m.GetKeyTweakProofs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetKeyTweakProofs()[key]
			_ = val

			// no validation rules for KeyTweakProofs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, StartSendTransferRequestValidationError{
							field:  fmt.Sprintf("KeyTweakProofs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, StartSendTransferRequestValidationError{
							field:  fmt.Sprintf("KeyTweakProofs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return StartSendTransferRequestValidationError{
						field:  fmt.Sprintf("KeyTweakProofs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return StartSendTransferRequestMultiError(errors)
	}

	return nil
}

// StartSendTransferRequestMultiError is an error wrapping multiple validation
// errors returned by StartSendTransferRequest.ValidateAll() if the designated
// constraints aren't met.
type StartSendTransferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartSendTransferRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartSendTransferRequestMultiError) AllErrors() []error { return m }

// StartSendTransferRequestValidationError is the validation error returned by
// StartSendTransferRequest.Validate if the designated constraints aren't met.
type StartSendTransferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartSendTransferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartSendTransferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartSendTransferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartSendTransferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartSendTransferRequestValidationError) ErrorName() string {
	return "StartSendTransferRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StartSendTransferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartSendTransferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartSendTransferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartSendTransferRequestValidationError{}

// Validate checks the field values on StartSendTransferResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartSendTransferResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartSendTransferResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartSendTransferResponseMultiError, or nil if none found.
func (m *StartSendTransferResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StartSendTransferResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartSendTransferResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartSendTransferResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartSendTransferResponseValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSigningResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StartSendTransferResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StartSendTransferResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StartSendTransferResponseValidationError{
					field:  fmt.Sprintf("SigningResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StartSendTransferResponseMultiError(errors)
	}

	return nil
}

// StartSendTransferResponseMultiError is an error wrapping multiple validation
// errors returned by StartSendTransferResponse.ValidateAll() if the
// designated constraints aren't met.
type StartSendTransferResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartSendTransferResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartSendTransferResponseMultiError) AllErrors() []error { return m }

// StartSendTransferResponseValidationError is the validation error returned by
// StartSendTransferResponse.Validate if the designated constraints aren't met.
type StartSendTransferResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartSendTransferResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartSendTransferResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartSendTransferResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartSendTransferResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartSendTransferResponseValidationError) ErrorName() string {
	return "StartSendTransferResponseValidationError"
}

// Error satisfies the builtin error interface
func (e StartSendTransferResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartSendTransferResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartSendTransferResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartSendTransferResponseValidationError{}

// Validate checks the field values on SendLeafKeyTweak with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SendLeafKeyTweak) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendLeafKeyTweak with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendLeafKeyTweakMultiError, or nil if none found.
func (m *SendLeafKeyTweak) ValidateAll() error {
	return m.validate(true)
}

func (m *SendLeafKeyTweak) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeafId

	if all {
		switch v := interface{}(m.GetSecretShareTweak()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendLeafKeyTweakValidationError{
					field:  "SecretShareTweak",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendLeafKeyTweakValidationError{
					field:  "SecretShareTweak",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecretShareTweak()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendLeafKeyTweakValidationError{
				field:  "SecretShareTweak",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PubkeySharesTweak

	// no validation rules for SecretCipher

	// no validation rules for Signature

	// no validation rules for RefundSignature

	if len(errors) > 0 {
		return SendLeafKeyTweakMultiError(errors)
	}

	return nil
}

// SendLeafKeyTweakMultiError is an error wrapping multiple validation errors
// returned by SendLeafKeyTweak.ValidateAll() if the designated constraints
// aren't met.
type SendLeafKeyTweakMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendLeafKeyTweakMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendLeafKeyTweakMultiError) AllErrors() []error { return m }

// SendLeafKeyTweakValidationError is the validation error returned by
// SendLeafKeyTweak.Validate if the designated constraints aren't met.
type SendLeafKeyTweakValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendLeafKeyTweakValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendLeafKeyTweakValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendLeafKeyTweakValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendLeafKeyTweakValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendLeafKeyTweakValidationError) ErrorName() string { return "SendLeafKeyTweakValidationError" }

// Error satisfies the builtin error interface
func (e SendLeafKeyTweakValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendLeafKeyTweak.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendLeafKeyTweakValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendLeafKeyTweakValidationError{}

// Validate checks the field values on CompleteSendTransferRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CompleteSendTransferRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompleteSendTransferRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompleteSendTransferRequestMultiError, or nil if none found.
func (m *CompleteSendTransferRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CompleteSendTransferRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	// no validation rules for OwnerIdentityPublicKey

	for idx, item := range m.GetLeavesToSend() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CompleteSendTransferRequestValidationError{
						field:  fmt.Sprintf("LeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CompleteSendTransferRequestValidationError{
						field:  fmt.Sprintf("LeavesToSend[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CompleteSendTransferRequestValidationError{
					field:  fmt.Sprintf("LeavesToSend[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CompleteSendTransferRequestMultiError(errors)
	}

	return nil
}

// CompleteSendTransferRequestMultiError is an error wrapping multiple
// validation errors returned by CompleteSendTransferRequest.ValidateAll() if
// the designated constraints aren't met.
type CompleteSendTransferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompleteSendTransferRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompleteSendTransferRequestMultiError) AllErrors() []error { return m }

// CompleteSendTransferRequestValidationError is the validation error returned
// by CompleteSendTransferRequest.Validate if the designated constraints
// aren't met.
type CompleteSendTransferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompleteSendTransferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompleteSendTransferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompleteSendTransferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompleteSendTransferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompleteSendTransferRequestValidationError) ErrorName() string {
	return "CompleteSendTransferRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CompleteSendTransferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompleteSendTransferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompleteSendTransferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompleteSendTransferRequestValidationError{}

// Validate checks the field values on Transfer with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transfer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transfer with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransferMultiError, or nil
// if none found.
func (m *Transfer) ValidateAll() error {
	return m.validate(true)
}

func (m *Transfer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for SenderIdentityPublicKey

	// no validation rules for ReceiverIdentityPublicKey

	// no validation rules for Status

	// no validation rules for TotalValue

	if all {
		switch v := interface{}(m.GetExpiryTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransferValidationError{
					field:  "ExpiryTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransferValidationError{
					field:  "ExpiryTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpiryTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransferValidationError{
				field:  "ExpiryTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLeaves() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransferValidationError{
						field:  fmt.Sprintf("Leaves[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransferValidationError{
						field:  fmt.Sprintf("Leaves[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransferValidationError{
					field:  fmt.Sprintf("Leaves[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCreatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransferValidationError{
					field:  "CreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransferValidationError{
					field:  "CreatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransferValidationError{
				field:  "CreatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransferValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransferValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransferValidationError{
				field:  "UpdatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransferMultiError(errors)
	}

	return nil
}

// TransferMultiError is an error wrapping multiple validation errors returned
// by Transfer.ValidateAll() if the designated constraints aren't met.
type TransferMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferMultiError) AllErrors() []error { return m }

// TransferValidationError is the validation error returned by
// Transfer.Validate if the designated constraints aren't met.
type TransferValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferValidationError) ErrorName() string { return "TransferValidationError" }

// Error satisfies the builtin error interface
func (e TransferValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransfer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferValidationError{}

// Validate checks the field values on TransferLeaf with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TransferLeaf) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransferLeaf with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransferLeafMultiError, or
// nil if none found.
func (m *TransferLeaf) ValidateAll() error {
	return m.validate(true)
}

func (m *TransferLeaf) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLeaf()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransferLeafValidationError{
					field:  "Leaf",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransferLeafValidationError{
					field:  "Leaf",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLeaf()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransferLeafValidationError{
				field:  "Leaf",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SecretCipher

	// no validation rules for Signature

	// no validation rules for IntermediateRefundTx

	if len(errors) > 0 {
		return TransferLeafMultiError(errors)
	}

	return nil
}

// TransferLeafMultiError is an error wrapping multiple validation errors
// returned by TransferLeaf.ValidateAll() if the designated constraints aren't met.
type TransferLeafMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferLeafMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferLeafMultiError) AllErrors() []error { return m }

// TransferLeafValidationError is the validation error returned by
// TransferLeaf.Validate if the designated constraints aren't met.
type TransferLeafValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferLeafValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferLeafValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferLeafValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferLeafValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferLeafValidationError) ErrorName() string { return "TransferLeafValidationError" }

// Error satisfies the builtin error interface
func (e TransferLeafValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferLeaf.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferLeafValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferLeafValidationError{}

// Validate checks the field values on CompleteSendTransferResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CompleteSendTransferResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompleteSendTransferResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompleteSendTransferResponseMultiError, or nil if none found.
func (m *CompleteSendTransferResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CompleteSendTransferResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompleteSendTransferResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompleteSendTransferResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompleteSendTransferResponseValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CompleteSendTransferResponseMultiError(errors)
	}

	return nil
}

// CompleteSendTransferResponseMultiError is an error wrapping multiple
// validation errors returned by CompleteSendTransferResponse.ValidateAll() if
// the designated constraints aren't met.
type CompleteSendTransferResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompleteSendTransferResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompleteSendTransferResponseMultiError) AllErrors() []error { return m }

// CompleteSendTransferResponseValidationError is the validation error returned
// by CompleteSendTransferResponse.Validate if the designated constraints
// aren't met.
type CompleteSendTransferResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompleteSendTransferResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompleteSendTransferResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompleteSendTransferResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompleteSendTransferResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompleteSendTransferResponseValidationError) ErrorName() string {
	return "CompleteSendTransferResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CompleteSendTransferResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompleteSendTransferResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompleteSendTransferResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompleteSendTransferResponseValidationError{}

// Validate checks the field values on QueryPendingTransfersRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryPendingTransfersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryPendingTransfersRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryPendingTransfersRequestMultiError, or nil if none found.
func (m *QueryPendingTransfersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryPendingTransfersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Participant.(type) {
	case *QueryPendingTransfersRequest_ReceiverIdentityPublicKey:
		if v == nil {
			err := QueryPendingTransfersRequestValidationError{
				field:  "Participant",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for ReceiverIdentityPublicKey
	case *QueryPendingTransfersRequest_SenderIdentityPublicKey:
		if v == nil {
			err := QueryPendingTransfersRequestValidationError{
				field:  "Participant",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for SenderIdentityPublicKey
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return QueryPendingTransfersRequestMultiError(errors)
	}

	return nil
}

// QueryPendingTransfersRequestMultiError is an error wrapping multiple
// validation errors returned by QueryPendingTransfersRequest.ValidateAll() if
// the designated constraints aren't met.
type QueryPendingTransfersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryPendingTransfersRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryPendingTransfersRequestMultiError) AllErrors() []error { return m }

// QueryPendingTransfersRequestValidationError is the validation error returned
// by QueryPendingTransfersRequest.Validate if the designated constraints
// aren't met.
type QueryPendingTransfersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryPendingTransfersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryPendingTransfersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryPendingTransfersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryPendingTransfersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryPendingTransfersRequestValidationError) ErrorName() string {
	return "QueryPendingTransfersRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryPendingTransfersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryPendingTransfersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryPendingTransfersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryPendingTransfersRequestValidationError{}

// Validate checks the field values on QueryPendingTransfersResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryPendingTransfersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryPendingTransfersResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// QueryPendingTransfersResponseMultiError, or nil if none found.
func (m *QueryPendingTransfersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryPendingTransfersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransfers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryPendingTransfersResponseValidationError{
						field:  fmt.Sprintf("Transfers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryPendingTransfersResponseValidationError{
						field:  fmt.Sprintf("Transfers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryPendingTransfersResponseValidationError{
					field:  fmt.Sprintf("Transfers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QueryPendingTransfersResponseMultiError(errors)
	}

	return nil
}

// QueryPendingTransfersResponseMultiError is an error wrapping multiple
// validation errors returned by QueryPendingTransfersResponse.ValidateAll()
// if the designated constraints aren't met.
type QueryPendingTransfersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryPendingTransfersResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryPendingTransfersResponseMultiError) AllErrors() []error { return m }

// QueryPendingTransfersResponseValidationError is the validation error
// returned by QueryPendingTransfersResponse.Validate if the designated
// constraints aren't met.
type QueryPendingTransfersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryPendingTransfersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryPendingTransfersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryPendingTransfersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryPendingTransfersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryPendingTransfersResponseValidationError) ErrorName() string {
	return "QueryPendingTransfersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryPendingTransfersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryPendingTransfersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryPendingTransfersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryPendingTransfersResponseValidationError{}

// Validate checks the field values on ClaimLeafKeyTweak with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ClaimLeafKeyTweak) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClaimLeafKeyTweak with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClaimLeafKeyTweakMultiError, or nil if none found.
func (m *ClaimLeafKeyTweak) ValidateAll() error {
	return m.validate(true)
}

func (m *ClaimLeafKeyTweak) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeafId

	if all {
		switch v := interface{}(m.GetSecretShareTweak()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClaimLeafKeyTweakValidationError{
					field:  "SecretShareTweak",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClaimLeafKeyTweakValidationError{
					field:  "SecretShareTweak",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecretShareTweak()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClaimLeafKeyTweakValidationError{
				field:  "SecretShareTweak",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PubkeySharesTweak

	if len(errors) > 0 {
		return ClaimLeafKeyTweakMultiError(errors)
	}

	return nil
}

// ClaimLeafKeyTweakMultiError is an error wrapping multiple validation errors
// returned by ClaimLeafKeyTweak.ValidateAll() if the designated constraints
// aren't met.
type ClaimLeafKeyTweakMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClaimLeafKeyTweakMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClaimLeafKeyTweakMultiError) AllErrors() []error { return m }

// ClaimLeafKeyTweakValidationError is the validation error returned by
// ClaimLeafKeyTweak.Validate if the designated constraints aren't met.
type ClaimLeafKeyTweakValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClaimLeafKeyTweakValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClaimLeafKeyTweakValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClaimLeafKeyTweakValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClaimLeafKeyTweakValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClaimLeafKeyTweakValidationError) ErrorName() string {
	return "ClaimLeafKeyTweakValidationError"
}

// Error satisfies the builtin error interface
func (e ClaimLeafKeyTweakValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClaimLeafKeyTweak.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClaimLeafKeyTweakValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClaimLeafKeyTweakValidationError{}

// Validate checks the field values on ClaimTransferTweakKeysRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClaimTransferTweakKeysRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClaimTransferTweakKeysRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ClaimTransferTweakKeysRequestMultiError, or nil if none found.
func (m *ClaimTransferTweakKeysRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ClaimTransferTweakKeysRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	// no validation rules for OwnerIdentityPublicKey

	for idx, item := range m.GetLeavesToReceive() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClaimTransferTweakKeysRequestValidationError{
						field:  fmt.Sprintf("LeavesToReceive[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClaimTransferTweakKeysRequestValidationError{
						field:  fmt.Sprintf("LeavesToReceive[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClaimTransferTweakKeysRequestValidationError{
					field:  fmt.Sprintf("LeavesToReceive[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ClaimTransferTweakKeysRequestMultiError(errors)
	}

	return nil
}

// ClaimTransferTweakKeysRequestMultiError is an error wrapping multiple
// validation errors returned by ClaimTransferTweakKeysRequest.ValidateAll()
// if the designated constraints aren't met.
type ClaimTransferTweakKeysRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClaimTransferTweakKeysRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClaimTransferTweakKeysRequestMultiError) AllErrors() []error { return m }

// ClaimTransferTweakKeysRequestValidationError is the validation error
// returned by ClaimTransferTweakKeysRequest.Validate if the designated
// constraints aren't met.
type ClaimTransferTweakKeysRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClaimTransferTweakKeysRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClaimTransferTweakKeysRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClaimTransferTweakKeysRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClaimTransferTweakKeysRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClaimTransferTweakKeysRequestValidationError) ErrorName() string {
	return "ClaimTransferTweakKeysRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ClaimTransferTweakKeysRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClaimTransferTweakKeysRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClaimTransferTweakKeysRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClaimTransferTweakKeysRequestValidationError{}

// Validate checks the field values on ClaimTransferSignRefundsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClaimTransferSignRefundsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClaimTransferSignRefundsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ClaimTransferSignRefundsRequestMultiError, or nil if none found.
func (m *ClaimTransferSignRefundsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ClaimTransferSignRefundsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	// no validation rules for OwnerIdentityPublicKey

	for idx, item := range m.GetSigningJobs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClaimTransferSignRefundsRequestValidationError{
						field:  fmt.Sprintf("SigningJobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClaimTransferSignRefundsRequestValidationError{
						field:  fmt.Sprintf("SigningJobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClaimTransferSignRefundsRequestValidationError{
					field:  fmt.Sprintf("SigningJobs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	{
		sorted_keys := make([]string, len(m.GetKeyTweakProofs()))
		i := 0
		for key := range m.GetKeyTweakProofs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetKeyTweakProofs()[key]
			_ = val

			// no validation rules for KeyTweakProofs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ClaimTransferSignRefundsRequestValidationError{
							field:  fmt.Sprintf("KeyTweakProofs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ClaimTransferSignRefundsRequestValidationError{
							field:  fmt.Sprintf("KeyTweakProofs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ClaimTransferSignRefundsRequestValidationError{
						field:  fmt.Sprintf("KeyTweakProofs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return ClaimTransferSignRefundsRequestMultiError(errors)
	}

	return nil
}

// ClaimTransferSignRefundsRequestMultiError is an error wrapping multiple
// validation errors returned by ClaimTransferSignRefundsRequest.ValidateAll()
// if the designated constraints aren't met.
type ClaimTransferSignRefundsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClaimTransferSignRefundsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClaimTransferSignRefundsRequestMultiError) AllErrors() []error { return m }

// ClaimTransferSignRefundsRequestValidationError is the validation error
// returned by ClaimTransferSignRefundsRequest.Validate if the designated
// constraints aren't met.
type ClaimTransferSignRefundsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClaimTransferSignRefundsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClaimTransferSignRefundsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClaimTransferSignRefundsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClaimTransferSignRefundsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClaimTransferSignRefundsRequestValidationError) ErrorName() string {
	return "ClaimTransferSignRefundsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ClaimTransferSignRefundsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClaimTransferSignRefundsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClaimTransferSignRefundsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClaimTransferSignRefundsRequestValidationError{}

// Validate checks the field values on ClaimTransferSignRefundsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ClaimTransferSignRefundsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClaimTransferSignRefundsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ClaimTransferSignRefundsResponseMultiError, or nil if none found.
func (m *ClaimTransferSignRefundsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ClaimTransferSignRefundsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSigningResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ClaimTransferSignRefundsResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ClaimTransferSignRefundsResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ClaimTransferSignRefundsResponseValidationError{
					field:  fmt.Sprintf("SigningResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ClaimTransferSignRefundsResponseMultiError(errors)
	}

	return nil
}

// ClaimTransferSignRefundsResponseMultiError is an error wrapping multiple
// validation errors returned by
// ClaimTransferSignRefundsResponse.ValidateAll() if the designated
// constraints aren't met.
type ClaimTransferSignRefundsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClaimTransferSignRefundsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClaimTransferSignRefundsResponseMultiError) AllErrors() []error { return m }

// ClaimTransferSignRefundsResponseValidationError is the validation error
// returned by ClaimTransferSignRefundsResponse.Validate if the designated
// constraints aren't met.
type ClaimTransferSignRefundsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClaimTransferSignRefundsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClaimTransferSignRefundsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClaimTransferSignRefundsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClaimTransferSignRefundsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClaimTransferSignRefundsResponseValidationError) ErrorName() string {
	return "ClaimTransferSignRefundsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ClaimTransferSignRefundsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClaimTransferSignRefundsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClaimTransferSignRefundsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClaimTransferSignRefundsResponseValidationError{}

// Validate checks the field values on AggregateNodesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AggregateNodesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AggregateNodesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AggregateNodesRequestMultiError, or nil if none found.
func (m *AggregateNodesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AggregateNodesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AggregateNodesRequestValidationError{
					field:  "SigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AggregateNodesRequestValidationError{
					field:  "SigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AggregateNodesRequestValidationError{
				field:  "SigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OwnerIdentityPublicKey

	if len(errors) > 0 {
		return AggregateNodesRequestMultiError(errors)
	}

	return nil
}

// AggregateNodesRequestMultiError is an error wrapping multiple validation
// errors returned by AggregateNodesRequest.ValidateAll() if the designated
// constraints aren't met.
type AggregateNodesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AggregateNodesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AggregateNodesRequestMultiError) AllErrors() []error { return m }

// AggregateNodesRequestValidationError is the validation error returned by
// AggregateNodesRequest.Validate if the designated constraints aren't met.
type AggregateNodesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AggregateNodesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AggregateNodesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AggregateNodesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AggregateNodesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AggregateNodesRequestValidationError) ErrorName() string {
	return "AggregateNodesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AggregateNodesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAggregateNodesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AggregateNodesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AggregateNodesRequestValidationError{}

// Validate checks the field values on AggregateNodesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AggregateNodesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AggregateNodesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AggregateNodesResponseMultiError, or nil if none found.
func (m *AggregateNodesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AggregateNodesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAggregateSignature()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AggregateNodesResponseValidationError{
					field:  "AggregateSignature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AggregateNodesResponseValidationError{
					field:  "AggregateSignature",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAggregateSignature()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AggregateNodesResponseValidationError{
				field:  "AggregateSignature",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for VerifyingKey

	// no validation rules for ParentNodeTx

	// no validation rules for ParentNodeVout

	if len(errors) > 0 {
		return AggregateNodesResponseMultiError(errors)
	}

	return nil
}

// AggregateNodesResponseMultiError is an error wrapping multiple validation
// errors returned by AggregateNodesResponse.ValidateAll() if the designated
// constraints aren't met.
type AggregateNodesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AggregateNodesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AggregateNodesResponseMultiError) AllErrors() []error { return m }

// AggregateNodesResponseValidationError is the validation error returned by
// AggregateNodesResponse.Validate if the designated constraints aren't met.
type AggregateNodesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AggregateNodesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AggregateNodesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AggregateNodesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AggregateNodesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AggregateNodesResponseValidationError) ErrorName() string {
	return "AggregateNodesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AggregateNodesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAggregateNodesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AggregateNodesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AggregateNodesResponseValidationError{}

// Validate checks the field values on StorePreimageShareRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StorePreimageShareRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StorePreimageShareRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StorePreimageShareRequestMultiError, or nil if none found.
func (m *StorePreimageShareRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StorePreimageShareRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentHash

	if all {
		switch v := interface{}(m.GetPreimageShare()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StorePreimageShareRequestValidationError{
					field:  "PreimageShare",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StorePreimageShareRequestValidationError{
					field:  "PreimageShare",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPreimageShare()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StorePreimageShareRequestValidationError{
				field:  "PreimageShare",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Threshold

	// no validation rules for InvoiceString

	// no validation rules for UserIdentityPublicKey

	if len(errors) > 0 {
		return StorePreimageShareRequestMultiError(errors)
	}

	return nil
}

// StorePreimageShareRequestMultiError is an error wrapping multiple validation
// errors returned by StorePreimageShareRequest.ValidateAll() if the
// designated constraints aren't met.
type StorePreimageShareRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StorePreimageShareRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StorePreimageShareRequestMultiError) AllErrors() []error { return m }

// StorePreimageShareRequestValidationError is the validation error returned by
// StorePreimageShareRequest.Validate if the designated constraints aren't met.
type StorePreimageShareRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StorePreimageShareRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StorePreimageShareRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StorePreimageShareRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StorePreimageShareRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StorePreimageShareRequestValidationError) ErrorName() string {
	return "StorePreimageShareRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StorePreimageShareRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStorePreimageShareRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StorePreimageShareRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StorePreimageShareRequestValidationError{}

// Validate checks the field values on RequestedSigningCommitments with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RequestedSigningCommitments) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestedSigningCommitments with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RequestedSigningCommitmentsMultiError, or nil if none found.
func (m *RequestedSigningCommitments) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestedSigningCommitments) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetSigningNonceCommitments()))
		i := 0
		for key := range m.GetSigningNonceCommitments() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSigningNonceCommitments()[key]
			_ = val

			// no validation rules for SigningNonceCommitments[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, RequestedSigningCommitmentsValidationError{
							field:  fmt.Sprintf("SigningNonceCommitments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, RequestedSigningCommitmentsValidationError{
							field:  fmt.Sprintf("SigningNonceCommitments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return RequestedSigningCommitmentsValidationError{
						field:  fmt.Sprintf("SigningNonceCommitments[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return RequestedSigningCommitmentsMultiError(errors)
	}

	return nil
}

// RequestedSigningCommitmentsMultiError is an error wrapping multiple
// validation errors returned by RequestedSigningCommitments.ValidateAll() if
// the designated constraints aren't met.
type RequestedSigningCommitmentsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestedSigningCommitmentsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestedSigningCommitmentsMultiError) AllErrors() []error { return m }

// RequestedSigningCommitmentsValidationError is the validation error returned
// by RequestedSigningCommitments.Validate if the designated constraints
// aren't met.
type RequestedSigningCommitmentsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestedSigningCommitmentsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestedSigningCommitmentsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestedSigningCommitmentsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestedSigningCommitmentsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestedSigningCommitmentsValidationError) ErrorName() string {
	return "RequestedSigningCommitmentsValidationError"
}

// Error satisfies the builtin error interface
func (e RequestedSigningCommitmentsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestedSigningCommitments.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestedSigningCommitmentsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestedSigningCommitmentsValidationError{}

// Validate checks the field values on GetSigningCommitmentsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSigningCommitmentsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSigningCommitmentsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSigningCommitmentsRequestMultiError, or nil if none found.
func (m *GetSigningCommitmentsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSigningCommitmentsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetSigningCommitmentsRequestMultiError(errors)
	}

	return nil
}

// GetSigningCommitmentsRequestMultiError is an error wrapping multiple
// validation errors returned by GetSigningCommitmentsRequest.ValidateAll() if
// the designated constraints aren't met.
type GetSigningCommitmentsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSigningCommitmentsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSigningCommitmentsRequestMultiError) AllErrors() []error { return m }

// GetSigningCommitmentsRequestValidationError is the validation error returned
// by GetSigningCommitmentsRequest.Validate if the designated constraints
// aren't met.
type GetSigningCommitmentsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSigningCommitmentsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSigningCommitmentsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSigningCommitmentsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSigningCommitmentsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSigningCommitmentsRequestValidationError) ErrorName() string {
	return "GetSigningCommitmentsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSigningCommitmentsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSigningCommitmentsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSigningCommitmentsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSigningCommitmentsRequestValidationError{}

// Validate checks the field values on GetSigningCommitmentsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSigningCommitmentsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSigningCommitmentsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetSigningCommitmentsResponseMultiError, or nil if none found.
func (m *GetSigningCommitmentsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSigningCommitmentsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSigningCommitments() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetSigningCommitmentsResponseValidationError{
						field:  fmt.Sprintf("SigningCommitments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetSigningCommitmentsResponseValidationError{
						field:  fmt.Sprintf("SigningCommitments[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetSigningCommitmentsResponseValidationError{
					field:  fmt.Sprintf("SigningCommitments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetSigningCommitmentsResponseMultiError(errors)
	}

	return nil
}

// GetSigningCommitmentsResponseMultiError is an error wrapping multiple
// validation errors returned by GetSigningCommitmentsResponse.ValidateAll()
// if the designated constraints aren't met.
type GetSigningCommitmentsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSigningCommitmentsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSigningCommitmentsResponseMultiError) AllErrors() []error { return m }

// GetSigningCommitmentsResponseValidationError is the validation error
// returned by GetSigningCommitmentsResponse.Validate if the designated
// constraints aren't met.
type GetSigningCommitmentsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSigningCommitmentsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSigningCommitmentsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSigningCommitmentsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSigningCommitmentsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSigningCommitmentsResponseValidationError) ErrorName() string {
	return "GetSigningCommitmentsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSigningCommitmentsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSigningCommitmentsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSigningCommitmentsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSigningCommitmentsResponseValidationError{}

// Validate checks the field values on SigningCommitments with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SigningCommitments) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SigningCommitments with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SigningCommitmentsMultiError, or nil if none found.
func (m *SigningCommitments) ValidateAll() error {
	return m.validate(true)
}

func (m *SigningCommitments) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetSigningCommitments()))
		i := 0
		for key := range m.GetSigningCommitments() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSigningCommitments()[key]
			_ = val

			// no validation rules for SigningCommitments[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, SigningCommitmentsValidationError{
							field:  fmt.Sprintf("SigningCommitments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, SigningCommitmentsValidationError{
							field:  fmt.Sprintf("SigningCommitments[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return SigningCommitmentsValidationError{
						field:  fmt.Sprintf("SigningCommitments[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return SigningCommitmentsMultiError(errors)
	}

	return nil
}

// SigningCommitmentsMultiError is an error wrapping multiple validation errors
// returned by SigningCommitments.ValidateAll() if the designated constraints
// aren't met.
type SigningCommitmentsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SigningCommitmentsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SigningCommitmentsMultiError) AllErrors() []error { return m }

// SigningCommitmentsValidationError is the validation error returned by
// SigningCommitments.Validate if the designated constraints aren't met.
type SigningCommitmentsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SigningCommitmentsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SigningCommitmentsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SigningCommitmentsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SigningCommitmentsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SigningCommitmentsValidationError) ErrorName() string {
	return "SigningCommitmentsValidationError"
}

// Error satisfies the builtin error interface
func (e SigningCommitmentsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSigningCommitments.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SigningCommitmentsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SigningCommitmentsValidationError{}

// Validate checks the field values on UserSignedRefund with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserSignedRefund) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserSignedRefund with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserSignedRefundMultiError, or nil if none found.
func (m *UserSignedRefund) ValidateAll() error {
	return m.validate(true)
}

func (m *UserSignedRefund) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeId

	// no validation rules for RefundTx

	// no validation rules for UserSignature

	if all {
		switch v := interface{}(m.GetSigningCommitments()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserSignedRefundValidationError{
					field:  "SigningCommitments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserSignedRefundValidationError{
					field:  "SigningCommitments",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSigningCommitments()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserSignedRefundValidationError{
				field:  "SigningCommitments",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUserSignatureCommitment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UserSignedRefundValidationError{
					field:  "UserSignatureCommitment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UserSignedRefundValidationError{
					field:  "UserSignatureCommitment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserSignatureCommitment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UserSignedRefundValidationError{
				field:  "UserSignatureCommitment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Network

	if len(errors) > 0 {
		return UserSignedRefundMultiError(errors)
	}

	return nil
}

// UserSignedRefundMultiError is an error wrapping multiple validation errors
// returned by UserSignedRefund.ValidateAll() if the designated constraints
// aren't met.
type UserSignedRefundMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserSignedRefundMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserSignedRefundMultiError) AllErrors() []error { return m }

// UserSignedRefundValidationError is the validation error returned by
// UserSignedRefund.Validate if the designated constraints aren't met.
type UserSignedRefundValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserSignedRefundValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserSignedRefundValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserSignedRefundValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserSignedRefundValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserSignedRefundValidationError) ErrorName() string { return "UserSignedRefundValidationError" }

// Error satisfies the builtin error interface
func (e UserSignedRefundValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserSignedRefund.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserSignedRefundValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserSignedRefundValidationError{}

// Validate checks the field values on InvoiceAmountProof with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InvoiceAmountProof) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceAmountProof with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InvoiceAmountProofMultiError, or nil if none found.
func (m *InvoiceAmountProof) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceAmountProof) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bolt11Invoice

	if len(errors) > 0 {
		return InvoiceAmountProofMultiError(errors)
	}

	return nil
}

// InvoiceAmountProofMultiError is an error wrapping multiple validation errors
// returned by InvoiceAmountProof.ValidateAll() if the designated constraints
// aren't met.
type InvoiceAmountProofMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceAmountProofMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceAmountProofMultiError) AllErrors() []error { return m }

// InvoiceAmountProofValidationError is the validation error returned by
// InvoiceAmountProof.Validate if the designated constraints aren't met.
type InvoiceAmountProofValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceAmountProofValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceAmountProofValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceAmountProofValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceAmountProofValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceAmountProofValidationError) ErrorName() string {
	return "InvoiceAmountProofValidationError"
}

// Error satisfies the builtin error interface
func (e InvoiceAmountProofValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceAmountProof.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceAmountProofValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceAmountProofValidationError{}

// Validate checks the field values on InvoiceAmount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InvoiceAmount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceAmount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvoiceAmountMultiError, or
// nil if none found.
func (m *InvoiceAmount) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceAmount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ValueSats

	if all {
		switch v := interface{}(m.GetInvoiceAmountProof()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceAmountValidationError{
					field:  "InvoiceAmountProof",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceAmountValidationError{
					field:  "InvoiceAmountProof",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceAmountProof()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceAmountValidationError{
				field:  "InvoiceAmountProof",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InvoiceAmountMultiError(errors)
	}

	return nil
}

// InvoiceAmountMultiError is an error wrapping multiple validation errors
// returned by InvoiceAmount.ValidateAll() if the designated constraints
// aren't met.
type InvoiceAmountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceAmountMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceAmountMultiError) AllErrors() []error { return m }

// InvoiceAmountValidationError is the validation error returned by
// InvoiceAmount.Validate if the designated constraints aren't met.
type InvoiceAmountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceAmountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceAmountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceAmountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceAmountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceAmountValidationError) ErrorName() string { return "InvoiceAmountValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceAmountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceAmount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceAmountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceAmountValidationError{}

// Validate checks the field values on InitiatePreimageSwapRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiatePreimageSwapRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiatePreimageSwapRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitiatePreimageSwapRequestMultiError, or nil if none found.
func (m *InitiatePreimageSwapRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiatePreimageSwapRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentHash

	for idx, item := range m.GetUserSignedRefunds() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InitiatePreimageSwapRequestValidationError{
						field:  fmt.Sprintf("UserSignedRefunds[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InitiatePreimageSwapRequestValidationError{
						field:  fmt.Sprintf("UserSignedRefunds[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InitiatePreimageSwapRequestValidationError{
					field:  fmt.Sprintf("UserSignedRefunds[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetInvoiceAmount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiatePreimageSwapRequestValidationError{
					field:  "InvoiceAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiatePreimageSwapRequestValidationError{
					field:  "InvoiceAmount",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceAmount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiatePreimageSwapRequestValidationError{
				field:  "InvoiceAmount",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reason

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiatePreimageSwapRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiatePreimageSwapRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiatePreimageSwapRequestValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ReceiverIdentityPublicKey

	// no validation rules for FeeSats

	if len(errors) > 0 {
		return InitiatePreimageSwapRequestMultiError(errors)
	}

	return nil
}

// InitiatePreimageSwapRequestMultiError is an error wrapping multiple
// validation errors returned by InitiatePreimageSwapRequest.ValidateAll() if
// the designated constraints aren't met.
type InitiatePreimageSwapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiatePreimageSwapRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiatePreimageSwapRequestMultiError) AllErrors() []error { return m }

// InitiatePreimageSwapRequestValidationError is the validation error returned
// by InitiatePreimageSwapRequest.Validate if the designated constraints
// aren't met.
type InitiatePreimageSwapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiatePreimageSwapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiatePreimageSwapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiatePreimageSwapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiatePreimageSwapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiatePreimageSwapRequestValidationError) ErrorName() string {
	return "InitiatePreimageSwapRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InitiatePreimageSwapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiatePreimageSwapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiatePreimageSwapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiatePreimageSwapRequestValidationError{}

// Validate checks the field values on InitiatePreimageSwapResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitiatePreimageSwapResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitiatePreimageSwapResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitiatePreimageSwapResponseMultiError, or nil if none found.
func (m *InitiatePreimageSwapResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *InitiatePreimageSwapResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Preimage

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InitiatePreimageSwapResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InitiatePreimageSwapResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InitiatePreimageSwapResponseValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InitiatePreimageSwapResponseMultiError(errors)
	}

	return nil
}

// InitiatePreimageSwapResponseMultiError is an error wrapping multiple
// validation errors returned by InitiatePreimageSwapResponse.ValidateAll() if
// the designated constraints aren't met.
type InitiatePreimageSwapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitiatePreimageSwapResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitiatePreimageSwapResponseMultiError) AllErrors() []error { return m }

// InitiatePreimageSwapResponseValidationError is the validation error returned
// by InitiatePreimageSwapResponse.Validate if the designated constraints
// aren't met.
type InitiatePreimageSwapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitiatePreimageSwapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitiatePreimageSwapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitiatePreimageSwapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitiatePreimageSwapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitiatePreimageSwapResponseValidationError) ErrorName() string {
	return "InitiatePreimageSwapResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InitiatePreimageSwapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitiatePreimageSwapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitiatePreimageSwapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitiatePreimageSwapResponseValidationError{}

// Validate checks the field values on OutPoint with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OutPoint) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OutPoint with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OutPointMultiError, or nil
// if none found.
func (m *OutPoint) ValidateAll() error {
	return m.validate(true)
}

func (m *OutPoint) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Txid

	// no validation rules for Vout

	if len(errors) > 0 {
		return OutPointMultiError(errors)
	}

	return nil
}

// OutPointMultiError is an error wrapping multiple validation errors returned
// by OutPoint.ValidateAll() if the designated constraints aren't met.
type OutPointMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OutPointMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OutPointMultiError) AllErrors() []error { return m }

// OutPointValidationError is the validation error returned by
// OutPoint.Validate if the designated constraints aren't met.
type OutPointValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OutPointValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OutPointValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OutPointValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OutPointValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OutPointValidationError) ErrorName() string { return "OutPointValidationError" }

// Error satisfies the builtin error interface
func (e OutPointValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOutPoint.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OutPointValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OutPointValidationError{}

// Validate checks the field values on CooperativeExitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CooperativeExitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CooperativeExitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CooperativeExitRequestMultiError, or nil if none found.
func (m *CooperativeExitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CooperativeExitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CooperativeExitRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CooperativeExitRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CooperativeExitRequestValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ExitId

	// no validation rules for ExitTxid

	if len(errors) > 0 {
		return CooperativeExitRequestMultiError(errors)
	}

	return nil
}

// CooperativeExitRequestMultiError is an error wrapping multiple validation
// errors returned by CooperativeExitRequest.ValidateAll() if the designated
// constraints aren't met.
type CooperativeExitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CooperativeExitRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CooperativeExitRequestMultiError) AllErrors() []error { return m }

// CooperativeExitRequestValidationError is the validation error returned by
// CooperativeExitRequest.Validate if the designated constraints aren't met.
type CooperativeExitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CooperativeExitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CooperativeExitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CooperativeExitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CooperativeExitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CooperativeExitRequestValidationError) ErrorName() string {
	return "CooperativeExitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CooperativeExitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCooperativeExitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CooperativeExitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CooperativeExitRequestValidationError{}

// Validate checks the field values on CooperativeExitResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CooperativeExitResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CooperativeExitResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CooperativeExitResponseMultiError, or nil if none found.
func (m *CooperativeExitResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CooperativeExitResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CooperativeExitResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CooperativeExitResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CooperativeExitResponseValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSigningResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CooperativeExitResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CooperativeExitResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CooperativeExitResponseValidationError{
					field:  fmt.Sprintf("SigningResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CooperativeExitResponseMultiError(errors)
	}

	return nil
}

// CooperativeExitResponseMultiError is an error wrapping multiple validation
// errors returned by CooperativeExitResponse.ValidateAll() if the designated
// constraints aren't met.
type CooperativeExitResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CooperativeExitResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CooperativeExitResponseMultiError) AllErrors() []error { return m }

// CooperativeExitResponseValidationError is the validation error returned by
// CooperativeExitResponse.Validate if the designated constraints aren't met.
type CooperativeExitResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CooperativeExitResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CooperativeExitResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CooperativeExitResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CooperativeExitResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CooperativeExitResponseValidationError) ErrorName() string {
	return "CooperativeExitResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CooperativeExitResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCooperativeExitResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CooperativeExitResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CooperativeExitResponseValidationError{}

// Validate checks the field values on LeafSwapRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LeafSwapRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeafSwapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LeafSwapRequestMultiError, or nil if none found.
func (m *LeafSwapRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LeafSwapRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeafSwapRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeafSwapRequestValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeafSwapRequestValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SwapId

	// no validation rules for AdaptorPublicKey

	if len(errors) > 0 {
		return LeafSwapRequestMultiError(errors)
	}

	return nil
}

// LeafSwapRequestMultiError is an error wrapping multiple validation errors
// returned by LeafSwapRequest.ValidateAll() if the designated constraints
// aren't met.
type LeafSwapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeafSwapRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeafSwapRequestMultiError) AllErrors() []error { return m }

// LeafSwapRequestValidationError is the validation error returned by
// LeafSwapRequest.Validate if the designated constraints aren't met.
type LeafSwapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeafSwapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeafSwapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeafSwapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeafSwapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeafSwapRequestValidationError) ErrorName() string { return "LeafSwapRequestValidationError" }

// Error satisfies the builtin error interface
func (e LeafSwapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeafSwapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeafSwapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeafSwapRequestValidationError{}

// Validate checks the field values on LeafSwapResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LeafSwapResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeafSwapResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LeafSwapResponseMultiError, or nil if none found.
func (m *LeafSwapResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LeafSwapResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeafSwapResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeafSwapResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeafSwapResponseValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSigningResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LeafSwapResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LeafSwapResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LeafSwapResponseValidationError{
					field:  fmt.Sprintf("SigningResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LeafSwapResponseMultiError(errors)
	}

	return nil
}

// LeafSwapResponseMultiError is an error wrapping multiple validation errors
// returned by LeafSwapResponse.ValidateAll() if the designated constraints
// aren't met.
type LeafSwapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeafSwapResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeafSwapResponseMultiError) AllErrors() []error { return m }

// LeafSwapResponseValidationError is the validation error returned by
// LeafSwapResponse.Validate if the designated constraints aren't met.
type LeafSwapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeafSwapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeafSwapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeafSwapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeafSwapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeafSwapResponseValidationError) ErrorName() string { return "LeafSwapResponseValidationError" }

// Error satisfies the builtin error interface
func (e LeafSwapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeafSwapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeafSwapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeafSwapResponseValidationError{}

// Validate checks the field values on RefreshTimelockRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshTimelockRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTimelockRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshTimelockRequestMultiError, or nil if none found.
func (m *RefreshTimelockRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTimelockRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeafId

	// no validation rules for OwnerIdentityPublicKey

	for idx, item := range m.GetSigningJobs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RefreshTimelockRequestValidationError{
						field:  fmt.Sprintf("SigningJobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RefreshTimelockRequestValidationError{
						field:  fmt.Sprintf("SigningJobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RefreshTimelockRequestValidationError{
					field:  fmt.Sprintf("SigningJobs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RefreshTimelockRequestMultiError(errors)
	}

	return nil
}

// RefreshTimelockRequestMultiError is an error wrapping multiple validation
// errors returned by RefreshTimelockRequest.ValidateAll() if the designated
// constraints aren't met.
type RefreshTimelockRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTimelockRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTimelockRequestMultiError) AllErrors() []error { return m }

// RefreshTimelockRequestValidationError is the validation error returned by
// RefreshTimelockRequest.Validate if the designated constraints aren't met.
type RefreshTimelockRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTimelockRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTimelockRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTimelockRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTimelockRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTimelockRequestValidationError) ErrorName() string {
	return "RefreshTimelockRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTimelockRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTimelockRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTimelockRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTimelockRequestValidationError{}

// Validate checks the field values on RefreshTimelockSigningResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshTimelockSigningResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTimelockSigningResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshTimelockSigningResultMultiError, or nil if none found.
func (m *RefreshTimelockSigningResult) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTimelockSigningResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RefreshTimelockSigningResultValidationError{
					field:  "SigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RefreshTimelockSigningResultValidationError{
					field:  "SigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RefreshTimelockSigningResultValidationError{
				field:  "SigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for VerifyingKey

	if len(errors) > 0 {
		return RefreshTimelockSigningResultMultiError(errors)
	}

	return nil
}

// RefreshTimelockSigningResultMultiError is an error wrapping multiple
// validation errors returned by RefreshTimelockSigningResult.ValidateAll() if
// the designated constraints aren't met.
type RefreshTimelockSigningResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTimelockSigningResultMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTimelockSigningResultMultiError) AllErrors() []error { return m }

// RefreshTimelockSigningResultValidationError is the validation error returned
// by RefreshTimelockSigningResult.Validate if the designated constraints
// aren't met.
type RefreshTimelockSigningResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTimelockSigningResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTimelockSigningResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTimelockSigningResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTimelockSigningResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTimelockSigningResultValidationError) ErrorName() string {
	return "RefreshTimelockSigningResultValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTimelockSigningResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTimelockSigningResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTimelockSigningResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTimelockSigningResultValidationError{}

// Validate checks the field values on RefreshTimelockResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshTimelockResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTimelockResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshTimelockResponseMultiError, or nil if none found.
func (m *RefreshTimelockResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTimelockResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSigningResults() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RefreshTimelockResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RefreshTimelockResponseValidationError{
						field:  fmt.Sprintf("SigningResults[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RefreshTimelockResponseValidationError{
					field:  fmt.Sprintf("SigningResults[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RefreshTimelockResponseMultiError(errors)
	}

	return nil
}

// RefreshTimelockResponseMultiError is an error wrapping multiple validation
// errors returned by RefreshTimelockResponse.ValidateAll() if the designated
// constraints aren't met.
type RefreshTimelockResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTimelockResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTimelockResponseMultiError) AllErrors() []error { return m }

// RefreshTimelockResponseValidationError is the validation error returned by
// RefreshTimelockResponse.Validate if the designated constraints aren't met.
type RefreshTimelockResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTimelockResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTimelockResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTimelockResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTimelockResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTimelockResponseValidationError) ErrorName() string {
	return "RefreshTimelockResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTimelockResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTimelockResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTimelockResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTimelockResponseValidationError{}

// Validate checks the field values on ExtendLeafRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExtendLeafRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExtendLeafRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExtendLeafRequestMultiError, or nil if none found.
func (m *ExtendLeafRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExtendLeafRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeafId

	// no validation rules for OwnerIdentityPublicKey

	if all {
		switch v := interface{}(m.GetNodeTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtendLeafRequestValidationError{
					field:  "NodeTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtendLeafRequestValidationError{
					field:  "NodeTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtendLeafRequestValidationError{
				field:  "NodeTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtendLeafRequestValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtendLeafRequestValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtendLeafRequestValidationError{
				field:  "RefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExtendLeafRequestMultiError(errors)
	}

	return nil
}

// ExtendLeafRequestMultiError is an error wrapping multiple validation errors
// returned by ExtendLeafRequest.ValidateAll() if the designated constraints
// aren't met.
type ExtendLeafRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExtendLeafRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExtendLeafRequestMultiError) AllErrors() []error { return m }

// ExtendLeafRequestValidationError is the validation error returned by
// ExtendLeafRequest.Validate if the designated constraints aren't met.
type ExtendLeafRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExtendLeafRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExtendLeafRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExtendLeafRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExtendLeafRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExtendLeafRequestValidationError) ErrorName() string {
	return "ExtendLeafRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExtendLeafRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtendLeafRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExtendLeafRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExtendLeafRequestValidationError{}

// Validate checks the field values on ExtendLeafSigningResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExtendLeafSigningResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExtendLeafSigningResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExtendLeafSigningResultMultiError, or nil if none found.
func (m *ExtendLeafSigningResult) ValidateAll() error {
	return m.validate(true)
}

func (m *ExtendLeafSigningResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtendLeafSigningResultValidationError{
					field:  "SigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtendLeafSigningResultValidationError{
					field:  "SigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtendLeafSigningResultValidationError{
				field:  "SigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for VerifyingKey

	if len(errors) > 0 {
		return ExtendLeafSigningResultMultiError(errors)
	}

	return nil
}

// ExtendLeafSigningResultMultiError is an error wrapping multiple validation
// errors returned by ExtendLeafSigningResult.ValidateAll() if the designated
// constraints aren't met.
type ExtendLeafSigningResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExtendLeafSigningResultMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExtendLeafSigningResultMultiError) AllErrors() []error { return m }

// ExtendLeafSigningResultValidationError is the validation error returned by
// ExtendLeafSigningResult.Validate if the designated constraints aren't met.
type ExtendLeafSigningResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExtendLeafSigningResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExtendLeafSigningResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExtendLeafSigningResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExtendLeafSigningResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExtendLeafSigningResultValidationError) ErrorName() string {
	return "ExtendLeafSigningResultValidationError"
}

// Error satisfies the builtin error interface
func (e ExtendLeafSigningResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtendLeafSigningResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExtendLeafSigningResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExtendLeafSigningResultValidationError{}

// Validate checks the field values on ExtendLeafResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExtendLeafResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExtendLeafResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExtendLeafResponseMultiError, or nil if none found.
func (m *ExtendLeafResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExtendLeafResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeafId

	if all {
		switch v := interface{}(m.GetNodeTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtendLeafResponseValidationError{
					field:  "NodeTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtendLeafResponseValidationError{
					field:  "NodeTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtendLeafResponseValidationError{
				field:  "NodeTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefundTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExtendLeafResponseValidationError{
					field:  "RefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExtendLeafResponseValidationError{
					field:  "RefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExtendLeafResponseValidationError{
				field:  "RefundTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ExtendLeafResponseMultiError(errors)
	}

	return nil
}

// ExtendLeafResponseMultiError is an error wrapping multiple validation errors
// returned by ExtendLeafResponse.ValidateAll() if the designated constraints
// aren't met.
type ExtendLeafResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExtendLeafResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExtendLeafResponseMultiError) AllErrors() []error { return m }

// ExtendLeafResponseValidationError is the validation error returned by
// ExtendLeafResponse.Validate if the designated constraints aren't met.
type ExtendLeafResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExtendLeafResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExtendLeafResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExtendLeafResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExtendLeafResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExtendLeafResponseValidationError) ErrorName() string {
	return "ExtendLeafResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExtendLeafResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtendLeafResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExtendLeafResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExtendLeafResponseValidationError{}

// Validate checks the field values on AddressRequestNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddressRequestNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddressRequestNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddressRequestNodeMultiError, or nil if none found.
func (m *AddressRequestNode) ValidateAll() error {
	return m.validate(true)
}

func (m *AddressRequestNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserPublicKey

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AddressRequestNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AddressRequestNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AddressRequestNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AddressRequestNodeMultiError(errors)
	}

	return nil
}

// AddressRequestNodeMultiError is an error wrapping multiple validation errors
// returned by AddressRequestNode.ValidateAll() if the designated constraints
// aren't met.
type AddressRequestNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressRequestNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressRequestNodeMultiError) AllErrors() []error { return m }

// AddressRequestNodeValidationError is the validation error returned by
// AddressRequestNode.Validate if the designated constraints aren't met.
type AddressRequestNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressRequestNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressRequestNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressRequestNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressRequestNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressRequestNodeValidationError) ErrorName() string {
	return "AddressRequestNodeValidationError"
}

// Error satisfies the builtin error interface
func (e AddressRequestNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddressRequestNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressRequestNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressRequestNodeValidationError{}

// Validate checks the field values on PrepareTreeAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PrepareTreeAddressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrepareTreeAddressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PrepareTreeAddressRequestMultiError, or nil if none found.
func (m *PrepareTreeAddressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PrepareTreeAddressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PrepareTreeAddressRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PrepareTreeAddressRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PrepareTreeAddressRequestValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserIdentityPublicKey

	switch v := m.Source.(type) {
	case *PrepareTreeAddressRequest_ParentNodeOutput:
		if v == nil {
			err := PrepareTreeAddressRequestValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetParentNodeOutput()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PrepareTreeAddressRequestValidationError{
						field:  "ParentNodeOutput",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PrepareTreeAddressRequestValidationError{
						field:  "ParentNodeOutput",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetParentNodeOutput()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PrepareTreeAddressRequestValidationError{
					field:  "ParentNodeOutput",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *PrepareTreeAddressRequest_OnChainUtxo:
		if v == nil {
			err := PrepareTreeAddressRequestValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOnChainUtxo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PrepareTreeAddressRequestValidationError{
						field:  "OnChainUtxo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PrepareTreeAddressRequestValidationError{
						field:  "OnChainUtxo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOnChainUtxo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PrepareTreeAddressRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return PrepareTreeAddressRequestMultiError(errors)
	}

	return nil
}

// PrepareTreeAddressRequestMultiError is an error wrapping multiple validation
// errors returned by PrepareTreeAddressRequest.ValidateAll() if the
// designated constraints aren't met.
type PrepareTreeAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrepareTreeAddressRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrepareTreeAddressRequestMultiError) AllErrors() []error { return m }

// PrepareTreeAddressRequestValidationError is the validation error returned by
// PrepareTreeAddressRequest.Validate if the designated constraints aren't met.
type PrepareTreeAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrepareTreeAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrepareTreeAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrepareTreeAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrepareTreeAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrepareTreeAddressRequestValidationError) ErrorName() string {
	return "PrepareTreeAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PrepareTreeAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrepareTreeAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrepareTreeAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrepareTreeAddressRequestValidationError{}

// Validate checks the field values on AddressNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AddressNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddressNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AddressNodeMultiError, or
// nil if none found.
func (m *AddressNode) ValidateAll() error {
	return m.validate(true)
}

func (m *AddressNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddressNodeValidationError{
					field:  "Address",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddressNodeValidationError{
					field:  "Address",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddressNodeValidationError{
				field:  "Address",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AddressNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AddressNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AddressNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AddressNodeMultiError(errors)
	}

	return nil
}

// AddressNodeMultiError is an error wrapping multiple validation errors
// returned by AddressNode.ValidateAll() if the designated constraints aren't met.
type AddressNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressNodeMultiError) AllErrors() []error { return m }

// AddressNodeValidationError is the validation error returned by
// AddressNode.Validate if the designated constraints aren't met.
type AddressNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressNodeValidationError) ErrorName() string { return "AddressNodeValidationError" }

// Error satisfies the builtin error interface
func (e AddressNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddressNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressNodeValidationError{}

// Validate checks the field values on PrepareTreeAddressResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PrepareTreeAddressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrepareTreeAddressResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PrepareTreeAddressResponseMultiError, or nil if none found.
func (m *PrepareTreeAddressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PrepareTreeAddressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PrepareTreeAddressResponseValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PrepareTreeAddressResponseValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PrepareTreeAddressResponseValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PrepareTreeAddressResponseMultiError(errors)
	}

	return nil
}

// PrepareTreeAddressResponseMultiError is an error wrapping multiple
// validation errors returned by PrepareTreeAddressResponse.ValidateAll() if
// the designated constraints aren't met.
type PrepareTreeAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrepareTreeAddressResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrepareTreeAddressResponseMultiError) AllErrors() []error { return m }

// PrepareTreeAddressResponseValidationError is the validation error returned
// by PrepareTreeAddressResponse.Validate if the designated constraints aren't met.
type PrepareTreeAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrepareTreeAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrepareTreeAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrepareTreeAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrepareTreeAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrepareTreeAddressResponseValidationError) ErrorName() string {
	return "PrepareTreeAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PrepareTreeAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrepareTreeAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrepareTreeAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrepareTreeAddressResponseValidationError{}

// Validate checks the field values on CreationNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreationNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreationNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreationNodeMultiError, or
// nil if none found.
func (m *CreationNode) ValidateAll() error {
	return m.validate(true)
}

func (m *CreationNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNodeTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreationNodeValidationError{
					field:  "NodeTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreationNodeValidationError{
					field:  "NodeTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreationNodeValidationError{
				field:  "NodeTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefundTxSigningJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreationNodeValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreationNodeValidationError{
					field:  "RefundTxSigningJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreationNodeValidationError{
				field:  "RefundTxSigningJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreationNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreationNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreationNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreationNodeMultiError(errors)
	}

	return nil
}

// CreationNodeMultiError is an error wrapping multiple validation errors
// returned by CreationNode.ValidateAll() if the designated constraints aren't met.
type CreationNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreationNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreationNodeMultiError) AllErrors() []error { return m }

// CreationNodeValidationError is the validation error returned by
// CreationNode.Validate if the designated constraints aren't met.
type CreationNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreationNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreationNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreationNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreationNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreationNodeValidationError) ErrorName() string { return "CreationNodeValidationError" }

// Error satisfies the builtin error interface
func (e CreationNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreationNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreationNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreationNodeValidationError{}

// Validate checks the field values on CreateTreeRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateTreeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTreeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTreeRequestMultiError, or nil if none found.
func (m *CreateTreeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTreeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTreeRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTreeRequestValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTreeRequestValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserIdentityPublicKey

	switch v := m.Source.(type) {
	case *CreateTreeRequest_ParentNodeOutput:
		if v == nil {
			err := CreateTreeRequestValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetParentNodeOutput()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTreeRequestValidationError{
						field:  "ParentNodeOutput",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTreeRequestValidationError{
						field:  "ParentNodeOutput",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetParentNodeOutput()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTreeRequestValidationError{
					field:  "ParentNodeOutput",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CreateTreeRequest_OnChainUtxo:
		if v == nil {
			err := CreateTreeRequestValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOnChainUtxo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTreeRequestValidationError{
						field:  "OnChainUtxo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTreeRequestValidationError{
						field:  "OnChainUtxo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOnChainUtxo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTreeRequestValidationError{
					field:  "OnChainUtxo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return CreateTreeRequestMultiError(errors)
	}

	return nil
}

// CreateTreeRequestMultiError is an error wrapping multiple validation errors
// returned by CreateTreeRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateTreeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTreeRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTreeRequestMultiError) AllErrors() []error { return m }

// CreateTreeRequestValidationError is the validation error returned by
// CreateTreeRequest.Validate if the designated constraints aren't met.
type CreateTreeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTreeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTreeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTreeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTreeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTreeRequestValidationError) ErrorName() string {
	return "CreateTreeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTreeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTreeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTreeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTreeRequestValidationError{}

// Validate checks the field values on CreationResponseNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreationResponseNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreationResponseNode with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreationResponseNodeMultiError, or nil if none found.
func (m *CreationResponseNode) ValidateAll() error {
	return m.validate(true)
}

func (m *CreationResponseNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeId

	if all {
		switch v := interface{}(m.GetNodeTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreationResponseNodeValidationError{
					field:  "NodeTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreationResponseNodeValidationError{
					field:  "NodeTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNodeTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreationResponseNodeValidationError{
				field:  "NodeTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRefundTxSigningResult()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreationResponseNodeValidationError{
					field:  "RefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreationResponseNodeValidationError{
					field:  "RefundTxSigningResult",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRefundTxSigningResult()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreationResponseNodeValidationError{
				field:  "RefundTxSigningResult",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetChildren() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreationResponseNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreationResponseNodeValidationError{
						field:  fmt.Sprintf("Children[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreationResponseNodeValidationError{
					field:  fmt.Sprintf("Children[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreationResponseNodeMultiError(errors)
	}

	return nil
}

// CreationResponseNodeMultiError is an error wrapping multiple validation
// errors returned by CreationResponseNode.ValidateAll() if the designated
// constraints aren't met.
type CreationResponseNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreationResponseNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreationResponseNodeMultiError) AllErrors() []error { return m }

// CreationResponseNodeValidationError is the validation error returned by
// CreationResponseNode.Validate if the designated constraints aren't met.
type CreationResponseNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreationResponseNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreationResponseNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreationResponseNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreationResponseNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreationResponseNodeValidationError) ErrorName() string {
	return "CreationResponseNodeValidationError"
}

// Error satisfies the builtin error interface
func (e CreationResponseNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreationResponseNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreationResponseNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreationResponseNodeValidationError{}

// Validate checks the field values on CreateTreeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTreeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTreeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTreeResponseMultiError, or nil if none found.
func (m *CreateTreeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTreeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNode()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTreeResponseValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTreeResponseValidationError{
					field:  "Node",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNode()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTreeResponseValidationError{
				field:  "Node",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTreeResponseMultiError(errors)
	}

	return nil
}

// CreateTreeResponseMultiError is an error wrapping multiple validation errors
// returned by CreateTreeResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateTreeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTreeResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTreeResponseMultiError) AllErrors() []error { return m }

// CreateTreeResponseValidationError is the validation error returned by
// CreateTreeResponse.Validate if the designated constraints aren't met.
type CreateTreeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTreeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTreeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTreeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTreeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTreeResponseValidationError) ErrorName() string {
	return "CreateTreeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTreeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTreeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTreeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTreeResponseValidationError{}

// Validate checks the field values on SigningOperatorInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SigningOperatorInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SigningOperatorInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SigningOperatorInfoMultiError, or nil if none found.
func (m *SigningOperatorInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SigningOperatorInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	// no validation rules for Identifier

	// no validation rules for PublicKey

	// no validation rules for Address

	if len(errors) > 0 {
		return SigningOperatorInfoMultiError(errors)
	}

	return nil
}

// SigningOperatorInfoMultiError is an error wrapping multiple validation
// errors returned by SigningOperatorInfo.ValidateAll() if the designated
// constraints aren't met.
type SigningOperatorInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SigningOperatorInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SigningOperatorInfoMultiError) AllErrors() []error { return m }

// SigningOperatorInfoValidationError is the validation error returned by
// SigningOperatorInfo.Validate if the designated constraints aren't met.
type SigningOperatorInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SigningOperatorInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SigningOperatorInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SigningOperatorInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SigningOperatorInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SigningOperatorInfoValidationError) ErrorName() string {
	return "SigningOperatorInfoValidationError"
}

// Error satisfies the builtin error interface
func (e SigningOperatorInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSigningOperatorInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SigningOperatorInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SigningOperatorInfoValidationError{}

// Validate checks the field values on GetSigningOperatorListResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSigningOperatorListResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSigningOperatorListResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetSigningOperatorListResponseMultiError, or nil if none found.
func (m *GetSigningOperatorListResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSigningOperatorListResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetSigningOperators()))
		i := 0
		for key := range m.GetSigningOperators() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetSigningOperators()[key]
			_ = val

			// no validation rules for SigningOperators[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, GetSigningOperatorListResponseValidationError{
							field:  fmt.Sprintf("SigningOperators[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, GetSigningOperatorListResponseValidationError{
							field:  fmt.Sprintf("SigningOperators[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return GetSigningOperatorListResponseValidationError{
						field:  fmt.Sprintf("SigningOperators[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return GetSigningOperatorListResponseMultiError(errors)
	}

	return nil
}

// GetSigningOperatorListResponseMultiError is an error wrapping multiple
// validation errors returned by GetSigningOperatorListResponse.ValidateAll()
// if the designated constraints aren't met.
type GetSigningOperatorListResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSigningOperatorListResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSigningOperatorListResponseMultiError) AllErrors() []error { return m }

// GetSigningOperatorListResponseValidationError is the validation error
// returned by GetSigningOperatorListResponse.Validate if the designated
// constraints aren't met.
type GetSigningOperatorListResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSigningOperatorListResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSigningOperatorListResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSigningOperatorListResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSigningOperatorListResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSigningOperatorListResponseValidationError) ErrorName() string {
	return "GetSigningOperatorListResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSigningOperatorListResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSigningOperatorListResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSigningOperatorListResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSigningOperatorListResponseValidationError{}

// Validate checks the field values on QueryUserSignedRefundsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryUserSignedRefundsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryUserSignedRefundsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// QueryUserSignedRefundsRequestMultiError, or nil if none found.
func (m *QueryUserSignedRefundsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryUserSignedRefundsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentHash

	// no validation rules for IdentityPublicKey

	if len(errors) > 0 {
		return QueryUserSignedRefundsRequestMultiError(errors)
	}

	return nil
}

// QueryUserSignedRefundsRequestMultiError is an error wrapping multiple
// validation errors returned by QueryUserSignedRefundsRequest.ValidateAll()
// if the designated constraints aren't met.
type QueryUserSignedRefundsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryUserSignedRefundsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryUserSignedRefundsRequestMultiError) AllErrors() []error { return m }

// QueryUserSignedRefundsRequestValidationError is the validation error
// returned by QueryUserSignedRefundsRequest.Validate if the designated
// constraints aren't met.
type QueryUserSignedRefundsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryUserSignedRefundsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryUserSignedRefundsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryUserSignedRefundsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryUserSignedRefundsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryUserSignedRefundsRequestValidationError) ErrorName() string {
	return "QueryUserSignedRefundsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryUserSignedRefundsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryUserSignedRefundsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryUserSignedRefundsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryUserSignedRefundsRequestValidationError{}

// Validate checks the field values on QueryUserSignedRefundsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryUserSignedRefundsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryUserSignedRefundsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// QueryUserSignedRefundsResponseMultiError, or nil if none found.
func (m *QueryUserSignedRefundsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryUserSignedRefundsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUserSignedRefunds() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryUserSignedRefundsResponseValidationError{
						field:  fmt.Sprintf("UserSignedRefunds[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryUserSignedRefundsResponseValidationError{
						field:  fmt.Sprintf("UserSignedRefunds[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryUserSignedRefundsResponseValidationError{
					field:  fmt.Sprintf("UserSignedRefunds[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QueryUserSignedRefundsResponseMultiError(errors)
	}

	return nil
}

// QueryUserSignedRefundsResponseMultiError is an error wrapping multiple
// validation errors returned by QueryUserSignedRefundsResponse.ValidateAll()
// if the designated constraints aren't met.
type QueryUserSignedRefundsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryUserSignedRefundsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryUserSignedRefundsResponseMultiError) AllErrors() []error { return m }

// QueryUserSignedRefundsResponseValidationError is the validation error
// returned by QueryUserSignedRefundsResponse.Validate if the designated
// constraints aren't met.
type QueryUserSignedRefundsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryUserSignedRefundsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryUserSignedRefundsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryUserSignedRefundsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryUserSignedRefundsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryUserSignedRefundsResponseValidationError) ErrorName() string {
	return "QueryUserSignedRefundsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryUserSignedRefundsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryUserSignedRefundsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryUserSignedRefundsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryUserSignedRefundsResponseValidationError{}

// Validate checks the field values on ProvidePreimageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProvidePreimageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProvidePreimageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProvidePreimageRequestMultiError, or nil if none found.
func (m *ProvidePreimageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProvidePreimageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentHash

	// no validation rules for Preimage

	// no validation rules for IdentityPublicKey

	if len(errors) > 0 {
		return ProvidePreimageRequestMultiError(errors)
	}

	return nil
}

// ProvidePreimageRequestMultiError is an error wrapping multiple validation
// errors returned by ProvidePreimageRequest.ValidateAll() if the designated
// constraints aren't met.
type ProvidePreimageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProvidePreimageRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProvidePreimageRequestMultiError) AllErrors() []error { return m }

// ProvidePreimageRequestValidationError is the validation error returned by
// ProvidePreimageRequest.Validate if the designated constraints aren't met.
type ProvidePreimageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProvidePreimageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProvidePreimageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProvidePreimageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProvidePreimageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProvidePreimageRequestValidationError) ErrorName() string {
	return "ProvidePreimageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProvidePreimageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProvidePreimageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProvidePreimageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProvidePreimageRequestValidationError{}

// Validate checks the field values on ProvidePreimageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProvidePreimageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProvidePreimageResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProvidePreimageResponseMultiError, or nil if none found.
func (m *ProvidePreimageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ProvidePreimageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProvidePreimageResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProvidePreimageResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProvidePreimageResponseValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProvidePreimageResponseMultiError(errors)
	}

	return nil
}

// ProvidePreimageResponseMultiError is an error wrapping multiple validation
// errors returned by ProvidePreimageResponse.ValidateAll() if the designated
// constraints aren't met.
type ProvidePreimageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProvidePreimageResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProvidePreimageResponseMultiError) AllErrors() []error { return m }

// ProvidePreimageResponseValidationError is the validation error returned by
// ProvidePreimageResponse.Validate if the designated constraints aren't met.
type ProvidePreimageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProvidePreimageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProvidePreimageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProvidePreimageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProvidePreimageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProvidePreimageResponseValidationError) ErrorName() string {
	return "ProvidePreimageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ProvidePreimageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProvidePreimageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProvidePreimageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProvidePreimageResponseValidationError{}

// Validate checks the field values on ReturnLightningPaymentRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReturnLightningPaymentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReturnLightningPaymentRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ReturnLightningPaymentRequestMultiError, or nil if none found.
func (m *ReturnLightningPaymentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReturnLightningPaymentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PaymentHash

	// no validation rules for UserIdentityPublicKey

	if len(errors) > 0 {
		return ReturnLightningPaymentRequestMultiError(errors)
	}

	return nil
}

// ReturnLightningPaymentRequestMultiError is an error wrapping multiple
// validation errors returned by ReturnLightningPaymentRequest.ValidateAll()
// if the designated constraints aren't met.
type ReturnLightningPaymentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReturnLightningPaymentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReturnLightningPaymentRequestMultiError) AllErrors() []error { return m }

// ReturnLightningPaymentRequestValidationError is the validation error
// returned by ReturnLightningPaymentRequest.Validate if the designated
// constraints aren't met.
type ReturnLightningPaymentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReturnLightningPaymentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReturnLightningPaymentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReturnLightningPaymentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReturnLightningPaymentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReturnLightningPaymentRequestValidationError) ErrorName() string {
	return "ReturnLightningPaymentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReturnLightningPaymentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReturnLightningPaymentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReturnLightningPaymentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReturnLightningPaymentRequestValidationError{}

// Validate checks the field values on TreeNodeIds with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TreeNodeIds) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TreeNodeIds with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TreeNodeIdsMultiError, or
// nil if none found.
func (m *TreeNodeIds) ValidateAll() error {
	return m.validate(true)
}

func (m *TreeNodeIds) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TreeNodeIdsMultiError(errors)
	}

	return nil
}

// TreeNodeIdsMultiError is an error wrapping multiple validation errors
// returned by TreeNodeIds.ValidateAll() if the designated constraints aren't met.
type TreeNodeIdsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TreeNodeIdsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TreeNodeIdsMultiError) AllErrors() []error { return m }

// TreeNodeIdsValidationError is the validation error returned by
// TreeNodeIds.Validate if the designated constraints aren't met.
type TreeNodeIdsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TreeNodeIdsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TreeNodeIdsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TreeNodeIdsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TreeNodeIdsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TreeNodeIdsValidationError) ErrorName() string { return "TreeNodeIdsValidationError" }

// Error satisfies the builtin error interface
func (e TreeNodeIdsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTreeNodeIds.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TreeNodeIdsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TreeNodeIdsValidationError{}

// Validate checks the field values on QueryNodesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *QueryNodesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryNodesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryNodesRequestMultiError, or nil if none found.
func (m *QueryNodesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryNodesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IncludeParents

	switch v := m.Source.(type) {
	case *QueryNodesRequest_OwnerIdentityPubkey:
		if v == nil {
			err := QueryNodesRequestValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for OwnerIdentityPubkey
	case *QueryNodesRequest_NodeIds:
		if v == nil {
			err := QueryNodesRequestValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNodeIds()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryNodesRequestValidationError{
						field:  "NodeIds",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryNodesRequestValidationError{
						field:  "NodeIds",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNodeIds()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryNodesRequestValidationError{
					field:  "NodeIds",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return QueryNodesRequestMultiError(errors)
	}

	return nil
}

// QueryNodesRequestMultiError is an error wrapping multiple validation errors
// returned by QueryNodesRequest.ValidateAll() if the designated constraints
// aren't met.
type QueryNodesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryNodesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryNodesRequestMultiError) AllErrors() []error { return m }

// QueryNodesRequestValidationError is the validation error returned by
// QueryNodesRequest.Validate if the designated constraints aren't met.
type QueryNodesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryNodesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryNodesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryNodesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryNodesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryNodesRequestValidationError) ErrorName() string {
	return "QueryNodesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryNodesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryNodesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryNodesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryNodesRequestValidationError{}

// Validate checks the field values on QueryNodesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryNodesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryNodesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryNodesResponseMultiError, or nil if none found.
func (m *QueryNodesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryNodesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetNodes()))
		i := 0
		for key := range m.GetNodes() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetNodes()[key]
			_ = val

			// no validation rules for Nodes[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, QueryNodesResponseValidationError{
							field:  fmt.Sprintf("Nodes[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, QueryNodesResponseValidationError{
							field:  fmt.Sprintf("Nodes[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return QueryNodesResponseValidationError{
						field:  fmt.Sprintf("Nodes[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return QueryNodesResponseMultiError(errors)
	}

	return nil
}

// QueryNodesResponseMultiError is an error wrapping multiple validation errors
// returned by QueryNodesResponse.ValidateAll() if the designated constraints
// aren't met.
type QueryNodesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryNodesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryNodesResponseMultiError) AllErrors() []error { return m }

// QueryNodesResponseValidationError is the validation error returned by
// QueryNodesResponse.Validate if the designated constraints aren't met.
type QueryNodesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryNodesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryNodesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryNodesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryNodesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryNodesResponseValidationError) ErrorName() string {
	return "QueryNodesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryNodesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryNodesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryNodesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryNodesResponseValidationError{}

// Validate checks the field values on CancelSendTransferRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CancelSendTransferRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelSendTransferRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelSendTransferRequestMultiError, or nil if none found.
func (m *CancelSendTransferRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelSendTransferRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferId

	// no validation rules for SenderIdentityPublicKey

	if len(errors) > 0 {
		return CancelSendTransferRequestMultiError(errors)
	}

	return nil
}

// CancelSendTransferRequestMultiError is an error wrapping multiple validation
// errors returned by CancelSendTransferRequest.ValidateAll() if the
// designated constraints aren't met.
type CancelSendTransferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelSendTransferRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelSendTransferRequestMultiError) AllErrors() []error { return m }

// CancelSendTransferRequestValidationError is the validation error returned by
// CancelSendTransferRequest.Validate if the designated constraints aren't met.
type CancelSendTransferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelSendTransferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelSendTransferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelSendTransferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelSendTransferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelSendTransferRequestValidationError) ErrorName() string {
	return "CancelSendTransferRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CancelSendTransferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelSendTransferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelSendTransferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelSendTransferRequestValidationError{}

// Validate checks the field values on CancelSendTransferResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CancelSendTransferResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelSendTransferResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelSendTransferResponseMultiError, or nil if none found.
func (m *CancelSendTransferResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelSendTransferResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransfer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CancelSendTransferResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CancelSendTransferResponseValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CancelSendTransferResponseValidationError{
				field:  "Transfer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CancelSendTransferResponseMultiError(errors)
	}

	return nil
}

// CancelSendTransferResponseMultiError is an error wrapping multiple
// validation errors returned by CancelSendTransferResponse.ValidateAll() if
// the designated constraints aren't met.
type CancelSendTransferResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelSendTransferResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelSendTransferResponseMultiError) AllErrors() []error { return m }

// CancelSendTransferResponseValidationError is the validation error returned
// by CancelSendTransferResponse.Validate if the designated constraints aren't met.
type CancelSendTransferResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelSendTransferResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelSendTransferResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelSendTransferResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelSendTransferResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelSendTransferResponseValidationError) ErrorName() string {
	return "CancelSendTransferResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CancelSendTransferResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelSendTransferResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelSendTransferResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelSendTransferResponseValidationError{}

// Validate checks the field values on QueryAllTransfersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryAllTransfersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryAllTransfersRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryAllTransfersRequestMultiError, or nil if none found.
func (m *QueryAllTransfersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryAllTransfersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IdentityPublicKey

	// no validation rules for Limit

	// no validation rules for Offset

	if len(errors) > 0 {
		return QueryAllTransfersRequestMultiError(errors)
	}

	return nil
}

// QueryAllTransfersRequestMultiError is an error wrapping multiple validation
// errors returned by QueryAllTransfersRequest.ValidateAll() if the designated
// constraints aren't met.
type QueryAllTransfersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryAllTransfersRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryAllTransfersRequestMultiError) AllErrors() []error { return m }

// QueryAllTransfersRequestValidationError is the validation error returned by
// QueryAllTransfersRequest.Validate if the designated constraints aren't met.
type QueryAllTransfersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryAllTransfersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryAllTransfersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryAllTransfersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryAllTransfersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryAllTransfersRequestValidationError) ErrorName() string {
	return "QueryAllTransfersRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryAllTransfersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryAllTransfersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryAllTransfersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryAllTransfersRequestValidationError{}

// Validate checks the field values on QueryAllTransfersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryAllTransfersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryAllTransfersResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryAllTransfersResponseMultiError, or nil if none found.
func (m *QueryAllTransfersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryAllTransfersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransfers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryAllTransfersResponseValidationError{
						field:  fmt.Sprintf("Transfers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryAllTransfersResponseValidationError{
						field:  fmt.Sprintf("Transfers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryAllTransfersResponseValidationError{
					field:  fmt.Sprintf("Transfers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Offset

	if len(errors) > 0 {
		return QueryAllTransfersResponseMultiError(errors)
	}

	return nil
}

// QueryAllTransfersResponseMultiError is an error wrapping multiple validation
// errors returned by QueryAllTransfersResponse.ValidateAll() if the
// designated constraints aren't met.
type QueryAllTransfersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryAllTransfersResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryAllTransfersResponseMultiError) AllErrors() []error { return m }

// QueryAllTransfersResponseValidationError is the validation error returned by
// QueryAllTransfersResponse.Validate if the designated constraints aren't met.
type QueryAllTransfersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryAllTransfersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryAllTransfersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryAllTransfersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryAllTransfersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryAllTransfersResponseValidationError) ErrorName() string {
	return "QueryAllTransfersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryAllTransfersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryAllTransfersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryAllTransfersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryAllTransfersResponseValidationError{}

// Validate checks the field values on QueryUnusedDepositAddressesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *QueryUnusedDepositAddressesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryUnusedDepositAddressesRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// QueryUnusedDepositAddressesRequestMultiError, or nil if none found.
func (m *QueryUnusedDepositAddressesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryUnusedDepositAddressesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IdentityPublicKey

	if len(errors) > 0 {
		return QueryUnusedDepositAddressesRequestMultiError(errors)
	}

	return nil
}

// QueryUnusedDepositAddressesRequestMultiError is an error wrapping multiple
// validation errors returned by
// QueryUnusedDepositAddressesRequest.ValidateAll() if the designated
// constraints aren't met.
type QueryUnusedDepositAddressesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryUnusedDepositAddressesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryUnusedDepositAddressesRequestMultiError) AllErrors() []error { return m }

// QueryUnusedDepositAddressesRequestValidationError is the validation error
// returned by QueryUnusedDepositAddressesRequest.Validate if the designated
// constraints aren't met.
type QueryUnusedDepositAddressesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryUnusedDepositAddressesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryUnusedDepositAddressesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryUnusedDepositAddressesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryUnusedDepositAddressesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryUnusedDepositAddressesRequestValidationError) ErrorName() string {
	return "QueryUnusedDepositAddressesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryUnusedDepositAddressesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryUnusedDepositAddressesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryUnusedDepositAddressesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryUnusedDepositAddressesRequestValidationError{}

// Validate checks the field values on DepositAddressQueryResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DepositAddressQueryResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DepositAddressQueryResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DepositAddressQueryResultMultiError, or nil if none found.
func (m *DepositAddressQueryResult) ValidateAll() error {
	return m.validate(true)
}

func (m *DepositAddressQueryResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DepositAddress

	// no validation rules for UserSigningPublicKey

	// no validation rules for VerifyingPublicKey

	if len(errors) > 0 {
		return DepositAddressQueryResultMultiError(errors)
	}

	return nil
}

// DepositAddressQueryResultMultiError is an error wrapping multiple validation
// errors returned by DepositAddressQueryResult.ValidateAll() if the
// designated constraints aren't met.
type DepositAddressQueryResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DepositAddressQueryResultMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DepositAddressQueryResultMultiError) AllErrors() []error { return m }

// DepositAddressQueryResultValidationError is the validation error returned by
// DepositAddressQueryResult.Validate if the designated constraints aren't met.
type DepositAddressQueryResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DepositAddressQueryResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DepositAddressQueryResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DepositAddressQueryResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DepositAddressQueryResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DepositAddressQueryResultValidationError) ErrorName() string {
	return "DepositAddressQueryResultValidationError"
}

// Error satisfies the builtin error interface
func (e DepositAddressQueryResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDepositAddressQueryResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DepositAddressQueryResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DepositAddressQueryResultValidationError{}

// Validate checks the field values on QueryUnusedDepositAddressesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *QueryUnusedDepositAddressesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryUnusedDepositAddressesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// QueryUnusedDepositAddressesResponseMultiError, or nil if none found.
func (m *QueryUnusedDepositAddressesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryUnusedDepositAddressesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDepositAddresses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, QueryUnusedDepositAddressesResponseValidationError{
						field:  fmt.Sprintf("DepositAddresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, QueryUnusedDepositAddressesResponseValidationError{
						field:  fmt.Sprintf("DepositAddresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return QueryUnusedDepositAddressesResponseValidationError{
					field:  fmt.Sprintf("DepositAddresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return QueryUnusedDepositAddressesResponseMultiError(errors)
	}

	return nil
}

// QueryUnusedDepositAddressesResponseMultiError is an error wrapping multiple
// validation errors returned by
// QueryUnusedDepositAddressesResponse.ValidateAll() if the designated
// constraints aren't met.
type QueryUnusedDepositAddressesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryUnusedDepositAddressesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryUnusedDepositAddressesResponseMultiError) AllErrors() []error { return m }

// QueryUnusedDepositAddressesResponseValidationError is the validation error
// returned by QueryUnusedDepositAddressesResponse.Validate if the designated
// constraints aren't met.
type QueryUnusedDepositAddressesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryUnusedDepositAddressesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryUnusedDepositAddressesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryUnusedDepositAddressesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryUnusedDepositAddressesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryUnusedDepositAddressesResponseValidationError) ErrorName() string {
	return "QueryUnusedDepositAddressesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryUnusedDepositAddressesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryUnusedDepositAddressesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryUnusedDepositAddressesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryUnusedDepositAddressesResponseValidationError{}

// Validate checks the field values on QueryBalanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryBalanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryBalanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryBalanceRequestMultiError, or nil if none found.
func (m *QueryBalanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryBalanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IdentityPublicKey

	if len(errors) > 0 {
		return QueryBalanceRequestMultiError(errors)
	}

	return nil
}

// QueryBalanceRequestMultiError is an error wrapping multiple validation
// errors returned by QueryBalanceRequest.ValidateAll() if the designated
// constraints aren't met.
type QueryBalanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryBalanceRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryBalanceRequestMultiError) AllErrors() []error { return m }

// QueryBalanceRequestValidationError is the validation error returned by
// QueryBalanceRequest.Validate if the designated constraints aren't met.
type QueryBalanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryBalanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryBalanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryBalanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryBalanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryBalanceRequestValidationError) ErrorName() string {
	return "QueryBalanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e QueryBalanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryBalanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryBalanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryBalanceRequestValidationError{}

// Validate checks the field values on QueryBalanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *QueryBalanceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueryBalanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueryBalanceResponseMultiError, or nil if none found.
func (m *QueryBalanceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *QueryBalanceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Balance

	// no validation rules for NodeBalances

	if len(errors) > 0 {
		return QueryBalanceResponseMultiError(errors)
	}

	return nil
}

// QueryBalanceResponseMultiError is an error wrapping multiple validation
// errors returned by QueryBalanceResponse.ValidateAll() if the designated
// constraints aren't met.
type QueryBalanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueryBalanceResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueryBalanceResponseMultiError) AllErrors() []error { return m }

// QueryBalanceResponseValidationError is the validation error returned by
// QueryBalanceResponse.Validate if the designated constraints aren't met.
type QueryBalanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueryBalanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueryBalanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueryBalanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueryBalanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueryBalanceResponseValidationError) ErrorName() string {
	return "QueryBalanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e QueryBalanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueryBalanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueryBalanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueryBalanceResponseValidationError{}
