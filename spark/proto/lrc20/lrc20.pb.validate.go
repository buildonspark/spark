// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: lrc20.proto

package lrc20

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on SendSparkTxRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendSparkTxRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendSparkTxRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendSparkTxRequestMultiError, or nil if none found.
func (m *SendSparkTxRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SendSparkTxRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IdentityPublicKey

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendSparkTxRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendSparkTxRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendSparkTxRequestValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SendSparkTxRequestMultiError(errors)
	}

	return nil
}

// SendSparkTxRequestMultiError is an error wrapping multiple validation errors
// returned by SendSparkTxRequest.ValidateAll() if the designated constraints
// aren't met.
type SendSparkTxRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendSparkTxRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendSparkTxRequestMultiError) AllErrors() []error { return m }

// SendSparkTxRequestValidationError is the validation error returned by
// SendSparkTxRequest.Validate if the designated constraints aren't met.
type SendSparkTxRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendSparkTxRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendSparkTxRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendSparkTxRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendSparkTxRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendSparkTxRequestValidationError) ErrorName() string {
	return "SendSparkTxRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SendSparkTxRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendSparkTxRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendSparkTxRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendSparkTxRequestValidationError{}

// Validate checks the field values on SendSparkSignatureRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendSparkSignatureRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendSparkSignatureRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendSparkSignatureRequestMultiError, or nil if none found.
func (m *SendSparkSignatureRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SendSparkSignatureRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSignatureData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SendSparkSignatureRequestValidationError{
					field:  "SignatureData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SendSparkSignatureRequestValidationError{
					field:  "SignatureData",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSignatureData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SendSparkSignatureRequestValidationError{
				field:  "SignatureData",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SendSparkSignatureRequestMultiError(errors)
	}

	return nil
}

// SendSparkSignatureRequestMultiError is an error wrapping multiple validation
// errors returned by SendSparkSignatureRequest.ValidateAll() if the
// designated constraints aren't met.
type SendSparkSignatureRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendSparkSignatureRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendSparkSignatureRequestMultiError) AllErrors() []error { return m }

// SendSparkSignatureRequestValidationError is the validation error returned by
// SendSparkSignatureRequest.Validate if the designated constraints aren't met.
type SendSparkSignatureRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendSparkSignatureRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendSparkSignatureRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendSparkSignatureRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendSparkSignatureRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendSparkSignatureRequestValidationError) ErrorName() string {
	return "SendSparkSignatureRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SendSparkSignatureRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendSparkSignatureRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendSparkSignatureRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendSparkSignatureRequestValidationError{}

// Validate checks the field values on SparkSignatureData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SparkSignatureData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SparkSignatureData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SparkSignatureDataMultiError, or nil if none found.
func (m *SparkSignatureData) ValidateAll() error {
	return m.validate(true)
}

func (m *SparkSignatureData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SparkOperatorSignature

	// no validation rules for SparkOperatorIdentityPublicKey

	for idx, item := range m.GetLeavesToSpendData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SparkSignatureDataValidationError{
						field:  fmt.Sprintf("LeavesToSpendData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SparkSignatureDataValidationError{
						field:  fmt.Sprintf("LeavesToSpendData[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SparkSignatureDataValidationError{
					field:  fmt.Sprintf("LeavesToSpendData[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SparkSignatureDataValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SparkSignatureDataValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SparkSignatureDataValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SparkSignatureDataMultiError(errors)
	}

	return nil
}

// SparkSignatureDataMultiError is an error wrapping multiple validation errors
// returned by SparkSignatureData.ValidateAll() if the designated constraints
// aren't met.
type SparkSignatureDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SparkSignatureDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SparkSignatureDataMultiError) AllErrors() []error { return m }

// SparkSignatureDataValidationError is the validation error returned by
// SparkSignatureData.Validate if the designated constraints aren't met.
type SparkSignatureDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SparkSignatureDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SparkSignatureDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SparkSignatureDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SparkSignatureDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SparkSignatureDataValidationError) ErrorName() string {
	return "SparkSignatureDataValidationError"
}

// Error satisfies the builtin error interface
func (e SparkSignatureDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSparkSignatureData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SparkSignatureDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SparkSignatureDataValidationError{}

// Validate checks the field values on SparkSignatureLeafData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SparkSignatureLeafData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SparkSignatureLeafData with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SparkSignatureLeafDataMultiError, or nil if none found.
func (m *SparkSignatureLeafData) ValidateAll() error {
	return m.validate(true)
}

func (m *SparkSignatureLeafData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SpentLeafIndex

	if m.RevocationPrivateKey != nil {
		// no validation rules for RevocationPrivateKey
	}

	if len(errors) > 0 {
		return SparkSignatureLeafDataMultiError(errors)
	}

	return nil
}

// SparkSignatureLeafDataMultiError is an error wrapping multiple validation
// errors returned by SparkSignatureLeafData.ValidateAll() if the designated
// constraints aren't met.
type SparkSignatureLeafDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SparkSignatureLeafDataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SparkSignatureLeafDataMultiError) AllErrors() []error { return m }

// SparkSignatureLeafDataValidationError is the validation error returned by
// SparkSignatureLeafData.Validate if the designated constraints aren't met.
type SparkSignatureLeafDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SparkSignatureLeafDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SparkSignatureLeafDataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SparkSignatureLeafDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SparkSignatureLeafDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SparkSignatureLeafDataValidationError) ErrorName() string {
	return "SparkSignatureLeafDataValidationError"
}

// Error satisfies the builtin error interface
func (e SparkSignatureLeafDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSparkSignatureLeafData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SparkSignatureLeafDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SparkSignatureLeafDataValidationError{}

// Validate checks the field values on GetSparkTxRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetSparkTxRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSparkTxRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSparkTxRequestMultiError, or nil if none found.
func (m *GetSparkTxRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSparkTxRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FinalTokenTransactionHash

	if len(errors) > 0 {
		return GetSparkTxRequestMultiError(errors)
	}

	return nil
}

// GetSparkTxRequestMultiError is an error wrapping multiple validation errors
// returned by GetSparkTxRequest.ValidateAll() if the designated constraints
// aren't met.
type GetSparkTxRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSparkTxRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSparkTxRequestMultiError) AllErrors() []error { return m }

// GetSparkTxRequestValidationError is the validation error returned by
// GetSparkTxRequest.Validate if the designated constraints aren't met.
type GetSparkTxRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSparkTxRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSparkTxRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSparkTxRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSparkTxRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSparkTxRequestValidationError) ErrorName() string {
	return "GetSparkTxRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSparkTxRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSparkTxRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSparkTxRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSparkTxRequestValidationError{}

// Validate checks the field values on VerifySparkTxRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *VerifySparkTxRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on VerifySparkTxRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// VerifySparkTxRequestMultiError, or nil if none found.
func (m *VerifySparkTxRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *VerifySparkTxRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, VerifySparkTxRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, VerifySparkTxRequestValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return VerifySparkTxRequestValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return VerifySparkTxRequestMultiError(errors)
	}

	return nil
}

// VerifySparkTxRequestMultiError is an error wrapping multiple validation
// errors returned by VerifySparkTxRequest.ValidateAll() if the designated
// constraints aren't met.
type VerifySparkTxRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VerifySparkTxRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VerifySparkTxRequestMultiError) AllErrors() []error { return m }

// VerifySparkTxRequestValidationError is the validation error returned by
// VerifySparkTxRequest.Validate if the designated constraints aren't met.
type VerifySparkTxRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VerifySparkTxRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VerifySparkTxRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VerifySparkTxRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VerifySparkTxRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VerifySparkTxRequestValidationError) ErrorName() string {
	return "VerifySparkTxRequestValidationError"
}

// Error satisfies the builtin error interface
func (e VerifySparkTxRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVerifySparkTxRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VerifySparkTxRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VerifySparkTxRequestValidationError{}

// Validate checks the field values on ListSparkTxsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSparkTxsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSparkTxsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSparkTxsRequestMultiError, or nil if none found.
func (m *ListSparkTxsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSparkTxsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.PageToken != nil {
		// no validation rules for PageToken
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListSparkTxsRequestMultiError(errors)
	}

	return nil
}

// ListSparkTxsRequestMultiError is an error wrapping multiple validation
// errors returned by ListSparkTxsRequest.ValidateAll() if the designated
// constraints aren't met.
type ListSparkTxsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSparkTxsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSparkTxsRequestMultiError) AllErrors() []error { return m }

// ListSparkTxsRequestValidationError is the validation error returned by
// ListSparkTxsRequest.Validate if the designated constraints aren't met.
type ListSparkTxsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSparkTxsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSparkTxsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSparkTxsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSparkTxsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSparkTxsRequestValidationError) ErrorName() string {
	return "ListSparkTxsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListSparkTxsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSparkTxsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSparkTxsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSparkTxsRequestValidationError{}

// Validate checks the field values on ListSparkTxsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSparkTxsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSparkTxsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSparkTxsResponseMultiError, or nil if none found.
func (m *ListSparkTxsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSparkTxsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTokenTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListSparkTxsResponseValidationError{
						field:  fmt.Sprintf("TokenTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListSparkTxsResponseValidationError{
						field:  fmt.Sprintf("TokenTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListSparkTxsResponseValidationError{
					field:  fmt.Sprintf("TokenTransactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.NextPageToken != nil {
		// no validation rules for NextPageToken
	}

	if len(errors) > 0 {
		return ListSparkTxsResponseMultiError(errors)
	}

	return nil
}

// ListSparkTxsResponseMultiError is an error wrapping multiple validation
// errors returned by ListSparkTxsResponse.ValidateAll() if the designated
// constraints aren't met.
type ListSparkTxsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSparkTxsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSparkTxsResponseMultiError) AllErrors() []error { return m }

// ListSparkTxsResponseValidationError is the validation error returned by
// ListSparkTxsResponse.Validate if the designated constraints aren't met.
type ListSparkTxsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSparkTxsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSparkTxsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSparkTxsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSparkTxsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSparkTxsResponseValidationError) ErrorName() string {
	return "ListSparkTxsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListSparkTxsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSparkTxsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSparkTxsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSparkTxsResponseValidationError{}

// Validate checks the field values on GetSparkTxResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSparkTxResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSparkTxResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSparkTxResponseMultiError, or nil if none found.
func (m *GetSparkTxResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSparkTxResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetSparkTxResponseValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetSparkTxResponseValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetSparkTxResponseValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetSparkTxResponseMultiError(errors)
	}

	return nil
}

// GetSparkTxResponseMultiError is an error wrapping multiple validation errors
// returned by GetSparkTxResponse.ValidateAll() if the designated constraints
// aren't met.
type GetSparkTxResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSparkTxResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSparkTxResponseMultiError) AllErrors() []error { return m }

// GetSparkTxResponseValidationError is the validation error returned by
// GetSparkTxResponse.Validate if the designated constraints aren't met.
type GetSparkTxResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSparkTxResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSparkTxResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSparkTxResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSparkTxResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSparkTxResponseValidationError) ErrorName() string {
	return "GetSparkTxResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSparkTxResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSparkTxResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSparkTxResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSparkTxResponseValidationError{}

// Validate checks the field values on TokenTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TokenTransactionResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TokenTransactionResponseMultiError, or nil if none found.
func (m *TokenTransactionResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenTransactionResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Finalized

	if all {
		switch v := interface{}(m.GetFinalTokenTransaction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TokenTransactionResponseValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TokenTransactionResponseValidationError{
					field:  "FinalTokenTransaction",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinalTokenTransaction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TokenTransactionResponseValidationError{
				field:  "FinalTokenTransaction",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TokenTransactionResponseMultiError(errors)
	}

	return nil
}

// TokenTransactionResponseMultiError is an error wrapping multiple validation
// errors returned by TokenTransactionResponse.ValidateAll() if the designated
// constraints aren't met.
type TokenTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenTransactionResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenTransactionResponseMultiError) AllErrors() []error { return m }

// TokenTransactionResponseValidationError is the validation error returned by
// TokenTransactionResponse.Validate if the designated constraints aren't met.
type TokenTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenTransactionResponseValidationError) ErrorName() string {
	return "TokenTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e TokenTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenTransactionResponseValidationError{}

// Validate checks the field values on ListWithdrawnLeavesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListWithdrawnLeavesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWithdrawnLeavesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListWithdrawnLeavesRequestMultiError, or nil if none found.
func (m *ListWithdrawnLeavesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWithdrawnLeavesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Blockhash != nil {
		// no validation rules for Blockhash
	}

	if m.PageToken != nil {
		// no validation rules for PageToken
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if len(errors) > 0 {
		return ListWithdrawnLeavesRequestMultiError(errors)
	}

	return nil
}

// ListWithdrawnLeavesRequestMultiError is an error wrapping multiple
// validation errors returned by ListWithdrawnLeavesRequest.ValidateAll() if
// the designated constraints aren't met.
type ListWithdrawnLeavesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWithdrawnLeavesRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWithdrawnLeavesRequestMultiError) AllErrors() []error { return m }

// ListWithdrawnLeavesRequestValidationError is the validation error returned
// by ListWithdrawnLeavesRequest.Validate if the designated constraints aren't met.
type ListWithdrawnLeavesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWithdrawnLeavesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWithdrawnLeavesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWithdrawnLeavesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWithdrawnLeavesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWithdrawnLeavesRequestValidationError) ErrorName() string {
	return "ListWithdrawnLeavesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListWithdrawnLeavesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWithdrawnLeavesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWithdrawnLeavesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWithdrawnLeavesRequestValidationError{}

// Validate checks the field values on ListWithdrawnLeavesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListWithdrawnLeavesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWithdrawnLeavesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListWithdrawnLeavesResponseMultiError, or nil if none found.
func (m *ListWithdrawnLeavesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWithdrawnLeavesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLeaves() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListWithdrawnLeavesResponseValidationError{
						field:  fmt.Sprintf("Leaves[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListWithdrawnLeavesResponseValidationError{
						field:  fmt.Sprintf("Leaves[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListWithdrawnLeavesResponseValidationError{
					field:  fmt.Sprintf("Leaves[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.NextPageToken != nil {
		// no validation rules for NextPageToken
	}

	if len(errors) > 0 {
		return ListWithdrawnLeavesResponseMultiError(errors)
	}

	return nil
}

// ListWithdrawnLeavesResponseMultiError is an error wrapping multiple
// validation errors returned by ListWithdrawnLeavesResponse.ValidateAll() if
// the designated constraints aren't met.
type ListWithdrawnLeavesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWithdrawnLeavesResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWithdrawnLeavesResponseMultiError) AllErrors() []error { return m }

// ListWithdrawnLeavesResponseValidationError is the validation error returned
// by ListWithdrawnLeavesResponse.Validate if the designated constraints
// aren't met.
type ListWithdrawnLeavesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWithdrawnLeavesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWithdrawnLeavesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWithdrawnLeavesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWithdrawnLeavesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWithdrawnLeavesResponseValidationError) ErrorName() string {
	return "ListWithdrawnLeavesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListWithdrawnLeavesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWithdrawnLeavesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWithdrawnLeavesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWithdrawnLeavesResponseValidationError{}
