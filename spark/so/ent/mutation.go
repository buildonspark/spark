// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/lightsparkdev/spark-go/so/ent/blockheight"
	"github.com/lightsparkdev/spark-go/so/ent/cooperativeexit"
	"github.com/lightsparkdev/spark-go/so/ent/depositaddress"
	"github.com/lightsparkdev/spark-go/so/ent/predicate"
	"github.com/lightsparkdev/spark-go/so/ent/preimagerequest"
	"github.com/lightsparkdev/spark-go/so/ent/preimageshare"
	"github.com/lightsparkdev/spark-go/so/ent/schema"
	"github.com/lightsparkdev/spark-go/so/ent/signingkeyshare"
	"github.com/lightsparkdev/spark-go/so/ent/signingnonce"
	"github.com/lightsparkdev/spark-go/so/ent/tokenissuance"
	"github.com/lightsparkdev/spark-go/so/ent/tokenleaf"
	"github.com/lightsparkdev/spark-go/so/ent/tokentransactionreceipt"
	"github.com/lightsparkdev/spark-go/so/ent/transfer"
	"github.com/lightsparkdev/spark-go/so/ent/transferleaf"
	"github.com/lightsparkdev/spark-go/so/ent/tree"
	"github.com/lightsparkdev/spark-go/so/ent/treenode"
	"github.com/lightsparkdev/spark-go/so/ent/usersignedtransaction"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBlockHeight             = "BlockHeight"
	TypeCooperativeExit         = "CooperativeExit"
	TypeDepositAddress          = "DepositAddress"
	TypePreimageRequest         = "PreimageRequest"
	TypePreimageShare           = "PreimageShare"
	TypeSigningKeyshare         = "SigningKeyshare"
	TypeSigningNonce            = "SigningNonce"
	TypeTokenIssuance           = "TokenIssuance"
	TypeTokenLeaf               = "TokenLeaf"
	TypeTokenTransactionReceipt = "TokenTransactionReceipt"
	TypeTransfer                = "Transfer"
	TypeTransferLeaf            = "TransferLeaf"
	TypeTree                    = "Tree"
	TypeTreeNode                = "TreeNode"
	TypeUserSignedTransaction   = "UserSignedTransaction"
)

// BlockHeightMutation represents an operation that mutates the BlockHeight nodes in the graph.
type BlockHeightMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	create_time   *time.Time
	update_time   *time.Time
	height        *int64
	addheight     *int64
	network       *schema.Network
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*BlockHeight, error)
	predicates    []predicate.BlockHeight
}

var _ ent.Mutation = (*BlockHeightMutation)(nil)

// blockheightOption allows management of the mutation configuration using functional options.
type blockheightOption func(*BlockHeightMutation)

// newBlockHeightMutation creates new mutation for the BlockHeight entity.
func newBlockHeightMutation(c config, op Op, opts ...blockheightOption) *BlockHeightMutation {
	m := &BlockHeightMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockHeight,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockHeightID sets the ID field of the mutation.
func withBlockHeightID(id uuid.UUID) blockheightOption {
	return func(m *BlockHeightMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockHeight
		)
		m.oldValue = func(ctx context.Context) (*BlockHeight, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockHeight.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockHeight sets the old BlockHeight of the mutation.
func withBlockHeight(node *BlockHeight) blockheightOption {
	return func(m *BlockHeightMutation) {
		m.oldValue = func(context.Context) (*BlockHeight, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockHeightMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockHeightMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlockHeight entities.
func (m *BlockHeightMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockHeightMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockHeightMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockHeight.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *BlockHeightMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *BlockHeightMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the BlockHeight entity.
// If the BlockHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeightMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *BlockHeightMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *BlockHeightMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *BlockHeightMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the BlockHeight entity.
// If the BlockHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeightMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *BlockHeightMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetHeight sets the "height" field.
func (m *BlockHeightMutation) SetHeight(i int64) {
	m.height = &i
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *BlockHeightMutation) Height() (r int64, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the BlockHeight entity.
// If the BlockHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeightMutation) OldHeight(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds i to the "height" field.
func (m *BlockHeightMutation) AddHeight(i int64) {
	if m.addheight != nil {
		*m.addheight += i
	} else {
		m.addheight = &i
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *BlockHeightMutation) AddedHeight() (r int64, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeight resets all changes to the "height" field.
func (m *BlockHeightMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
}

// SetNetwork sets the "network" field.
func (m *BlockHeightMutation) SetNetwork(s schema.Network) {
	m.network = &s
}

// Network returns the value of the "network" field in the mutation.
func (m *BlockHeightMutation) Network() (r schema.Network, exists bool) {
	v := m.network
	if v == nil {
		return
	}
	return *v, true
}

// OldNetwork returns the old "network" field's value of the BlockHeight entity.
// If the BlockHeight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockHeightMutation) OldNetwork(ctx context.Context) (v schema.Network, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetwork is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetwork requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetwork: %w", err)
	}
	return oldValue.Network, nil
}

// ResetNetwork resets all changes to the "network" field.
func (m *BlockHeightMutation) ResetNetwork() {
	m.network = nil
}

// Where appends a list predicates to the BlockHeightMutation builder.
func (m *BlockHeightMutation) Where(ps ...predicate.BlockHeight) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockHeightMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockHeightMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockHeight, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockHeightMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockHeightMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockHeight).
func (m *BlockHeightMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockHeightMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, blockheight.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, blockheight.FieldUpdateTime)
	}
	if m.height != nil {
		fields = append(fields, blockheight.FieldHeight)
	}
	if m.network != nil {
		fields = append(fields, blockheight.FieldNetwork)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockHeightMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockheight.FieldCreateTime:
		return m.CreateTime()
	case blockheight.FieldUpdateTime:
		return m.UpdateTime()
	case blockheight.FieldHeight:
		return m.Height()
	case blockheight.FieldNetwork:
		return m.Network()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockHeightMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockheight.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case blockheight.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case blockheight.FieldHeight:
		return m.OldHeight(ctx)
	case blockheight.FieldNetwork:
		return m.OldNetwork(ctx)
	}
	return nil, fmt.Errorf("unknown BlockHeight field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockHeightMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockheight.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case blockheight.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case blockheight.FieldHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case blockheight.FieldNetwork:
		v, ok := value.(schema.Network)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetwork(v)
		return nil
	}
	return fmt.Errorf("unknown BlockHeight field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockHeightMutation) AddedFields() []string {
	var fields []string
	if m.addheight != nil {
		fields = append(fields, blockheight.FieldHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockHeightMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blockheight.FieldHeight:
		return m.AddedHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockHeightMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blockheight.FieldHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	}
	return fmt.Errorf("unknown BlockHeight numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockHeightMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockHeightMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockHeightMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BlockHeight nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockHeightMutation) ResetField(name string) error {
	switch name {
	case blockheight.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case blockheight.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case blockheight.FieldHeight:
		m.ResetHeight()
		return nil
	case blockheight.FieldNetwork:
		m.ResetNetwork()
		return nil
	}
	return fmt.Errorf("unknown BlockHeight field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockHeightMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockHeightMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockHeightMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockHeightMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockHeightMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockHeightMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockHeightMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BlockHeight unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockHeightMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BlockHeight edge %s", name)
}

// CooperativeExitMutation represents an operation that mutates the CooperativeExit nodes in the graph.
type CooperativeExitMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	create_time            *time.Time
	update_time            *time.Time
	exit_txid              *[]byte
	confirmation_height    *int64
	addconfirmation_height *int64
	clearedFields          map[string]struct{}
	transfer               *uuid.UUID
	clearedtransfer        bool
	done                   bool
	oldValue               func(context.Context) (*CooperativeExit, error)
	predicates             []predicate.CooperativeExit
}

var _ ent.Mutation = (*CooperativeExitMutation)(nil)

// cooperativeexitOption allows management of the mutation configuration using functional options.
type cooperativeexitOption func(*CooperativeExitMutation)

// newCooperativeExitMutation creates new mutation for the CooperativeExit entity.
func newCooperativeExitMutation(c config, op Op, opts ...cooperativeexitOption) *CooperativeExitMutation {
	m := &CooperativeExitMutation{
		config:        c,
		op:            op,
		typ:           TypeCooperativeExit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCooperativeExitID sets the ID field of the mutation.
func withCooperativeExitID(id uuid.UUID) cooperativeexitOption {
	return func(m *CooperativeExitMutation) {
		var (
			err   error
			once  sync.Once
			value *CooperativeExit
		)
		m.oldValue = func(ctx context.Context) (*CooperativeExit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CooperativeExit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCooperativeExit sets the old CooperativeExit of the mutation.
func withCooperativeExit(node *CooperativeExit) cooperativeexitOption {
	return func(m *CooperativeExitMutation) {
		m.oldValue = func(context.Context) (*CooperativeExit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CooperativeExitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CooperativeExitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CooperativeExit entities.
func (m *CooperativeExitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CooperativeExitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CooperativeExitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CooperativeExit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CooperativeExitMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CooperativeExitMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CooperativeExit entity.
// If the CooperativeExit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CooperativeExitMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CooperativeExitMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CooperativeExitMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CooperativeExitMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CooperativeExit entity.
// If the CooperativeExit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CooperativeExitMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CooperativeExitMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetExitTxid sets the "exit_txid" field.
func (m *CooperativeExitMutation) SetExitTxid(b []byte) {
	m.exit_txid = &b
}

// ExitTxid returns the value of the "exit_txid" field in the mutation.
func (m *CooperativeExitMutation) ExitTxid() (r []byte, exists bool) {
	v := m.exit_txid
	if v == nil {
		return
	}
	return *v, true
}

// OldExitTxid returns the old "exit_txid" field's value of the CooperativeExit entity.
// If the CooperativeExit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CooperativeExitMutation) OldExitTxid(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExitTxid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExitTxid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExitTxid: %w", err)
	}
	return oldValue.ExitTxid, nil
}

// ResetExitTxid resets all changes to the "exit_txid" field.
func (m *CooperativeExitMutation) ResetExitTxid() {
	m.exit_txid = nil
}

// SetConfirmationHeight sets the "confirmation_height" field.
func (m *CooperativeExitMutation) SetConfirmationHeight(i int64) {
	m.confirmation_height = &i
	m.addconfirmation_height = nil
}

// ConfirmationHeight returns the value of the "confirmation_height" field in the mutation.
func (m *CooperativeExitMutation) ConfirmationHeight() (r int64, exists bool) {
	v := m.confirmation_height
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmationHeight returns the old "confirmation_height" field's value of the CooperativeExit entity.
// If the CooperativeExit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CooperativeExitMutation) OldConfirmationHeight(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmationHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmationHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmationHeight: %w", err)
	}
	return oldValue.ConfirmationHeight, nil
}

// AddConfirmationHeight adds i to the "confirmation_height" field.
func (m *CooperativeExitMutation) AddConfirmationHeight(i int64) {
	if m.addconfirmation_height != nil {
		*m.addconfirmation_height += i
	} else {
		m.addconfirmation_height = &i
	}
}

// AddedConfirmationHeight returns the value that was added to the "confirmation_height" field in this mutation.
func (m *CooperativeExitMutation) AddedConfirmationHeight() (r int64, exists bool) {
	v := m.addconfirmation_height
	if v == nil {
		return
	}
	return *v, true
}

// ClearConfirmationHeight clears the value of the "confirmation_height" field.
func (m *CooperativeExitMutation) ClearConfirmationHeight() {
	m.confirmation_height = nil
	m.addconfirmation_height = nil
	m.clearedFields[cooperativeexit.FieldConfirmationHeight] = struct{}{}
}

// ConfirmationHeightCleared returns if the "confirmation_height" field was cleared in this mutation.
func (m *CooperativeExitMutation) ConfirmationHeightCleared() bool {
	_, ok := m.clearedFields[cooperativeexit.FieldConfirmationHeight]
	return ok
}

// ResetConfirmationHeight resets all changes to the "confirmation_height" field.
func (m *CooperativeExitMutation) ResetConfirmationHeight() {
	m.confirmation_height = nil
	m.addconfirmation_height = nil
	delete(m.clearedFields, cooperativeexit.FieldConfirmationHeight)
}

// SetTransferID sets the "transfer" edge to the Transfer entity by id.
func (m *CooperativeExitMutation) SetTransferID(id uuid.UUID) {
	m.transfer = &id
}

// ClearTransfer clears the "transfer" edge to the Transfer entity.
func (m *CooperativeExitMutation) ClearTransfer() {
	m.clearedtransfer = true
}

// TransferCleared reports if the "transfer" edge to the Transfer entity was cleared.
func (m *CooperativeExitMutation) TransferCleared() bool {
	return m.clearedtransfer
}

// TransferID returns the "transfer" edge ID in the mutation.
func (m *CooperativeExitMutation) TransferID() (id uuid.UUID, exists bool) {
	if m.transfer != nil {
		return *m.transfer, true
	}
	return
}

// TransferIDs returns the "transfer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransferID instead. It exists only for internal usage by the builders.
func (m *CooperativeExitMutation) TransferIDs() (ids []uuid.UUID) {
	if id := m.transfer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransfer resets all changes to the "transfer" edge.
func (m *CooperativeExitMutation) ResetTransfer() {
	m.transfer = nil
	m.clearedtransfer = false
}

// Where appends a list predicates to the CooperativeExitMutation builder.
func (m *CooperativeExitMutation) Where(ps ...predicate.CooperativeExit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CooperativeExitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CooperativeExitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CooperativeExit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CooperativeExitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CooperativeExitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CooperativeExit).
func (m *CooperativeExitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CooperativeExitMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, cooperativeexit.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, cooperativeexit.FieldUpdateTime)
	}
	if m.exit_txid != nil {
		fields = append(fields, cooperativeexit.FieldExitTxid)
	}
	if m.confirmation_height != nil {
		fields = append(fields, cooperativeexit.FieldConfirmationHeight)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CooperativeExitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cooperativeexit.FieldCreateTime:
		return m.CreateTime()
	case cooperativeexit.FieldUpdateTime:
		return m.UpdateTime()
	case cooperativeexit.FieldExitTxid:
		return m.ExitTxid()
	case cooperativeexit.FieldConfirmationHeight:
		return m.ConfirmationHeight()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CooperativeExitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cooperativeexit.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case cooperativeexit.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case cooperativeexit.FieldExitTxid:
		return m.OldExitTxid(ctx)
	case cooperativeexit.FieldConfirmationHeight:
		return m.OldConfirmationHeight(ctx)
	}
	return nil, fmt.Errorf("unknown CooperativeExit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CooperativeExitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cooperativeexit.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case cooperativeexit.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case cooperativeexit.FieldExitTxid:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExitTxid(v)
		return nil
	case cooperativeexit.FieldConfirmationHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmationHeight(v)
		return nil
	}
	return fmt.Errorf("unknown CooperativeExit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CooperativeExitMutation) AddedFields() []string {
	var fields []string
	if m.addconfirmation_height != nil {
		fields = append(fields, cooperativeexit.FieldConfirmationHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CooperativeExitMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cooperativeexit.FieldConfirmationHeight:
		return m.AddedConfirmationHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CooperativeExitMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cooperativeexit.FieldConfirmationHeight:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfirmationHeight(v)
		return nil
	}
	return fmt.Errorf("unknown CooperativeExit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CooperativeExitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cooperativeexit.FieldConfirmationHeight) {
		fields = append(fields, cooperativeexit.FieldConfirmationHeight)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CooperativeExitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CooperativeExitMutation) ClearField(name string) error {
	switch name {
	case cooperativeexit.FieldConfirmationHeight:
		m.ClearConfirmationHeight()
		return nil
	}
	return fmt.Errorf("unknown CooperativeExit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CooperativeExitMutation) ResetField(name string) error {
	switch name {
	case cooperativeexit.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case cooperativeexit.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case cooperativeexit.FieldExitTxid:
		m.ResetExitTxid()
		return nil
	case cooperativeexit.FieldConfirmationHeight:
		m.ResetConfirmationHeight()
		return nil
	}
	return fmt.Errorf("unknown CooperativeExit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CooperativeExitMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transfer != nil {
		edges = append(edges, cooperativeexit.EdgeTransfer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CooperativeExitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cooperativeexit.EdgeTransfer:
		if id := m.transfer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CooperativeExitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CooperativeExitMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CooperativeExitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtransfer {
		edges = append(edges, cooperativeexit.EdgeTransfer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CooperativeExitMutation) EdgeCleared(name string) bool {
	switch name {
	case cooperativeexit.EdgeTransfer:
		return m.clearedtransfer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CooperativeExitMutation) ClearEdge(name string) error {
	switch name {
	case cooperativeexit.EdgeTransfer:
		m.ClearTransfer()
		return nil
	}
	return fmt.Errorf("unknown CooperativeExit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CooperativeExitMutation) ResetEdge(name string) error {
	switch name {
	case cooperativeexit.EdgeTransfer:
		m.ResetTransfer()
		return nil
	}
	return fmt.Errorf("unknown CooperativeExit edge %s", name)
}

// DepositAddressMutation represents an operation that mutates the DepositAddress nodes in the graph.
type DepositAddressMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	create_time             *time.Time
	update_time             *time.Time
	address                 *string
	owner_identity_pubkey   *[]byte
	owner_signing_pubkey    *[]byte
	clearedFields           map[string]struct{}
	signing_keyshare        *uuid.UUID
	clearedsigning_keyshare bool
	done                    bool
	oldValue                func(context.Context) (*DepositAddress, error)
	predicates              []predicate.DepositAddress
}

var _ ent.Mutation = (*DepositAddressMutation)(nil)

// depositaddressOption allows management of the mutation configuration using functional options.
type depositaddressOption func(*DepositAddressMutation)

// newDepositAddressMutation creates new mutation for the DepositAddress entity.
func newDepositAddressMutation(c config, op Op, opts ...depositaddressOption) *DepositAddressMutation {
	m := &DepositAddressMutation{
		config:        c,
		op:            op,
		typ:           TypeDepositAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepositAddressID sets the ID field of the mutation.
func withDepositAddressID(id uuid.UUID) depositaddressOption {
	return func(m *DepositAddressMutation) {
		var (
			err   error
			once  sync.Once
			value *DepositAddress
		)
		m.oldValue = func(ctx context.Context) (*DepositAddress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DepositAddress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepositAddress sets the old DepositAddress of the mutation.
func withDepositAddress(node *DepositAddress) depositaddressOption {
	return func(m *DepositAddressMutation) {
		m.oldValue = func(context.Context) (*DepositAddress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepositAddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepositAddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DepositAddress entities.
func (m *DepositAddressMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepositAddressMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepositAddressMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DepositAddress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *DepositAddressMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DepositAddressMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DepositAddressMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DepositAddressMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DepositAddressMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DepositAddressMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetAddress sets the "address" field.
func (m *DepositAddressMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *DepositAddressMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *DepositAddressMutation) ResetAddress() {
	m.address = nil
}

// SetOwnerIdentityPubkey sets the "owner_identity_pubkey" field.
func (m *DepositAddressMutation) SetOwnerIdentityPubkey(b []byte) {
	m.owner_identity_pubkey = &b
}

// OwnerIdentityPubkey returns the value of the "owner_identity_pubkey" field in the mutation.
func (m *DepositAddressMutation) OwnerIdentityPubkey() (r []byte, exists bool) {
	v := m.owner_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerIdentityPubkey returns the old "owner_identity_pubkey" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldOwnerIdentityPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerIdentityPubkey: %w", err)
	}
	return oldValue.OwnerIdentityPubkey, nil
}

// ResetOwnerIdentityPubkey resets all changes to the "owner_identity_pubkey" field.
func (m *DepositAddressMutation) ResetOwnerIdentityPubkey() {
	m.owner_identity_pubkey = nil
}

// SetOwnerSigningPubkey sets the "owner_signing_pubkey" field.
func (m *DepositAddressMutation) SetOwnerSigningPubkey(b []byte) {
	m.owner_signing_pubkey = &b
}

// OwnerSigningPubkey returns the value of the "owner_signing_pubkey" field in the mutation.
func (m *DepositAddressMutation) OwnerSigningPubkey() (r []byte, exists bool) {
	v := m.owner_signing_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerSigningPubkey returns the old "owner_signing_pubkey" field's value of the DepositAddress entity.
// If the DepositAddress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepositAddressMutation) OldOwnerSigningPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerSigningPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerSigningPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerSigningPubkey: %w", err)
	}
	return oldValue.OwnerSigningPubkey, nil
}

// ResetOwnerSigningPubkey resets all changes to the "owner_signing_pubkey" field.
func (m *DepositAddressMutation) ResetOwnerSigningPubkey() {
	m.owner_signing_pubkey = nil
}

// SetSigningKeyshareID sets the "signing_keyshare" edge to the SigningKeyshare entity by id.
func (m *DepositAddressMutation) SetSigningKeyshareID(id uuid.UUID) {
	m.signing_keyshare = &id
}

// ClearSigningKeyshare clears the "signing_keyshare" edge to the SigningKeyshare entity.
func (m *DepositAddressMutation) ClearSigningKeyshare() {
	m.clearedsigning_keyshare = true
}

// SigningKeyshareCleared reports if the "signing_keyshare" edge to the SigningKeyshare entity was cleared.
func (m *DepositAddressMutation) SigningKeyshareCleared() bool {
	return m.clearedsigning_keyshare
}

// SigningKeyshareID returns the "signing_keyshare" edge ID in the mutation.
func (m *DepositAddressMutation) SigningKeyshareID() (id uuid.UUID, exists bool) {
	if m.signing_keyshare != nil {
		return *m.signing_keyshare, true
	}
	return
}

// SigningKeyshareIDs returns the "signing_keyshare" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SigningKeyshareID instead. It exists only for internal usage by the builders.
func (m *DepositAddressMutation) SigningKeyshareIDs() (ids []uuid.UUID) {
	if id := m.signing_keyshare; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSigningKeyshare resets all changes to the "signing_keyshare" edge.
func (m *DepositAddressMutation) ResetSigningKeyshare() {
	m.signing_keyshare = nil
	m.clearedsigning_keyshare = false
}

// Where appends a list predicates to the DepositAddressMutation builder.
func (m *DepositAddressMutation) Where(ps ...predicate.DepositAddress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepositAddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepositAddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DepositAddress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepositAddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepositAddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DepositAddress).
func (m *DepositAddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepositAddressMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, depositaddress.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, depositaddress.FieldUpdateTime)
	}
	if m.address != nil {
		fields = append(fields, depositaddress.FieldAddress)
	}
	if m.owner_identity_pubkey != nil {
		fields = append(fields, depositaddress.FieldOwnerIdentityPubkey)
	}
	if m.owner_signing_pubkey != nil {
		fields = append(fields, depositaddress.FieldOwnerSigningPubkey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepositAddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case depositaddress.FieldCreateTime:
		return m.CreateTime()
	case depositaddress.FieldUpdateTime:
		return m.UpdateTime()
	case depositaddress.FieldAddress:
		return m.Address()
	case depositaddress.FieldOwnerIdentityPubkey:
		return m.OwnerIdentityPubkey()
	case depositaddress.FieldOwnerSigningPubkey:
		return m.OwnerSigningPubkey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepositAddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case depositaddress.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case depositaddress.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case depositaddress.FieldAddress:
		return m.OldAddress(ctx)
	case depositaddress.FieldOwnerIdentityPubkey:
		return m.OldOwnerIdentityPubkey(ctx)
	case depositaddress.FieldOwnerSigningPubkey:
		return m.OldOwnerSigningPubkey(ctx)
	}
	return nil, fmt.Errorf("unknown DepositAddress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepositAddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case depositaddress.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case depositaddress.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case depositaddress.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case depositaddress.FieldOwnerIdentityPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerIdentityPubkey(v)
		return nil
	case depositaddress.FieldOwnerSigningPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerSigningPubkey(v)
		return nil
	}
	return fmt.Errorf("unknown DepositAddress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepositAddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepositAddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepositAddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DepositAddress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepositAddressMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepositAddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepositAddressMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DepositAddress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepositAddressMutation) ResetField(name string) error {
	switch name {
	case depositaddress.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case depositaddress.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case depositaddress.FieldAddress:
		m.ResetAddress()
		return nil
	case depositaddress.FieldOwnerIdentityPubkey:
		m.ResetOwnerIdentityPubkey()
		return nil
	case depositaddress.FieldOwnerSigningPubkey:
		m.ResetOwnerSigningPubkey()
		return nil
	}
	return fmt.Errorf("unknown DepositAddress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepositAddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.signing_keyshare != nil {
		edges = append(edges, depositaddress.EdgeSigningKeyshare)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepositAddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case depositaddress.EdgeSigningKeyshare:
		if id := m.signing_keyshare; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepositAddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepositAddressMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepositAddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsigning_keyshare {
		edges = append(edges, depositaddress.EdgeSigningKeyshare)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepositAddressMutation) EdgeCleared(name string) bool {
	switch name {
	case depositaddress.EdgeSigningKeyshare:
		return m.clearedsigning_keyshare
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepositAddressMutation) ClearEdge(name string) error {
	switch name {
	case depositaddress.EdgeSigningKeyshare:
		m.ClearSigningKeyshare()
		return nil
	}
	return fmt.Errorf("unknown DepositAddress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepositAddressMutation) ResetEdge(name string) error {
	switch name {
	case depositaddress.EdgeSigningKeyshare:
		m.ResetSigningKeyshare()
		return nil
	}
	return fmt.Errorf("unknown DepositAddress edge %s", name)
}

// PreimageRequestMutation represents an operation that mutates the PreimageRequest nodes in the graph.
type PreimageRequestMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	create_time            *time.Time
	update_time            *time.Time
	payment_hash           *[]byte
	status                 *schema.PreimageRequestStatus
	clearedFields          map[string]struct{}
	transactions           map[uuid.UUID]struct{}
	removedtransactions    map[uuid.UUID]struct{}
	clearedtransactions    bool
	preimage_shares        *uuid.UUID
	clearedpreimage_shares bool
	transfers              *uuid.UUID
	clearedtransfers       bool
	done                   bool
	oldValue               func(context.Context) (*PreimageRequest, error)
	predicates             []predicate.PreimageRequest
}

var _ ent.Mutation = (*PreimageRequestMutation)(nil)

// preimagerequestOption allows management of the mutation configuration using functional options.
type preimagerequestOption func(*PreimageRequestMutation)

// newPreimageRequestMutation creates new mutation for the PreimageRequest entity.
func newPreimageRequestMutation(c config, op Op, opts ...preimagerequestOption) *PreimageRequestMutation {
	m := &PreimageRequestMutation{
		config:        c,
		op:            op,
		typ:           TypePreimageRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPreimageRequestID sets the ID field of the mutation.
func withPreimageRequestID(id uuid.UUID) preimagerequestOption {
	return func(m *PreimageRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *PreimageRequest
		)
		m.oldValue = func(ctx context.Context) (*PreimageRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PreimageRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPreimageRequest sets the old PreimageRequest of the mutation.
func withPreimageRequest(node *PreimageRequest) preimagerequestOption {
	return func(m *PreimageRequestMutation) {
		m.oldValue = func(context.Context) (*PreimageRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PreimageRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PreimageRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PreimageRequest entities.
func (m *PreimageRequestMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PreimageRequestMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PreimageRequestMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PreimageRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PreimageRequestMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PreimageRequestMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PreimageRequest entity.
// If the PreimageRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageRequestMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PreimageRequestMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PreimageRequestMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PreimageRequestMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PreimageRequest entity.
// If the PreimageRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageRequestMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PreimageRequestMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPaymentHash sets the "payment_hash" field.
func (m *PreimageRequestMutation) SetPaymentHash(b []byte) {
	m.payment_hash = &b
}

// PaymentHash returns the value of the "payment_hash" field in the mutation.
func (m *PreimageRequestMutation) PaymentHash() (r []byte, exists bool) {
	v := m.payment_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentHash returns the old "payment_hash" field's value of the PreimageRequest entity.
// If the PreimageRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageRequestMutation) OldPaymentHash(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentHash: %w", err)
	}
	return oldValue.PaymentHash, nil
}

// ResetPaymentHash resets all changes to the "payment_hash" field.
func (m *PreimageRequestMutation) ResetPaymentHash() {
	m.payment_hash = nil
}

// SetStatus sets the "status" field.
func (m *PreimageRequestMutation) SetStatus(srs schema.PreimageRequestStatus) {
	m.status = &srs
}

// Status returns the value of the "status" field in the mutation.
func (m *PreimageRequestMutation) Status() (r schema.PreimageRequestStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PreimageRequest entity.
// If the PreimageRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageRequestMutation) OldStatus(ctx context.Context) (v schema.PreimageRequestStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PreimageRequestMutation) ResetStatus() {
	m.status = nil
}

// AddTransactionIDs adds the "transactions" edge to the UserSignedTransaction entity by ids.
func (m *PreimageRequestMutation) AddTransactionIDs(ids ...uuid.UUID) {
	if m.transactions == nil {
		m.transactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.transactions[ids[i]] = struct{}{}
	}
}

// ClearTransactions clears the "transactions" edge to the UserSignedTransaction entity.
func (m *PreimageRequestMutation) ClearTransactions() {
	m.clearedtransactions = true
}

// TransactionsCleared reports if the "transactions" edge to the UserSignedTransaction entity was cleared.
func (m *PreimageRequestMutation) TransactionsCleared() bool {
	return m.clearedtransactions
}

// RemoveTransactionIDs removes the "transactions" edge to the UserSignedTransaction entity by IDs.
func (m *PreimageRequestMutation) RemoveTransactionIDs(ids ...uuid.UUID) {
	if m.removedtransactions == nil {
		m.removedtransactions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.transactions, ids[i])
		m.removedtransactions[ids[i]] = struct{}{}
	}
}

// RemovedTransactions returns the removed IDs of the "transactions" edge to the UserSignedTransaction entity.
func (m *PreimageRequestMutation) RemovedTransactionsIDs() (ids []uuid.UUID) {
	for id := range m.removedtransactions {
		ids = append(ids, id)
	}
	return
}

// TransactionsIDs returns the "transactions" edge IDs in the mutation.
func (m *PreimageRequestMutation) TransactionsIDs() (ids []uuid.UUID) {
	for id := range m.transactions {
		ids = append(ids, id)
	}
	return
}

// ResetTransactions resets all changes to the "transactions" edge.
func (m *PreimageRequestMutation) ResetTransactions() {
	m.transactions = nil
	m.clearedtransactions = false
	m.removedtransactions = nil
}

// SetPreimageSharesID sets the "preimage_shares" edge to the PreimageShare entity by id.
func (m *PreimageRequestMutation) SetPreimageSharesID(id uuid.UUID) {
	m.preimage_shares = &id
}

// ClearPreimageShares clears the "preimage_shares" edge to the PreimageShare entity.
func (m *PreimageRequestMutation) ClearPreimageShares() {
	m.clearedpreimage_shares = true
}

// PreimageSharesCleared reports if the "preimage_shares" edge to the PreimageShare entity was cleared.
func (m *PreimageRequestMutation) PreimageSharesCleared() bool {
	return m.clearedpreimage_shares
}

// PreimageSharesID returns the "preimage_shares" edge ID in the mutation.
func (m *PreimageRequestMutation) PreimageSharesID() (id uuid.UUID, exists bool) {
	if m.preimage_shares != nil {
		return *m.preimage_shares, true
	}
	return
}

// PreimageSharesIDs returns the "preimage_shares" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PreimageSharesID instead. It exists only for internal usage by the builders.
func (m *PreimageRequestMutation) PreimageSharesIDs() (ids []uuid.UUID) {
	if id := m.preimage_shares; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPreimageShares resets all changes to the "preimage_shares" edge.
func (m *PreimageRequestMutation) ResetPreimageShares() {
	m.preimage_shares = nil
	m.clearedpreimage_shares = false
}

// SetTransfersID sets the "transfers" edge to the Transfer entity by id.
func (m *PreimageRequestMutation) SetTransfersID(id uuid.UUID) {
	m.transfers = &id
}

// ClearTransfers clears the "transfers" edge to the Transfer entity.
func (m *PreimageRequestMutation) ClearTransfers() {
	m.clearedtransfers = true
}

// TransfersCleared reports if the "transfers" edge to the Transfer entity was cleared.
func (m *PreimageRequestMutation) TransfersCleared() bool {
	return m.clearedtransfers
}

// TransfersID returns the "transfers" edge ID in the mutation.
func (m *PreimageRequestMutation) TransfersID() (id uuid.UUID, exists bool) {
	if m.transfers != nil {
		return *m.transfers, true
	}
	return
}

// TransfersIDs returns the "transfers" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransfersID instead. It exists only for internal usage by the builders.
func (m *PreimageRequestMutation) TransfersIDs() (ids []uuid.UUID) {
	if id := m.transfers; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransfers resets all changes to the "transfers" edge.
func (m *PreimageRequestMutation) ResetTransfers() {
	m.transfers = nil
	m.clearedtransfers = false
}

// Where appends a list predicates to the PreimageRequestMutation builder.
func (m *PreimageRequestMutation) Where(ps ...predicate.PreimageRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PreimageRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PreimageRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PreimageRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PreimageRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PreimageRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PreimageRequest).
func (m *PreimageRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PreimageRequestMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, preimagerequest.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, preimagerequest.FieldUpdateTime)
	}
	if m.payment_hash != nil {
		fields = append(fields, preimagerequest.FieldPaymentHash)
	}
	if m.status != nil {
		fields = append(fields, preimagerequest.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PreimageRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case preimagerequest.FieldCreateTime:
		return m.CreateTime()
	case preimagerequest.FieldUpdateTime:
		return m.UpdateTime()
	case preimagerequest.FieldPaymentHash:
		return m.PaymentHash()
	case preimagerequest.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PreimageRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case preimagerequest.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case preimagerequest.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case preimagerequest.FieldPaymentHash:
		return m.OldPaymentHash(ctx)
	case preimagerequest.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown PreimageRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PreimageRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case preimagerequest.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case preimagerequest.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case preimagerequest.FieldPaymentHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentHash(v)
		return nil
	case preimagerequest.FieldStatus:
		v, ok := value.(schema.PreimageRequestStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PreimageRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PreimageRequestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PreimageRequestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PreimageRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PreimageRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PreimageRequestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PreimageRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PreimageRequestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PreimageRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PreimageRequestMutation) ResetField(name string) error {
	switch name {
	case preimagerequest.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case preimagerequest.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case preimagerequest.FieldPaymentHash:
		m.ResetPaymentHash()
		return nil
	case preimagerequest.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown PreimageRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PreimageRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.transactions != nil {
		edges = append(edges, preimagerequest.EdgeTransactions)
	}
	if m.preimage_shares != nil {
		edges = append(edges, preimagerequest.EdgePreimageShares)
	}
	if m.transfers != nil {
		edges = append(edges, preimagerequest.EdgeTransfers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PreimageRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case preimagerequest.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.transactions))
		for id := range m.transactions {
			ids = append(ids, id)
		}
		return ids
	case preimagerequest.EdgePreimageShares:
		if id := m.preimage_shares; id != nil {
			return []ent.Value{*id}
		}
	case preimagerequest.EdgeTransfers:
		if id := m.transfers; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PreimageRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtransactions != nil {
		edges = append(edges, preimagerequest.EdgeTransactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PreimageRequestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case preimagerequest.EdgeTransactions:
		ids := make([]ent.Value, 0, len(m.removedtransactions))
		for id := range m.removedtransactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PreimageRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtransactions {
		edges = append(edges, preimagerequest.EdgeTransactions)
	}
	if m.clearedpreimage_shares {
		edges = append(edges, preimagerequest.EdgePreimageShares)
	}
	if m.clearedtransfers {
		edges = append(edges, preimagerequest.EdgeTransfers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PreimageRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case preimagerequest.EdgeTransactions:
		return m.clearedtransactions
	case preimagerequest.EdgePreimageShares:
		return m.clearedpreimage_shares
	case preimagerequest.EdgeTransfers:
		return m.clearedtransfers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PreimageRequestMutation) ClearEdge(name string) error {
	switch name {
	case preimagerequest.EdgePreimageShares:
		m.ClearPreimageShares()
		return nil
	case preimagerequest.EdgeTransfers:
		m.ClearTransfers()
		return nil
	}
	return fmt.Errorf("unknown PreimageRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PreimageRequestMutation) ResetEdge(name string) error {
	switch name {
	case preimagerequest.EdgeTransactions:
		m.ResetTransactions()
		return nil
	case preimagerequest.EdgePreimageShares:
		m.ResetPreimageShares()
		return nil
	case preimagerequest.EdgeTransfers:
		m.ResetTransfers()
		return nil
	}
	return fmt.Errorf("unknown PreimageRequest edge %s", name)
}

// PreimageShareMutation represents an operation that mutates the PreimageShare nodes in the graph.
type PreimageShareMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	create_time             *time.Time
	update_time             *time.Time
	payment_hash            *[]byte
	preimage_share          *[]byte
	threshold               *uint32
	addthreshold            *int32
	owner_identity_pubkey   *[]byte
	invoice_string          *string
	clearedFields           map[string]struct{}
	preimage_request        *uuid.UUID
	clearedpreimage_request bool
	done                    bool
	oldValue                func(context.Context) (*PreimageShare, error)
	predicates              []predicate.PreimageShare
}

var _ ent.Mutation = (*PreimageShareMutation)(nil)

// preimageshareOption allows management of the mutation configuration using functional options.
type preimageshareOption func(*PreimageShareMutation)

// newPreimageShareMutation creates new mutation for the PreimageShare entity.
func newPreimageShareMutation(c config, op Op, opts ...preimageshareOption) *PreimageShareMutation {
	m := &PreimageShareMutation{
		config:        c,
		op:            op,
		typ:           TypePreimageShare,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPreimageShareID sets the ID field of the mutation.
func withPreimageShareID(id uuid.UUID) preimageshareOption {
	return func(m *PreimageShareMutation) {
		var (
			err   error
			once  sync.Once
			value *PreimageShare
		)
		m.oldValue = func(ctx context.Context) (*PreimageShare, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PreimageShare.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPreimageShare sets the old PreimageShare of the mutation.
func withPreimageShare(node *PreimageShare) preimageshareOption {
	return func(m *PreimageShareMutation) {
		m.oldValue = func(context.Context) (*PreimageShare, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PreimageShareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PreimageShareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PreimageShare entities.
func (m *PreimageShareMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PreimageShareMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PreimageShareMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PreimageShare.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *PreimageShareMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *PreimageShareMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *PreimageShareMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *PreimageShareMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *PreimageShareMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *PreimageShareMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPaymentHash sets the "payment_hash" field.
func (m *PreimageShareMutation) SetPaymentHash(b []byte) {
	m.payment_hash = &b
}

// PaymentHash returns the value of the "payment_hash" field in the mutation.
func (m *PreimageShareMutation) PaymentHash() (r []byte, exists bool) {
	v := m.payment_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentHash returns the old "payment_hash" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldPaymentHash(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentHash: %w", err)
	}
	return oldValue.PaymentHash, nil
}

// ResetPaymentHash resets all changes to the "payment_hash" field.
func (m *PreimageShareMutation) ResetPaymentHash() {
	m.payment_hash = nil
}

// SetPreimageShare sets the "preimage_share" field.
func (m *PreimageShareMutation) SetPreimageShare(b []byte) {
	m.preimage_share = &b
}

// PreimageShare returns the value of the "preimage_share" field in the mutation.
func (m *PreimageShareMutation) PreimageShare() (r []byte, exists bool) {
	v := m.preimage_share
	if v == nil {
		return
	}
	return *v, true
}

// OldPreimageShare returns the old "preimage_share" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldPreimageShare(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreimageShare is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreimageShare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreimageShare: %w", err)
	}
	return oldValue.PreimageShare, nil
}

// ResetPreimageShare resets all changes to the "preimage_share" field.
func (m *PreimageShareMutation) ResetPreimageShare() {
	m.preimage_share = nil
}

// SetThreshold sets the "threshold" field.
func (m *PreimageShareMutation) SetThreshold(u uint32) {
	m.threshold = &u
	m.addthreshold = nil
}

// Threshold returns the value of the "threshold" field in the mutation.
func (m *PreimageShareMutation) Threshold() (r uint32, exists bool) {
	v := m.threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldThreshold returns the old "threshold" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldThreshold(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThreshold: %w", err)
	}
	return oldValue.Threshold, nil
}

// AddThreshold adds u to the "threshold" field.
func (m *PreimageShareMutation) AddThreshold(u int32) {
	if m.addthreshold != nil {
		*m.addthreshold += u
	} else {
		m.addthreshold = &u
	}
}

// AddedThreshold returns the value that was added to the "threshold" field in this mutation.
func (m *PreimageShareMutation) AddedThreshold() (r int32, exists bool) {
	v := m.addthreshold
	if v == nil {
		return
	}
	return *v, true
}

// ResetThreshold resets all changes to the "threshold" field.
func (m *PreimageShareMutation) ResetThreshold() {
	m.threshold = nil
	m.addthreshold = nil
}

// SetOwnerIdentityPubkey sets the "owner_identity_pubkey" field.
func (m *PreimageShareMutation) SetOwnerIdentityPubkey(b []byte) {
	m.owner_identity_pubkey = &b
}

// OwnerIdentityPubkey returns the value of the "owner_identity_pubkey" field in the mutation.
func (m *PreimageShareMutation) OwnerIdentityPubkey() (r []byte, exists bool) {
	v := m.owner_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerIdentityPubkey returns the old "owner_identity_pubkey" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldOwnerIdentityPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerIdentityPubkey: %w", err)
	}
	return oldValue.OwnerIdentityPubkey, nil
}

// ResetOwnerIdentityPubkey resets all changes to the "owner_identity_pubkey" field.
func (m *PreimageShareMutation) ResetOwnerIdentityPubkey() {
	m.owner_identity_pubkey = nil
}

// SetInvoiceString sets the "invoice_string" field.
func (m *PreimageShareMutation) SetInvoiceString(s string) {
	m.invoice_string = &s
}

// InvoiceString returns the value of the "invoice_string" field in the mutation.
func (m *PreimageShareMutation) InvoiceString() (r string, exists bool) {
	v := m.invoice_string
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceString returns the old "invoice_string" field's value of the PreimageShare entity.
// If the PreimageShare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PreimageShareMutation) OldInvoiceString(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceString is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceString requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceString: %w", err)
	}
	return oldValue.InvoiceString, nil
}

// ResetInvoiceString resets all changes to the "invoice_string" field.
func (m *PreimageShareMutation) ResetInvoiceString() {
	m.invoice_string = nil
}

// SetPreimageRequestID sets the "preimage_request" edge to the PreimageRequest entity by id.
func (m *PreimageShareMutation) SetPreimageRequestID(id uuid.UUID) {
	m.preimage_request = &id
}

// ClearPreimageRequest clears the "preimage_request" edge to the PreimageRequest entity.
func (m *PreimageShareMutation) ClearPreimageRequest() {
	m.clearedpreimage_request = true
}

// PreimageRequestCleared reports if the "preimage_request" edge to the PreimageRequest entity was cleared.
func (m *PreimageShareMutation) PreimageRequestCleared() bool {
	return m.clearedpreimage_request
}

// PreimageRequestID returns the "preimage_request" edge ID in the mutation.
func (m *PreimageShareMutation) PreimageRequestID() (id uuid.UUID, exists bool) {
	if m.preimage_request != nil {
		return *m.preimage_request, true
	}
	return
}

// PreimageRequestIDs returns the "preimage_request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PreimageRequestID instead. It exists only for internal usage by the builders.
func (m *PreimageShareMutation) PreimageRequestIDs() (ids []uuid.UUID) {
	if id := m.preimage_request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPreimageRequest resets all changes to the "preimage_request" edge.
func (m *PreimageShareMutation) ResetPreimageRequest() {
	m.preimage_request = nil
	m.clearedpreimage_request = false
}

// Where appends a list predicates to the PreimageShareMutation builder.
func (m *PreimageShareMutation) Where(ps ...predicate.PreimageShare) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PreimageShareMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PreimageShareMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PreimageShare, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PreimageShareMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PreimageShareMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PreimageShare).
func (m *PreimageShareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PreimageShareMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, preimageshare.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, preimageshare.FieldUpdateTime)
	}
	if m.payment_hash != nil {
		fields = append(fields, preimageshare.FieldPaymentHash)
	}
	if m.preimage_share != nil {
		fields = append(fields, preimageshare.FieldPreimageShare)
	}
	if m.threshold != nil {
		fields = append(fields, preimageshare.FieldThreshold)
	}
	if m.owner_identity_pubkey != nil {
		fields = append(fields, preimageshare.FieldOwnerIdentityPubkey)
	}
	if m.invoice_string != nil {
		fields = append(fields, preimageshare.FieldInvoiceString)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PreimageShareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case preimageshare.FieldCreateTime:
		return m.CreateTime()
	case preimageshare.FieldUpdateTime:
		return m.UpdateTime()
	case preimageshare.FieldPaymentHash:
		return m.PaymentHash()
	case preimageshare.FieldPreimageShare:
		return m.PreimageShare()
	case preimageshare.FieldThreshold:
		return m.Threshold()
	case preimageshare.FieldOwnerIdentityPubkey:
		return m.OwnerIdentityPubkey()
	case preimageshare.FieldInvoiceString:
		return m.InvoiceString()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PreimageShareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case preimageshare.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case preimageshare.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case preimageshare.FieldPaymentHash:
		return m.OldPaymentHash(ctx)
	case preimageshare.FieldPreimageShare:
		return m.OldPreimageShare(ctx)
	case preimageshare.FieldThreshold:
		return m.OldThreshold(ctx)
	case preimageshare.FieldOwnerIdentityPubkey:
		return m.OldOwnerIdentityPubkey(ctx)
	case preimageshare.FieldInvoiceString:
		return m.OldInvoiceString(ctx)
	}
	return nil, fmt.Errorf("unknown PreimageShare field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PreimageShareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case preimageshare.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case preimageshare.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case preimageshare.FieldPaymentHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentHash(v)
		return nil
	case preimageshare.FieldPreimageShare:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreimageShare(v)
		return nil
	case preimageshare.FieldThreshold:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThreshold(v)
		return nil
	case preimageshare.FieldOwnerIdentityPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerIdentityPubkey(v)
		return nil
	case preimageshare.FieldInvoiceString:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceString(v)
		return nil
	}
	return fmt.Errorf("unknown PreimageShare field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PreimageShareMutation) AddedFields() []string {
	var fields []string
	if m.addthreshold != nil {
		fields = append(fields, preimageshare.FieldThreshold)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PreimageShareMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case preimageshare.FieldThreshold:
		return m.AddedThreshold()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PreimageShareMutation) AddField(name string, value ent.Value) error {
	switch name {
	case preimageshare.FieldThreshold:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddThreshold(v)
		return nil
	}
	return fmt.Errorf("unknown PreimageShare numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PreimageShareMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PreimageShareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PreimageShareMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PreimageShare nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PreimageShareMutation) ResetField(name string) error {
	switch name {
	case preimageshare.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case preimageshare.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case preimageshare.FieldPaymentHash:
		m.ResetPaymentHash()
		return nil
	case preimageshare.FieldPreimageShare:
		m.ResetPreimageShare()
		return nil
	case preimageshare.FieldThreshold:
		m.ResetThreshold()
		return nil
	case preimageshare.FieldOwnerIdentityPubkey:
		m.ResetOwnerIdentityPubkey()
		return nil
	case preimageshare.FieldInvoiceString:
		m.ResetInvoiceString()
		return nil
	}
	return fmt.Errorf("unknown PreimageShare field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PreimageShareMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.preimage_request != nil {
		edges = append(edges, preimageshare.EdgePreimageRequest)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PreimageShareMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case preimageshare.EdgePreimageRequest:
		if id := m.preimage_request; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PreimageShareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PreimageShareMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PreimageShareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpreimage_request {
		edges = append(edges, preimageshare.EdgePreimageRequest)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PreimageShareMutation) EdgeCleared(name string) bool {
	switch name {
	case preimageshare.EdgePreimageRequest:
		return m.clearedpreimage_request
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PreimageShareMutation) ClearEdge(name string) error {
	switch name {
	case preimageshare.EdgePreimageRequest:
		m.ClearPreimageRequest()
		return nil
	}
	return fmt.Errorf("unknown PreimageShare unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PreimageShareMutation) ResetEdge(name string) error {
	switch name {
	case preimageshare.EdgePreimageRequest:
		m.ResetPreimageRequest()
		return nil
	}
	return fmt.Errorf("unknown PreimageShare edge %s", name)
}

// SigningKeyshareMutation represents an operation that mutates the SigningKeyshare nodes in the graph.
type SigningKeyshareMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	create_time          *time.Time
	update_time          *time.Time
	status               *schema.SigningKeyshareStatus
	secret_share         *[]byte
	public_shares        *map[string][]uint8
	public_key           *[]byte
	min_signers          *uint32
	addmin_signers       *int32
	coordinator_index    *uint64
	addcoordinator_index *int64
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*SigningKeyshare, error)
	predicates           []predicate.SigningKeyshare
}

var _ ent.Mutation = (*SigningKeyshareMutation)(nil)

// signingkeyshareOption allows management of the mutation configuration using functional options.
type signingkeyshareOption func(*SigningKeyshareMutation)

// newSigningKeyshareMutation creates new mutation for the SigningKeyshare entity.
func newSigningKeyshareMutation(c config, op Op, opts ...signingkeyshareOption) *SigningKeyshareMutation {
	m := &SigningKeyshareMutation{
		config:        c,
		op:            op,
		typ:           TypeSigningKeyshare,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSigningKeyshareID sets the ID field of the mutation.
func withSigningKeyshareID(id uuid.UUID) signingkeyshareOption {
	return func(m *SigningKeyshareMutation) {
		var (
			err   error
			once  sync.Once
			value *SigningKeyshare
		)
		m.oldValue = func(ctx context.Context) (*SigningKeyshare, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SigningKeyshare.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSigningKeyshare sets the old SigningKeyshare of the mutation.
func withSigningKeyshare(node *SigningKeyshare) signingkeyshareOption {
	return func(m *SigningKeyshareMutation) {
		m.oldValue = func(context.Context) (*SigningKeyshare, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SigningKeyshareMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SigningKeyshareMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SigningKeyshare entities.
func (m *SigningKeyshareMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SigningKeyshareMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SigningKeyshareMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SigningKeyshare.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SigningKeyshareMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SigningKeyshareMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SigningKeyshareMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SigningKeyshareMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SigningKeyshareMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SigningKeyshareMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *SigningKeyshareMutation) SetStatus(sks schema.SigningKeyshareStatus) {
	m.status = &sks
}

// Status returns the value of the "status" field in the mutation.
func (m *SigningKeyshareMutation) Status() (r schema.SigningKeyshareStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldStatus(ctx context.Context) (v schema.SigningKeyshareStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SigningKeyshareMutation) ResetStatus() {
	m.status = nil
}

// SetSecretShare sets the "secret_share" field.
func (m *SigningKeyshareMutation) SetSecretShare(b []byte) {
	m.secret_share = &b
}

// SecretShare returns the value of the "secret_share" field in the mutation.
func (m *SigningKeyshareMutation) SecretShare() (r []byte, exists bool) {
	v := m.secret_share
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretShare returns the old "secret_share" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldSecretShare(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretShare is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretShare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretShare: %w", err)
	}
	return oldValue.SecretShare, nil
}

// ResetSecretShare resets all changes to the "secret_share" field.
func (m *SigningKeyshareMutation) ResetSecretShare() {
	m.secret_share = nil
}

// SetPublicShares sets the "public_shares" field.
func (m *SigningKeyshareMutation) SetPublicShares(value map[string][]uint8) {
	m.public_shares = &value
}

// PublicShares returns the value of the "public_shares" field in the mutation.
func (m *SigningKeyshareMutation) PublicShares() (r map[string][]uint8, exists bool) {
	v := m.public_shares
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicShares returns the old "public_shares" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldPublicShares(ctx context.Context) (v map[string][]uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicShares is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicShares requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicShares: %w", err)
	}
	return oldValue.PublicShares, nil
}

// ResetPublicShares resets all changes to the "public_shares" field.
func (m *SigningKeyshareMutation) ResetPublicShares() {
	m.public_shares = nil
}

// SetPublicKey sets the "public_key" field.
func (m *SigningKeyshareMutation) SetPublicKey(b []byte) {
	m.public_key = &b
}

// PublicKey returns the value of the "public_key" field in the mutation.
func (m *SigningKeyshareMutation) PublicKey() (r []byte, exists bool) {
	v := m.public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "public_key" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ResetPublicKey resets all changes to the "public_key" field.
func (m *SigningKeyshareMutation) ResetPublicKey() {
	m.public_key = nil
}

// SetMinSigners sets the "min_signers" field.
func (m *SigningKeyshareMutation) SetMinSigners(u uint32) {
	m.min_signers = &u
	m.addmin_signers = nil
}

// MinSigners returns the value of the "min_signers" field in the mutation.
func (m *SigningKeyshareMutation) MinSigners() (r uint32, exists bool) {
	v := m.min_signers
	if v == nil {
		return
	}
	return *v, true
}

// OldMinSigners returns the old "min_signers" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldMinSigners(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinSigners is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinSigners requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinSigners: %w", err)
	}
	return oldValue.MinSigners, nil
}

// AddMinSigners adds u to the "min_signers" field.
func (m *SigningKeyshareMutation) AddMinSigners(u int32) {
	if m.addmin_signers != nil {
		*m.addmin_signers += u
	} else {
		m.addmin_signers = &u
	}
}

// AddedMinSigners returns the value that was added to the "min_signers" field in this mutation.
func (m *SigningKeyshareMutation) AddedMinSigners() (r int32, exists bool) {
	v := m.addmin_signers
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinSigners resets all changes to the "min_signers" field.
func (m *SigningKeyshareMutation) ResetMinSigners() {
	m.min_signers = nil
	m.addmin_signers = nil
}

// SetCoordinatorIndex sets the "coordinator_index" field.
func (m *SigningKeyshareMutation) SetCoordinatorIndex(u uint64) {
	m.coordinator_index = &u
	m.addcoordinator_index = nil
}

// CoordinatorIndex returns the value of the "coordinator_index" field in the mutation.
func (m *SigningKeyshareMutation) CoordinatorIndex() (r uint64, exists bool) {
	v := m.coordinator_index
	if v == nil {
		return
	}
	return *v, true
}

// OldCoordinatorIndex returns the old "coordinator_index" field's value of the SigningKeyshare entity.
// If the SigningKeyshare object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningKeyshareMutation) OldCoordinatorIndex(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoordinatorIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoordinatorIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoordinatorIndex: %w", err)
	}
	return oldValue.CoordinatorIndex, nil
}

// AddCoordinatorIndex adds u to the "coordinator_index" field.
func (m *SigningKeyshareMutation) AddCoordinatorIndex(u int64) {
	if m.addcoordinator_index != nil {
		*m.addcoordinator_index += u
	} else {
		m.addcoordinator_index = &u
	}
}

// AddedCoordinatorIndex returns the value that was added to the "coordinator_index" field in this mutation.
func (m *SigningKeyshareMutation) AddedCoordinatorIndex() (r int64, exists bool) {
	v := m.addcoordinator_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoordinatorIndex resets all changes to the "coordinator_index" field.
func (m *SigningKeyshareMutation) ResetCoordinatorIndex() {
	m.coordinator_index = nil
	m.addcoordinator_index = nil
}

// Where appends a list predicates to the SigningKeyshareMutation builder.
func (m *SigningKeyshareMutation) Where(ps ...predicate.SigningKeyshare) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SigningKeyshareMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SigningKeyshareMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SigningKeyshare, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SigningKeyshareMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SigningKeyshareMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SigningKeyshare).
func (m *SigningKeyshareMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SigningKeyshareMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, signingkeyshare.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, signingkeyshare.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, signingkeyshare.FieldStatus)
	}
	if m.secret_share != nil {
		fields = append(fields, signingkeyshare.FieldSecretShare)
	}
	if m.public_shares != nil {
		fields = append(fields, signingkeyshare.FieldPublicShares)
	}
	if m.public_key != nil {
		fields = append(fields, signingkeyshare.FieldPublicKey)
	}
	if m.min_signers != nil {
		fields = append(fields, signingkeyshare.FieldMinSigners)
	}
	if m.coordinator_index != nil {
		fields = append(fields, signingkeyshare.FieldCoordinatorIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SigningKeyshareMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signingkeyshare.FieldCreateTime:
		return m.CreateTime()
	case signingkeyshare.FieldUpdateTime:
		return m.UpdateTime()
	case signingkeyshare.FieldStatus:
		return m.Status()
	case signingkeyshare.FieldSecretShare:
		return m.SecretShare()
	case signingkeyshare.FieldPublicShares:
		return m.PublicShares()
	case signingkeyshare.FieldPublicKey:
		return m.PublicKey()
	case signingkeyshare.FieldMinSigners:
		return m.MinSigners()
	case signingkeyshare.FieldCoordinatorIndex:
		return m.CoordinatorIndex()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SigningKeyshareMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signingkeyshare.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case signingkeyshare.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case signingkeyshare.FieldStatus:
		return m.OldStatus(ctx)
	case signingkeyshare.FieldSecretShare:
		return m.OldSecretShare(ctx)
	case signingkeyshare.FieldPublicShares:
		return m.OldPublicShares(ctx)
	case signingkeyshare.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case signingkeyshare.FieldMinSigners:
		return m.OldMinSigners(ctx)
	case signingkeyshare.FieldCoordinatorIndex:
		return m.OldCoordinatorIndex(ctx)
	}
	return nil, fmt.Errorf("unknown SigningKeyshare field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningKeyshareMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signingkeyshare.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case signingkeyshare.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case signingkeyshare.FieldStatus:
		v, ok := value.(schema.SigningKeyshareStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case signingkeyshare.FieldSecretShare:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretShare(v)
		return nil
	case signingkeyshare.FieldPublicShares:
		v, ok := value.(map[string][]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicShares(v)
		return nil
	case signingkeyshare.FieldPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case signingkeyshare.FieldMinSigners:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinSigners(v)
		return nil
	case signingkeyshare.FieldCoordinatorIndex:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoordinatorIndex(v)
		return nil
	}
	return fmt.Errorf("unknown SigningKeyshare field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SigningKeyshareMutation) AddedFields() []string {
	var fields []string
	if m.addmin_signers != nil {
		fields = append(fields, signingkeyshare.FieldMinSigners)
	}
	if m.addcoordinator_index != nil {
		fields = append(fields, signingkeyshare.FieldCoordinatorIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SigningKeyshareMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case signingkeyshare.FieldMinSigners:
		return m.AddedMinSigners()
	case signingkeyshare.FieldCoordinatorIndex:
		return m.AddedCoordinatorIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningKeyshareMutation) AddField(name string, value ent.Value) error {
	switch name {
	case signingkeyshare.FieldMinSigners:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinSigners(v)
		return nil
	case signingkeyshare.FieldCoordinatorIndex:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoordinatorIndex(v)
		return nil
	}
	return fmt.Errorf("unknown SigningKeyshare numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SigningKeyshareMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SigningKeyshareMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SigningKeyshareMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SigningKeyshare nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SigningKeyshareMutation) ResetField(name string) error {
	switch name {
	case signingkeyshare.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case signingkeyshare.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case signingkeyshare.FieldStatus:
		m.ResetStatus()
		return nil
	case signingkeyshare.FieldSecretShare:
		m.ResetSecretShare()
		return nil
	case signingkeyshare.FieldPublicShares:
		m.ResetPublicShares()
		return nil
	case signingkeyshare.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case signingkeyshare.FieldMinSigners:
		m.ResetMinSigners()
		return nil
	case signingkeyshare.FieldCoordinatorIndex:
		m.ResetCoordinatorIndex()
		return nil
	}
	return fmt.Errorf("unknown SigningKeyshare field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SigningKeyshareMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SigningKeyshareMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SigningKeyshareMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SigningKeyshareMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SigningKeyshareMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SigningKeyshareMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SigningKeyshareMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SigningKeyshare unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SigningKeyshareMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SigningKeyshare edge %s", name)
}

// SigningNonceMutation represents an operation that mutates the SigningNonce nodes in the graph.
type SigningNonceMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	create_time      *time.Time
	update_time      *time.Time
	nonce            *[]byte
	nonce_commitment *[]byte
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*SigningNonce, error)
	predicates       []predicate.SigningNonce
}

var _ ent.Mutation = (*SigningNonceMutation)(nil)

// signingnonceOption allows management of the mutation configuration using functional options.
type signingnonceOption func(*SigningNonceMutation)

// newSigningNonceMutation creates new mutation for the SigningNonce entity.
func newSigningNonceMutation(c config, op Op, opts ...signingnonceOption) *SigningNonceMutation {
	m := &SigningNonceMutation{
		config:        c,
		op:            op,
		typ:           TypeSigningNonce,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSigningNonceID sets the ID field of the mutation.
func withSigningNonceID(id uuid.UUID) signingnonceOption {
	return func(m *SigningNonceMutation) {
		var (
			err   error
			once  sync.Once
			value *SigningNonce
		)
		m.oldValue = func(ctx context.Context) (*SigningNonce, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SigningNonce.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSigningNonce sets the old SigningNonce of the mutation.
func withSigningNonce(node *SigningNonce) signingnonceOption {
	return func(m *SigningNonceMutation) {
		m.oldValue = func(context.Context) (*SigningNonce, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SigningNonceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SigningNonceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SigningNonce entities.
func (m *SigningNonceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SigningNonceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SigningNonceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SigningNonce.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SigningNonceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SigningNonceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SigningNonce entity.
// If the SigningNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningNonceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SigningNonceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SigningNonceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SigningNonceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SigningNonce entity.
// If the SigningNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningNonceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SigningNonceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetNonce sets the "nonce" field.
func (m *SigningNonceMutation) SetNonce(b []byte) {
	m.nonce = &b
}

// Nonce returns the value of the "nonce" field in the mutation.
func (m *SigningNonceMutation) Nonce() (r []byte, exists bool) {
	v := m.nonce
	if v == nil {
		return
	}
	return *v, true
}

// OldNonce returns the old "nonce" field's value of the SigningNonce entity.
// If the SigningNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningNonceMutation) OldNonce(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonce: %w", err)
	}
	return oldValue.Nonce, nil
}

// ResetNonce resets all changes to the "nonce" field.
func (m *SigningNonceMutation) ResetNonce() {
	m.nonce = nil
}

// SetNonceCommitment sets the "nonce_commitment" field.
func (m *SigningNonceMutation) SetNonceCommitment(b []byte) {
	m.nonce_commitment = &b
}

// NonceCommitment returns the value of the "nonce_commitment" field in the mutation.
func (m *SigningNonceMutation) NonceCommitment() (r []byte, exists bool) {
	v := m.nonce_commitment
	if v == nil {
		return
	}
	return *v, true
}

// OldNonceCommitment returns the old "nonce_commitment" field's value of the SigningNonce entity.
// If the SigningNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SigningNonceMutation) OldNonceCommitment(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNonceCommitment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNonceCommitment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNonceCommitment: %w", err)
	}
	return oldValue.NonceCommitment, nil
}

// ResetNonceCommitment resets all changes to the "nonce_commitment" field.
func (m *SigningNonceMutation) ResetNonceCommitment() {
	m.nonce_commitment = nil
}

// Where appends a list predicates to the SigningNonceMutation builder.
func (m *SigningNonceMutation) Where(ps ...predicate.SigningNonce) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SigningNonceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SigningNonceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SigningNonce, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SigningNonceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SigningNonceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SigningNonce).
func (m *SigningNonceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SigningNonceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, signingnonce.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, signingnonce.FieldUpdateTime)
	}
	if m.nonce != nil {
		fields = append(fields, signingnonce.FieldNonce)
	}
	if m.nonce_commitment != nil {
		fields = append(fields, signingnonce.FieldNonceCommitment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SigningNonceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signingnonce.FieldCreateTime:
		return m.CreateTime()
	case signingnonce.FieldUpdateTime:
		return m.UpdateTime()
	case signingnonce.FieldNonce:
		return m.Nonce()
	case signingnonce.FieldNonceCommitment:
		return m.NonceCommitment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SigningNonceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signingnonce.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case signingnonce.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case signingnonce.FieldNonce:
		return m.OldNonce(ctx)
	case signingnonce.FieldNonceCommitment:
		return m.OldNonceCommitment(ctx)
	}
	return nil, fmt.Errorf("unknown SigningNonce field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningNonceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signingnonce.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case signingnonce.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case signingnonce.FieldNonce:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonce(v)
		return nil
	case signingnonce.FieldNonceCommitment:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNonceCommitment(v)
		return nil
	}
	return fmt.Errorf("unknown SigningNonce field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SigningNonceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SigningNonceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SigningNonceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SigningNonce numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SigningNonceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SigningNonceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SigningNonceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SigningNonce nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SigningNonceMutation) ResetField(name string) error {
	switch name {
	case signingnonce.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case signingnonce.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case signingnonce.FieldNonce:
		m.ResetNonce()
		return nil
	case signingnonce.FieldNonceCommitment:
		m.ResetNonceCommitment()
		return nil
	}
	return fmt.Errorf("unknown SigningNonce field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SigningNonceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SigningNonceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SigningNonceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SigningNonceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SigningNonceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SigningNonceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SigningNonceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SigningNonce unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SigningNonceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SigningNonce edge %s", name)
}

// TokenIssuanceMutation represents an operation that mutates the TokenIssuance nodes in the graph.
type TokenIssuanceMutation struct {
	config
	op                               Op
	typ                              string
	id                               *uuid.UUID
	create_time                      *time.Time
	update_time                      *time.Time
	issuer_public_key                *[]byte
	issuer_signature                 *[]byte
	clearedFields                    map[string]struct{}
	token_transaction_receipt        map[uuid.UUID]struct{}
	removedtoken_transaction_receipt map[uuid.UUID]struct{}
	clearedtoken_transaction_receipt bool
	done                             bool
	oldValue                         func(context.Context) (*TokenIssuance, error)
	predicates                       []predicate.TokenIssuance
}

var _ ent.Mutation = (*TokenIssuanceMutation)(nil)

// tokenissuanceOption allows management of the mutation configuration using functional options.
type tokenissuanceOption func(*TokenIssuanceMutation)

// newTokenIssuanceMutation creates new mutation for the TokenIssuance entity.
func newTokenIssuanceMutation(c config, op Op, opts ...tokenissuanceOption) *TokenIssuanceMutation {
	m := &TokenIssuanceMutation{
		config:        c,
		op:            op,
		typ:           TypeTokenIssuance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenIssuanceID sets the ID field of the mutation.
func withTokenIssuanceID(id uuid.UUID) tokenissuanceOption {
	return func(m *TokenIssuanceMutation) {
		var (
			err   error
			once  sync.Once
			value *TokenIssuance
		)
		m.oldValue = func(ctx context.Context) (*TokenIssuance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TokenIssuance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTokenIssuance sets the old TokenIssuance of the mutation.
func withTokenIssuance(node *TokenIssuance) tokenissuanceOption {
	return func(m *TokenIssuanceMutation) {
		m.oldValue = func(context.Context) (*TokenIssuance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenIssuanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenIssuanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TokenIssuance entities.
func (m *TokenIssuanceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenIssuanceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenIssuanceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TokenIssuance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TokenIssuanceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TokenIssuanceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TokenIssuance entity.
// If the TokenIssuance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenIssuanceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TokenIssuanceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TokenIssuanceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TokenIssuanceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TokenIssuance entity.
// If the TokenIssuance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenIssuanceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TokenIssuanceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetIssuerPublicKey sets the "issuer_public_key" field.
func (m *TokenIssuanceMutation) SetIssuerPublicKey(b []byte) {
	m.issuer_public_key = &b
}

// IssuerPublicKey returns the value of the "issuer_public_key" field in the mutation.
func (m *TokenIssuanceMutation) IssuerPublicKey() (r []byte, exists bool) {
	v := m.issuer_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerPublicKey returns the old "issuer_public_key" field's value of the TokenIssuance entity.
// If the TokenIssuance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenIssuanceMutation) OldIssuerPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerPublicKey: %w", err)
	}
	return oldValue.IssuerPublicKey, nil
}

// ResetIssuerPublicKey resets all changes to the "issuer_public_key" field.
func (m *TokenIssuanceMutation) ResetIssuerPublicKey() {
	m.issuer_public_key = nil
}

// SetIssuerSignature sets the "issuer_signature" field.
func (m *TokenIssuanceMutation) SetIssuerSignature(b []byte) {
	m.issuer_signature = &b
}

// IssuerSignature returns the value of the "issuer_signature" field in the mutation.
func (m *TokenIssuanceMutation) IssuerSignature() (r []byte, exists bool) {
	v := m.issuer_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldIssuerSignature returns the old "issuer_signature" field's value of the TokenIssuance entity.
// If the TokenIssuance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenIssuanceMutation) OldIssuerSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIssuerSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIssuerSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIssuerSignature: %w", err)
	}
	return oldValue.IssuerSignature, nil
}

// ResetIssuerSignature resets all changes to the "issuer_signature" field.
func (m *TokenIssuanceMutation) ResetIssuerSignature() {
	m.issuer_signature = nil
}

// AddTokenTransactionReceiptIDs adds the "token_transaction_receipt" edge to the TokenTransactionReceipt entity by ids.
func (m *TokenIssuanceMutation) AddTokenTransactionReceiptIDs(ids ...uuid.UUID) {
	if m.token_transaction_receipt == nil {
		m.token_transaction_receipt = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.token_transaction_receipt[ids[i]] = struct{}{}
	}
}

// ClearTokenTransactionReceipt clears the "token_transaction_receipt" edge to the TokenTransactionReceipt entity.
func (m *TokenIssuanceMutation) ClearTokenTransactionReceipt() {
	m.clearedtoken_transaction_receipt = true
}

// TokenTransactionReceiptCleared reports if the "token_transaction_receipt" edge to the TokenTransactionReceipt entity was cleared.
func (m *TokenIssuanceMutation) TokenTransactionReceiptCleared() bool {
	return m.clearedtoken_transaction_receipt
}

// RemoveTokenTransactionReceiptIDs removes the "token_transaction_receipt" edge to the TokenTransactionReceipt entity by IDs.
func (m *TokenIssuanceMutation) RemoveTokenTransactionReceiptIDs(ids ...uuid.UUID) {
	if m.removedtoken_transaction_receipt == nil {
		m.removedtoken_transaction_receipt = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.token_transaction_receipt, ids[i])
		m.removedtoken_transaction_receipt[ids[i]] = struct{}{}
	}
}

// RemovedTokenTransactionReceipt returns the removed IDs of the "token_transaction_receipt" edge to the TokenTransactionReceipt entity.
func (m *TokenIssuanceMutation) RemovedTokenTransactionReceiptIDs() (ids []uuid.UUID) {
	for id := range m.removedtoken_transaction_receipt {
		ids = append(ids, id)
	}
	return
}

// TokenTransactionReceiptIDs returns the "token_transaction_receipt" edge IDs in the mutation.
func (m *TokenIssuanceMutation) TokenTransactionReceiptIDs() (ids []uuid.UUID) {
	for id := range m.token_transaction_receipt {
		ids = append(ids, id)
	}
	return
}

// ResetTokenTransactionReceipt resets all changes to the "token_transaction_receipt" edge.
func (m *TokenIssuanceMutation) ResetTokenTransactionReceipt() {
	m.token_transaction_receipt = nil
	m.clearedtoken_transaction_receipt = false
	m.removedtoken_transaction_receipt = nil
}

// Where appends a list predicates to the TokenIssuanceMutation builder.
func (m *TokenIssuanceMutation) Where(ps ...predicate.TokenIssuance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenIssuanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenIssuanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TokenIssuance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenIssuanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenIssuanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TokenIssuance).
func (m *TokenIssuanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenIssuanceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, tokenissuance.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tokenissuance.FieldUpdateTime)
	}
	if m.issuer_public_key != nil {
		fields = append(fields, tokenissuance.FieldIssuerPublicKey)
	}
	if m.issuer_signature != nil {
		fields = append(fields, tokenissuance.FieldIssuerSignature)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenIssuanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tokenissuance.FieldCreateTime:
		return m.CreateTime()
	case tokenissuance.FieldUpdateTime:
		return m.UpdateTime()
	case tokenissuance.FieldIssuerPublicKey:
		return m.IssuerPublicKey()
	case tokenissuance.FieldIssuerSignature:
		return m.IssuerSignature()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenIssuanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tokenissuance.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tokenissuance.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tokenissuance.FieldIssuerPublicKey:
		return m.OldIssuerPublicKey(ctx)
	case tokenissuance.FieldIssuerSignature:
		return m.OldIssuerSignature(ctx)
	}
	return nil, fmt.Errorf("unknown TokenIssuance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenIssuanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tokenissuance.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tokenissuance.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tokenissuance.FieldIssuerPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerPublicKey(v)
		return nil
	case tokenissuance.FieldIssuerSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIssuerSignature(v)
		return nil
	}
	return fmt.Errorf("unknown TokenIssuance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenIssuanceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenIssuanceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenIssuanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TokenIssuance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenIssuanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenIssuanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenIssuanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TokenIssuance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenIssuanceMutation) ResetField(name string) error {
	switch name {
	case tokenissuance.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tokenissuance.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tokenissuance.FieldIssuerPublicKey:
		m.ResetIssuerPublicKey()
		return nil
	case tokenissuance.FieldIssuerSignature:
		m.ResetIssuerSignature()
		return nil
	}
	return fmt.Errorf("unknown TokenIssuance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenIssuanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.token_transaction_receipt != nil {
		edges = append(edges, tokenissuance.EdgeTokenTransactionReceipt)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenIssuanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tokenissuance.EdgeTokenTransactionReceipt:
		ids := make([]ent.Value, 0, len(m.token_transaction_receipt))
		for id := range m.token_transaction_receipt {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenIssuanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtoken_transaction_receipt != nil {
		edges = append(edges, tokenissuance.EdgeTokenTransactionReceipt)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenIssuanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tokenissuance.EdgeTokenTransactionReceipt:
		ids := make([]ent.Value, 0, len(m.removedtoken_transaction_receipt))
		for id := range m.removedtoken_transaction_receipt {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenIssuanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtoken_transaction_receipt {
		edges = append(edges, tokenissuance.EdgeTokenTransactionReceipt)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenIssuanceMutation) EdgeCleared(name string) bool {
	switch name {
	case tokenissuance.EdgeTokenTransactionReceipt:
		return m.clearedtoken_transaction_receipt
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenIssuanceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TokenIssuance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenIssuanceMutation) ResetEdge(name string) error {
	switch name {
	case tokenissuance.EdgeTokenTransactionReceipt:
		m.ResetTokenTransactionReceipt()
		return nil
	}
	return fmt.Errorf("unknown TokenIssuance edge %s", name)
}

// TokenLeafMutation represents an operation that mutates the TokenLeaf nodes in the graph.
type TokenLeafMutation struct {
	config
	op                                            Op
	typ                                           string
	id                                            *uuid.UUID
	create_time                                   *time.Time
	update_time                                   *time.Time
	status                                        *schema.TokenLeafStatus
	owner_public_key                              *[]byte
	withdrawal_bond_sats                          *uint64
	addwithdrawal_bond_sats                       *int64
	withdrawal_locktime                           *uint64
	addwithdrawal_locktime                        *int64
	withdrawal_revocation_public_key              *[]byte
	token_public_key                              *[]byte
	token_amount                                  *[]byte
	leaf_created_transaction_ouput_vout           *uint32
	addleaf_created_transaction_ouput_vout        *int32
	leaf_spent_ownership_signature                *[]byte
	leaf_spent_transaction_input_vout             *uint32
	addleaf_spent_transaction_input_vout          *int32
	leaf_spent_revocation_private_key             *[]byte
	clearedFields                                 map[string]struct{}
	revocation_keyshare                           *uuid.UUID
	clearedrevocation_keyshare                    bool
	leaf_created_token_transaction_receipt        *uuid.UUID
	clearedleaf_created_token_transaction_receipt bool
	leaf_spent_token_transaction_receipt          *uuid.UUID
	clearedleaf_spent_token_transaction_receipt   bool
	done                                          bool
	oldValue                                      func(context.Context) (*TokenLeaf, error)
	predicates                                    []predicate.TokenLeaf
}

var _ ent.Mutation = (*TokenLeafMutation)(nil)

// tokenleafOption allows management of the mutation configuration using functional options.
type tokenleafOption func(*TokenLeafMutation)

// newTokenLeafMutation creates new mutation for the TokenLeaf entity.
func newTokenLeafMutation(c config, op Op, opts ...tokenleafOption) *TokenLeafMutation {
	m := &TokenLeafMutation{
		config:        c,
		op:            op,
		typ:           TypeTokenLeaf,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenLeafID sets the ID field of the mutation.
func withTokenLeafID(id uuid.UUID) tokenleafOption {
	return func(m *TokenLeafMutation) {
		var (
			err   error
			once  sync.Once
			value *TokenLeaf
		)
		m.oldValue = func(ctx context.Context) (*TokenLeaf, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TokenLeaf.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTokenLeaf sets the old TokenLeaf of the mutation.
func withTokenLeaf(node *TokenLeaf) tokenleafOption {
	return func(m *TokenLeafMutation) {
		m.oldValue = func(context.Context) (*TokenLeaf, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenLeafMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenLeafMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TokenLeaf entities.
func (m *TokenLeafMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenLeafMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenLeafMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TokenLeaf.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TokenLeafMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TokenLeafMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TokenLeaf entity.
// If the TokenLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenLeafMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TokenLeafMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TokenLeafMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TokenLeafMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TokenLeaf entity.
// If the TokenLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenLeafMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TokenLeafMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *TokenLeafMutation) SetStatus(sls schema.TokenLeafStatus) {
	m.status = &sls
}

// Status returns the value of the "status" field in the mutation.
func (m *TokenLeafMutation) Status() (r schema.TokenLeafStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TokenLeaf entity.
// If the TokenLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenLeafMutation) OldStatus(ctx context.Context) (v schema.TokenLeafStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TokenLeafMutation) ResetStatus() {
	m.status = nil
}

// SetOwnerPublicKey sets the "owner_public_key" field.
func (m *TokenLeafMutation) SetOwnerPublicKey(b []byte) {
	m.owner_public_key = &b
}

// OwnerPublicKey returns the value of the "owner_public_key" field in the mutation.
func (m *TokenLeafMutation) OwnerPublicKey() (r []byte, exists bool) {
	v := m.owner_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerPublicKey returns the old "owner_public_key" field's value of the TokenLeaf entity.
// If the TokenLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenLeafMutation) OldOwnerPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerPublicKey: %w", err)
	}
	return oldValue.OwnerPublicKey, nil
}

// ResetOwnerPublicKey resets all changes to the "owner_public_key" field.
func (m *TokenLeafMutation) ResetOwnerPublicKey() {
	m.owner_public_key = nil
}

// SetWithdrawalBondSats sets the "withdrawal_bond_sats" field.
func (m *TokenLeafMutation) SetWithdrawalBondSats(u uint64) {
	m.withdrawal_bond_sats = &u
	m.addwithdrawal_bond_sats = nil
}

// WithdrawalBondSats returns the value of the "withdrawal_bond_sats" field in the mutation.
func (m *TokenLeafMutation) WithdrawalBondSats() (r uint64, exists bool) {
	v := m.withdrawal_bond_sats
	if v == nil {
		return
	}
	return *v, true
}

// OldWithdrawalBondSats returns the old "withdrawal_bond_sats" field's value of the TokenLeaf entity.
// If the TokenLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenLeafMutation) OldWithdrawalBondSats(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithdrawalBondSats is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithdrawalBondSats requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithdrawalBondSats: %w", err)
	}
	return oldValue.WithdrawalBondSats, nil
}

// AddWithdrawalBondSats adds u to the "withdrawal_bond_sats" field.
func (m *TokenLeafMutation) AddWithdrawalBondSats(u int64) {
	if m.addwithdrawal_bond_sats != nil {
		*m.addwithdrawal_bond_sats += u
	} else {
		m.addwithdrawal_bond_sats = &u
	}
}

// AddedWithdrawalBondSats returns the value that was added to the "withdrawal_bond_sats" field in this mutation.
func (m *TokenLeafMutation) AddedWithdrawalBondSats() (r int64, exists bool) {
	v := m.addwithdrawal_bond_sats
	if v == nil {
		return
	}
	return *v, true
}

// ResetWithdrawalBondSats resets all changes to the "withdrawal_bond_sats" field.
func (m *TokenLeafMutation) ResetWithdrawalBondSats() {
	m.withdrawal_bond_sats = nil
	m.addwithdrawal_bond_sats = nil
}

// SetWithdrawalLocktime sets the "withdrawal_locktime" field.
func (m *TokenLeafMutation) SetWithdrawalLocktime(u uint64) {
	m.withdrawal_locktime = &u
	m.addwithdrawal_locktime = nil
}

// WithdrawalLocktime returns the value of the "withdrawal_locktime" field in the mutation.
func (m *TokenLeafMutation) WithdrawalLocktime() (r uint64, exists bool) {
	v := m.withdrawal_locktime
	if v == nil {
		return
	}
	return *v, true
}

// OldWithdrawalLocktime returns the old "withdrawal_locktime" field's value of the TokenLeaf entity.
// If the TokenLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenLeafMutation) OldWithdrawalLocktime(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithdrawalLocktime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithdrawalLocktime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithdrawalLocktime: %w", err)
	}
	return oldValue.WithdrawalLocktime, nil
}

// AddWithdrawalLocktime adds u to the "withdrawal_locktime" field.
func (m *TokenLeafMutation) AddWithdrawalLocktime(u int64) {
	if m.addwithdrawal_locktime != nil {
		*m.addwithdrawal_locktime += u
	} else {
		m.addwithdrawal_locktime = &u
	}
}

// AddedWithdrawalLocktime returns the value that was added to the "withdrawal_locktime" field in this mutation.
func (m *TokenLeafMutation) AddedWithdrawalLocktime() (r int64, exists bool) {
	v := m.addwithdrawal_locktime
	if v == nil {
		return
	}
	return *v, true
}

// ResetWithdrawalLocktime resets all changes to the "withdrawal_locktime" field.
func (m *TokenLeafMutation) ResetWithdrawalLocktime() {
	m.withdrawal_locktime = nil
	m.addwithdrawal_locktime = nil
}

// SetWithdrawalRevocationPublicKey sets the "withdrawal_revocation_public_key" field.
func (m *TokenLeafMutation) SetWithdrawalRevocationPublicKey(b []byte) {
	m.withdrawal_revocation_public_key = &b
}

// WithdrawalRevocationPublicKey returns the value of the "withdrawal_revocation_public_key" field in the mutation.
func (m *TokenLeafMutation) WithdrawalRevocationPublicKey() (r []byte, exists bool) {
	v := m.withdrawal_revocation_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldWithdrawalRevocationPublicKey returns the old "withdrawal_revocation_public_key" field's value of the TokenLeaf entity.
// If the TokenLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenLeafMutation) OldWithdrawalRevocationPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWithdrawalRevocationPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWithdrawalRevocationPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWithdrawalRevocationPublicKey: %w", err)
	}
	return oldValue.WithdrawalRevocationPublicKey, nil
}

// ResetWithdrawalRevocationPublicKey resets all changes to the "withdrawal_revocation_public_key" field.
func (m *TokenLeafMutation) ResetWithdrawalRevocationPublicKey() {
	m.withdrawal_revocation_public_key = nil
}

// SetTokenPublicKey sets the "token_public_key" field.
func (m *TokenLeafMutation) SetTokenPublicKey(b []byte) {
	m.token_public_key = &b
}

// TokenPublicKey returns the value of the "token_public_key" field in the mutation.
func (m *TokenLeafMutation) TokenPublicKey() (r []byte, exists bool) {
	v := m.token_public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenPublicKey returns the old "token_public_key" field's value of the TokenLeaf entity.
// If the TokenLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenLeafMutation) OldTokenPublicKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenPublicKey: %w", err)
	}
	return oldValue.TokenPublicKey, nil
}

// ResetTokenPublicKey resets all changes to the "token_public_key" field.
func (m *TokenLeafMutation) ResetTokenPublicKey() {
	m.token_public_key = nil
}

// SetTokenAmount sets the "token_amount" field.
func (m *TokenLeafMutation) SetTokenAmount(b []byte) {
	m.token_amount = &b
}

// TokenAmount returns the value of the "token_amount" field in the mutation.
func (m *TokenLeafMutation) TokenAmount() (r []byte, exists bool) {
	v := m.token_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenAmount returns the old "token_amount" field's value of the TokenLeaf entity.
// If the TokenLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenLeafMutation) OldTokenAmount(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenAmount: %w", err)
	}
	return oldValue.TokenAmount, nil
}

// ResetTokenAmount resets all changes to the "token_amount" field.
func (m *TokenLeafMutation) ResetTokenAmount() {
	m.token_amount = nil
}

// SetLeafCreatedTransactionOuputVout sets the "leaf_created_transaction_ouput_vout" field.
func (m *TokenLeafMutation) SetLeafCreatedTransactionOuputVout(u uint32) {
	m.leaf_created_transaction_ouput_vout = &u
	m.addleaf_created_transaction_ouput_vout = nil
}

// LeafCreatedTransactionOuputVout returns the value of the "leaf_created_transaction_ouput_vout" field in the mutation.
func (m *TokenLeafMutation) LeafCreatedTransactionOuputVout() (r uint32, exists bool) {
	v := m.leaf_created_transaction_ouput_vout
	if v == nil {
		return
	}
	return *v, true
}

// OldLeafCreatedTransactionOuputVout returns the old "leaf_created_transaction_ouput_vout" field's value of the TokenLeaf entity.
// If the TokenLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenLeafMutation) OldLeafCreatedTransactionOuputVout(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeafCreatedTransactionOuputVout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeafCreatedTransactionOuputVout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeafCreatedTransactionOuputVout: %w", err)
	}
	return oldValue.LeafCreatedTransactionOuputVout, nil
}

// AddLeafCreatedTransactionOuputVout adds u to the "leaf_created_transaction_ouput_vout" field.
func (m *TokenLeafMutation) AddLeafCreatedTransactionOuputVout(u int32) {
	if m.addleaf_created_transaction_ouput_vout != nil {
		*m.addleaf_created_transaction_ouput_vout += u
	} else {
		m.addleaf_created_transaction_ouput_vout = &u
	}
}

// AddedLeafCreatedTransactionOuputVout returns the value that was added to the "leaf_created_transaction_ouput_vout" field in this mutation.
func (m *TokenLeafMutation) AddedLeafCreatedTransactionOuputVout() (r int32, exists bool) {
	v := m.addleaf_created_transaction_ouput_vout
	if v == nil {
		return
	}
	return *v, true
}

// ResetLeafCreatedTransactionOuputVout resets all changes to the "leaf_created_transaction_ouput_vout" field.
func (m *TokenLeafMutation) ResetLeafCreatedTransactionOuputVout() {
	m.leaf_created_transaction_ouput_vout = nil
	m.addleaf_created_transaction_ouput_vout = nil
}

// SetLeafSpentOwnershipSignature sets the "leaf_spent_ownership_signature" field.
func (m *TokenLeafMutation) SetLeafSpentOwnershipSignature(b []byte) {
	m.leaf_spent_ownership_signature = &b
}

// LeafSpentOwnershipSignature returns the value of the "leaf_spent_ownership_signature" field in the mutation.
func (m *TokenLeafMutation) LeafSpentOwnershipSignature() (r []byte, exists bool) {
	v := m.leaf_spent_ownership_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldLeafSpentOwnershipSignature returns the old "leaf_spent_ownership_signature" field's value of the TokenLeaf entity.
// If the TokenLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenLeafMutation) OldLeafSpentOwnershipSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeafSpentOwnershipSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeafSpentOwnershipSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeafSpentOwnershipSignature: %w", err)
	}
	return oldValue.LeafSpentOwnershipSignature, nil
}

// ClearLeafSpentOwnershipSignature clears the value of the "leaf_spent_ownership_signature" field.
func (m *TokenLeafMutation) ClearLeafSpentOwnershipSignature() {
	m.leaf_spent_ownership_signature = nil
	m.clearedFields[tokenleaf.FieldLeafSpentOwnershipSignature] = struct{}{}
}

// LeafSpentOwnershipSignatureCleared returns if the "leaf_spent_ownership_signature" field was cleared in this mutation.
func (m *TokenLeafMutation) LeafSpentOwnershipSignatureCleared() bool {
	_, ok := m.clearedFields[tokenleaf.FieldLeafSpentOwnershipSignature]
	return ok
}

// ResetLeafSpentOwnershipSignature resets all changes to the "leaf_spent_ownership_signature" field.
func (m *TokenLeafMutation) ResetLeafSpentOwnershipSignature() {
	m.leaf_spent_ownership_signature = nil
	delete(m.clearedFields, tokenleaf.FieldLeafSpentOwnershipSignature)
}

// SetLeafSpentTransactionInputVout sets the "leaf_spent_transaction_input_vout" field.
func (m *TokenLeafMutation) SetLeafSpentTransactionInputVout(u uint32) {
	m.leaf_spent_transaction_input_vout = &u
	m.addleaf_spent_transaction_input_vout = nil
}

// LeafSpentTransactionInputVout returns the value of the "leaf_spent_transaction_input_vout" field in the mutation.
func (m *TokenLeafMutation) LeafSpentTransactionInputVout() (r uint32, exists bool) {
	v := m.leaf_spent_transaction_input_vout
	if v == nil {
		return
	}
	return *v, true
}

// OldLeafSpentTransactionInputVout returns the old "leaf_spent_transaction_input_vout" field's value of the TokenLeaf entity.
// If the TokenLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenLeafMutation) OldLeafSpentTransactionInputVout(ctx context.Context) (v uint32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeafSpentTransactionInputVout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeafSpentTransactionInputVout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeafSpentTransactionInputVout: %w", err)
	}
	return oldValue.LeafSpentTransactionInputVout, nil
}

// AddLeafSpentTransactionInputVout adds u to the "leaf_spent_transaction_input_vout" field.
func (m *TokenLeafMutation) AddLeafSpentTransactionInputVout(u int32) {
	if m.addleaf_spent_transaction_input_vout != nil {
		*m.addleaf_spent_transaction_input_vout += u
	} else {
		m.addleaf_spent_transaction_input_vout = &u
	}
}

// AddedLeafSpentTransactionInputVout returns the value that was added to the "leaf_spent_transaction_input_vout" field in this mutation.
func (m *TokenLeafMutation) AddedLeafSpentTransactionInputVout() (r int32, exists bool) {
	v := m.addleaf_spent_transaction_input_vout
	if v == nil {
		return
	}
	return *v, true
}

// ClearLeafSpentTransactionInputVout clears the value of the "leaf_spent_transaction_input_vout" field.
func (m *TokenLeafMutation) ClearLeafSpentTransactionInputVout() {
	m.leaf_spent_transaction_input_vout = nil
	m.addleaf_spent_transaction_input_vout = nil
	m.clearedFields[tokenleaf.FieldLeafSpentTransactionInputVout] = struct{}{}
}

// LeafSpentTransactionInputVoutCleared returns if the "leaf_spent_transaction_input_vout" field was cleared in this mutation.
func (m *TokenLeafMutation) LeafSpentTransactionInputVoutCleared() bool {
	_, ok := m.clearedFields[tokenleaf.FieldLeafSpentTransactionInputVout]
	return ok
}

// ResetLeafSpentTransactionInputVout resets all changes to the "leaf_spent_transaction_input_vout" field.
func (m *TokenLeafMutation) ResetLeafSpentTransactionInputVout() {
	m.leaf_spent_transaction_input_vout = nil
	m.addleaf_spent_transaction_input_vout = nil
	delete(m.clearedFields, tokenleaf.FieldLeafSpentTransactionInputVout)
}

// SetLeafSpentRevocationPrivateKey sets the "leaf_spent_revocation_private_key" field.
func (m *TokenLeafMutation) SetLeafSpentRevocationPrivateKey(b []byte) {
	m.leaf_spent_revocation_private_key = &b
}

// LeafSpentRevocationPrivateKey returns the value of the "leaf_spent_revocation_private_key" field in the mutation.
func (m *TokenLeafMutation) LeafSpentRevocationPrivateKey() (r []byte, exists bool) {
	v := m.leaf_spent_revocation_private_key
	if v == nil {
		return
	}
	return *v, true
}

// OldLeafSpentRevocationPrivateKey returns the old "leaf_spent_revocation_private_key" field's value of the TokenLeaf entity.
// If the TokenLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenLeafMutation) OldLeafSpentRevocationPrivateKey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeafSpentRevocationPrivateKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeafSpentRevocationPrivateKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeafSpentRevocationPrivateKey: %w", err)
	}
	return oldValue.LeafSpentRevocationPrivateKey, nil
}

// ClearLeafSpentRevocationPrivateKey clears the value of the "leaf_spent_revocation_private_key" field.
func (m *TokenLeafMutation) ClearLeafSpentRevocationPrivateKey() {
	m.leaf_spent_revocation_private_key = nil
	m.clearedFields[tokenleaf.FieldLeafSpentRevocationPrivateKey] = struct{}{}
}

// LeafSpentRevocationPrivateKeyCleared returns if the "leaf_spent_revocation_private_key" field was cleared in this mutation.
func (m *TokenLeafMutation) LeafSpentRevocationPrivateKeyCleared() bool {
	_, ok := m.clearedFields[tokenleaf.FieldLeafSpentRevocationPrivateKey]
	return ok
}

// ResetLeafSpentRevocationPrivateKey resets all changes to the "leaf_spent_revocation_private_key" field.
func (m *TokenLeafMutation) ResetLeafSpentRevocationPrivateKey() {
	m.leaf_spent_revocation_private_key = nil
	delete(m.clearedFields, tokenleaf.FieldLeafSpentRevocationPrivateKey)
}

// SetRevocationKeyshareID sets the "revocation_keyshare" edge to the SigningKeyshare entity by id.
func (m *TokenLeafMutation) SetRevocationKeyshareID(id uuid.UUID) {
	m.revocation_keyshare = &id
}

// ClearRevocationKeyshare clears the "revocation_keyshare" edge to the SigningKeyshare entity.
func (m *TokenLeafMutation) ClearRevocationKeyshare() {
	m.clearedrevocation_keyshare = true
}

// RevocationKeyshareCleared reports if the "revocation_keyshare" edge to the SigningKeyshare entity was cleared.
func (m *TokenLeafMutation) RevocationKeyshareCleared() bool {
	return m.clearedrevocation_keyshare
}

// RevocationKeyshareID returns the "revocation_keyshare" edge ID in the mutation.
func (m *TokenLeafMutation) RevocationKeyshareID() (id uuid.UUID, exists bool) {
	if m.revocation_keyshare != nil {
		return *m.revocation_keyshare, true
	}
	return
}

// RevocationKeyshareIDs returns the "revocation_keyshare" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RevocationKeyshareID instead. It exists only for internal usage by the builders.
func (m *TokenLeafMutation) RevocationKeyshareIDs() (ids []uuid.UUID) {
	if id := m.revocation_keyshare; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRevocationKeyshare resets all changes to the "revocation_keyshare" edge.
func (m *TokenLeafMutation) ResetRevocationKeyshare() {
	m.revocation_keyshare = nil
	m.clearedrevocation_keyshare = false
}

// SetLeafCreatedTokenTransactionReceiptID sets the "leaf_created_token_transaction_receipt" edge to the TokenTransactionReceipt entity by id.
func (m *TokenLeafMutation) SetLeafCreatedTokenTransactionReceiptID(id uuid.UUID) {
	m.leaf_created_token_transaction_receipt = &id
}

// ClearLeafCreatedTokenTransactionReceipt clears the "leaf_created_token_transaction_receipt" edge to the TokenTransactionReceipt entity.
func (m *TokenLeafMutation) ClearLeafCreatedTokenTransactionReceipt() {
	m.clearedleaf_created_token_transaction_receipt = true
}

// LeafCreatedTokenTransactionReceiptCleared reports if the "leaf_created_token_transaction_receipt" edge to the TokenTransactionReceipt entity was cleared.
func (m *TokenLeafMutation) LeafCreatedTokenTransactionReceiptCleared() bool {
	return m.clearedleaf_created_token_transaction_receipt
}

// LeafCreatedTokenTransactionReceiptID returns the "leaf_created_token_transaction_receipt" edge ID in the mutation.
func (m *TokenLeafMutation) LeafCreatedTokenTransactionReceiptID() (id uuid.UUID, exists bool) {
	if m.leaf_created_token_transaction_receipt != nil {
		return *m.leaf_created_token_transaction_receipt, true
	}
	return
}

// LeafCreatedTokenTransactionReceiptIDs returns the "leaf_created_token_transaction_receipt" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeafCreatedTokenTransactionReceiptID instead. It exists only for internal usage by the builders.
func (m *TokenLeafMutation) LeafCreatedTokenTransactionReceiptIDs() (ids []uuid.UUID) {
	if id := m.leaf_created_token_transaction_receipt; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeafCreatedTokenTransactionReceipt resets all changes to the "leaf_created_token_transaction_receipt" edge.
func (m *TokenLeafMutation) ResetLeafCreatedTokenTransactionReceipt() {
	m.leaf_created_token_transaction_receipt = nil
	m.clearedleaf_created_token_transaction_receipt = false
}

// SetLeafSpentTokenTransactionReceiptID sets the "leaf_spent_token_transaction_receipt" edge to the TokenTransactionReceipt entity by id.
func (m *TokenLeafMutation) SetLeafSpentTokenTransactionReceiptID(id uuid.UUID) {
	m.leaf_spent_token_transaction_receipt = &id
}

// ClearLeafSpentTokenTransactionReceipt clears the "leaf_spent_token_transaction_receipt" edge to the TokenTransactionReceipt entity.
func (m *TokenLeafMutation) ClearLeafSpentTokenTransactionReceipt() {
	m.clearedleaf_spent_token_transaction_receipt = true
}

// LeafSpentTokenTransactionReceiptCleared reports if the "leaf_spent_token_transaction_receipt" edge to the TokenTransactionReceipt entity was cleared.
func (m *TokenLeafMutation) LeafSpentTokenTransactionReceiptCleared() bool {
	return m.clearedleaf_spent_token_transaction_receipt
}

// LeafSpentTokenTransactionReceiptID returns the "leaf_spent_token_transaction_receipt" edge ID in the mutation.
func (m *TokenLeafMutation) LeafSpentTokenTransactionReceiptID() (id uuid.UUID, exists bool) {
	if m.leaf_spent_token_transaction_receipt != nil {
		return *m.leaf_spent_token_transaction_receipt, true
	}
	return
}

// LeafSpentTokenTransactionReceiptIDs returns the "leaf_spent_token_transaction_receipt" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeafSpentTokenTransactionReceiptID instead. It exists only for internal usage by the builders.
func (m *TokenLeafMutation) LeafSpentTokenTransactionReceiptIDs() (ids []uuid.UUID) {
	if id := m.leaf_spent_token_transaction_receipt; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeafSpentTokenTransactionReceipt resets all changes to the "leaf_spent_token_transaction_receipt" edge.
func (m *TokenLeafMutation) ResetLeafSpentTokenTransactionReceipt() {
	m.leaf_spent_token_transaction_receipt = nil
	m.clearedleaf_spent_token_transaction_receipt = false
}

// Where appends a list predicates to the TokenLeafMutation builder.
func (m *TokenLeafMutation) Where(ps ...predicate.TokenLeaf) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenLeafMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenLeafMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TokenLeaf, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenLeafMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenLeafMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TokenLeaf).
func (m *TokenLeafMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenLeafMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.create_time != nil {
		fields = append(fields, tokenleaf.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tokenleaf.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, tokenleaf.FieldStatus)
	}
	if m.owner_public_key != nil {
		fields = append(fields, tokenleaf.FieldOwnerPublicKey)
	}
	if m.withdrawal_bond_sats != nil {
		fields = append(fields, tokenleaf.FieldWithdrawalBondSats)
	}
	if m.withdrawal_locktime != nil {
		fields = append(fields, tokenleaf.FieldWithdrawalLocktime)
	}
	if m.withdrawal_revocation_public_key != nil {
		fields = append(fields, tokenleaf.FieldWithdrawalRevocationPublicKey)
	}
	if m.token_public_key != nil {
		fields = append(fields, tokenleaf.FieldTokenPublicKey)
	}
	if m.token_amount != nil {
		fields = append(fields, tokenleaf.FieldTokenAmount)
	}
	if m.leaf_created_transaction_ouput_vout != nil {
		fields = append(fields, tokenleaf.FieldLeafCreatedTransactionOuputVout)
	}
	if m.leaf_spent_ownership_signature != nil {
		fields = append(fields, tokenleaf.FieldLeafSpentOwnershipSignature)
	}
	if m.leaf_spent_transaction_input_vout != nil {
		fields = append(fields, tokenleaf.FieldLeafSpentTransactionInputVout)
	}
	if m.leaf_spent_revocation_private_key != nil {
		fields = append(fields, tokenleaf.FieldLeafSpentRevocationPrivateKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenLeafMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tokenleaf.FieldCreateTime:
		return m.CreateTime()
	case tokenleaf.FieldUpdateTime:
		return m.UpdateTime()
	case tokenleaf.FieldStatus:
		return m.Status()
	case tokenleaf.FieldOwnerPublicKey:
		return m.OwnerPublicKey()
	case tokenleaf.FieldWithdrawalBondSats:
		return m.WithdrawalBondSats()
	case tokenleaf.FieldWithdrawalLocktime:
		return m.WithdrawalLocktime()
	case tokenleaf.FieldWithdrawalRevocationPublicKey:
		return m.WithdrawalRevocationPublicKey()
	case tokenleaf.FieldTokenPublicKey:
		return m.TokenPublicKey()
	case tokenleaf.FieldTokenAmount:
		return m.TokenAmount()
	case tokenleaf.FieldLeafCreatedTransactionOuputVout:
		return m.LeafCreatedTransactionOuputVout()
	case tokenleaf.FieldLeafSpentOwnershipSignature:
		return m.LeafSpentOwnershipSignature()
	case tokenleaf.FieldLeafSpentTransactionInputVout:
		return m.LeafSpentTransactionInputVout()
	case tokenleaf.FieldLeafSpentRevocationPrivateKey:
		return m.LeafSpentRevocationPrivateKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenLeafMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tokenleaf.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tokenleaf.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tokenleaf.FieldStatus:
		return m.OldStatus(ctx)
	case tokenleaf.FieldOwnerPublicKey:
		return m.OldOwnerPublicKey(ctx)
	case tokenleaf.FieldWithdrawalBondSats:
		return m.OldWithdrawalBondSats(ctx)
	case tokenleaf.FieldWithdrawalLocktime:
		return m.OldWithdrawalLocktime(ctx)
	case tokenleaf.FieldWithdrawalRevocationPublicKey:
		return m.OldWithdrawalRevocationPublicKey(ctx)
	case tokenleaf.FieldTokenPublicKey:
		return m.OldTokenPublicKey(ctx)
	case tokenleaf.FieldTokenAmount:
		return m.OldTokenAmount(ctx)
	case tokenleaf.FieldLeafCreatedTransactionOuputVout:
		return m.OldLeafCreatedTransactionOuputVout(ctx)
	case tokenleaf.FieldLeafSpentOwnershipSignature:
		return m.OldLeafSpentOwnershipSignature(ctx)
	case tokenleaf.FieldLeafSpentTransactionInputVout:
		return m.OldLeafSpentTransactionInputVout(ctx)
	case tokenleaf.FieldLeafSpentRevocationPrivateKey:
		return m.OldLeafSpentRevocationPrivateKey(ctx)
	}
	return nil, fmt.Errorf("unknown TokenLeaf field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenLeafMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tokenleaf.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tokenleaf.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tokenleaf.FieldStatus:
		v, ok := value.(schema.TokenLeafStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tokenleaf.FieldOwnerPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerPublicKey(v)
		return nil
	case tokenleaf.FieldWithdrawalBondSats:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithdrawalBondSats(v)
		return nil
	case tokenleaf.FieldWithdrawalLocktime:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithdrawalLocktime(v)
		return nil
	case tokenleaf.FieldWithdrawalRevocationPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWithdrawalRevocationPublicKey(v)
		return nil
	case tokenleaf.FieldTokenPublicKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenPublicKey(v)
		return nil
	case tokenleaf.FieldTokenAmount:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenAmount(v)
		return nil
	case tokenleaf.FieldLeafCreatedTransactionOuputVout:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeafCreatedTransactionOuputVout(v)
		return nil
	case tokenleaf.FieldLeafSpentOwnershipSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeafSpentOwnershipSignature(v)
		return nil
	case tokenleaf.FieldLeafSpentTransactionInputVout:
		v, ok := value.(uint32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeafSpentTransactionInputVout(v)
		return nil
	case tokenleaf.FieldLeafSpentRevocationPrivateKey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeafSpentRevocationPrivateKey(v)
		return nil
	}
	return fmt.Errorf("unknown TokenLeaf field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenLeafMutation) AddedFields() []string {
	var fields []string
	if m.addwithdrawal_bond_sats != nil {
		fields = append(fields, tokenleaf.FieldWithdrawalBondSats)
	}
	if m.addwithdrawal_locktime != nil {
		fields = append(fields, tokenleaf.FieldWithdrawalLocktime)
	}
	if m.addleaf_created_transaction_ouput_vout != nil {
		fields = append(fields, tokenleaf.FieldLeafCreatedTransactionOuputVout)
	}
	if m.addleaf_spent_transaction_input_vout != nil {
		fields = append(fields, tokenleaf.FieldLeafSpentTransactionInputVout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenLeafMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tokenleaf.FieldWithdrawalBondSats:
		return m.AddedWithdrawalBondSats()
	case tokenleaf.FieldWithdrawalLocktime:
		return m.AddedWithdrawalLocktime()
	case tokenleaf.FieldLeafCreatedTransactionOuputVout:
		return m.AddedLeafCreatedTransactionOuputVout()
	case tokenleaf.FieldLeafSpentTransactionInputVout:
		return m.AddedLeafSpentTransactionInputVout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenLeafMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tokenleaf.FieldWithdrawalBondSats:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWithdrawalBondSats(v)
		return nil
	case tokenleaf.FieldWithdrawalLocktime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWithdrawalLocktime(v)
		return nil
	case tokenleaf.FieldLeafCreatedTransactionOuputVout:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLeafCreatedTransactionOuputVout(v)
		return nil
	case tokenleaf.FieldLeafSpentTransactionInputVout:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLeafSpentTransactionInputVout(v)
		return nil
	}
	return fmt.Errorf("unknown TokenLeaf numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenLeafMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tokenleaf.FieldLeafSpentOwnershipSignature) {
		fields = append(fields, tokenleaf.FieldLeafSpentOwnershipSignature)
	}
	if m.FieldCleared(tokenleaf.FieldLeafSpentTransactionInputVout) {
		fields = append(fields, tokenleaf.FieldLeafSpentTransactionInputVout)
	}
	if m.FieldCleared(tokenleaf.FieldLeafSpentRevocationPrivateKey) {
		fields = append(fields, tokenleaf.FieldLeafSpentRevocationPrivateKey)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenLeafMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenLeafMutation) ClearField(name string) error {
	switch name {
	case tokenleaf.FieldLeafSpentOwnershipSignature:
		m.ClearLeafSpentOwnershipSignature()
		return nil
	case tokenleaf.FieldLeafSpentTransactionInputVout:
		m.ClearLeafSpentTransactionInputVout()
		return nil
	case tokenleaf.FieldLeafSpentRevocationPrivateKey:
		m.ClearLeafSpentRevocationPrivateKey()
		return nil
	}
	return fmt.Errorf("unknown TokenLeaf nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenLeafMutation) ResetField(name string) error {
	switch name {
	case tokenleaf.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tokenleaf.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tokenleaf.FieldStatus:
		m.ResetStatus()
		return nil
	case tokenleaf.FieldOwnerPublicKey:
		m.ResetOwnerPublicKey()
		return nil
	case tokenleaf.FieldWithdrawalBondSats:
		m.ResetWithdrawalBondSats()
		return nil
	case tokenleaf.FieldWithdrawalLocktime:
		m.ResetWithdrawalLocktime()
		return nil
	case tokenleaf.FieldWithdrawalRevocationPublicKey:
		m.ResetWithdrawalRevocationPublicKey()
		return nil
	case tokenleaf.FieldTokenPublicKey:
		m.ResetTokenPublicKey()
		return nil
	case tokenleaf.FieldTokenAmount:
		m.ResetTokenAmount()
		return nil
	case tokenleaf.FieldLeafCreatedTransactionOuputVout:
		m.ResetLeafCreatedTransactionOuputVout()
		return nil
	case tokenleaf.FieldLeafSpentOwnershipSignature:
		m.ResetLeafSpentOwnershipSignature()
		return nil
	case tokenleaf.FieldLeafSpentTransactionInputVout:
		m.ResetLeafSpentTransactionInputVout()
		return nil
	case tokenleaf.FieldLeafSpentRevocationPrivateKey:
		m.ResetLeafSpentRevocationPrivateKey()
		return nil
	}
	return fmt.Errorf("unknown TokenLeaf field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenLeafMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.revocation_keyshare != nil {
		edges = append(edges, tokenleaf.EdgeRevocationKeyshare)
	}
	if m.leaf_created_token_transaction_receipt != nil {
		edges = append(edges, tokenleaf.EdgeLeafCreatedTokenTransactionReceipt)
	}
	if m.leaf_spent_token_transaction_receipt != nil {
		edges = append(edges, tokenleaf.EdgeLeafSpentTokenTransactionReceipt)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenLeafMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tokenleaf.EdgeRevocationKeyshare:
		if id := m.revocation_keyshare; id != nil {
			return []ent.Value{*id}
		}
	case tokenleaf.EdgeLeafCreatedTokenTransactionReceipt:
		if id := m.leaf_created_token_transaction_receipt; id != nil {
			return []ent.Value{*id}
		}
	case tokenleaf.EdgeLeafSpentTokenTransactionReceipt:
		if id := m.leaf_spent_token_transaction_receipt; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenLeafMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenLeafMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenLeafMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrevocation_keyshare {
		edges = append(edges, tokenleaf.EdgeRevocationKeyshare)
	}
	if m.clearedleaf_created_token_transaction_receipt {
		edges = append(edges, tokenleaf.EdgeLeafCreatedTokenTransactionReceipt)
	}
	if m.clearedleaf_spent_token_transaction_receipt {
		edges = append(edges, tokenleaf.EdgeLeafSpentTokenTransactionReceipt)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenLeafMutation) EdgeCleared(name string) bool {
	switch name {
	case tokenleaf.EdgeRevocationKeyshare:
		return m.clearedrevocation_keyshare
	case tokenleaf.EdgeLeafCreatedTokenTransactionReceipt:
		return m.clearedleaf_created_token_transaction_receipt
	case tokenleaf.EdgeLeafSpentTokenTransactionReceipt:
		return m.clearedleaf_spent_token_transaction_receipt
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenLeafMutation) ClearEdge(name string) error {
	switch name {
	case tokenleaf.EdgeRevocationKeyshare:
		m.ClearRevocationKeyshare()
		return nil
	case tokenleaf.EdgeLeafCreatedTokenTransactionReceipt:
		m.ClearLeafCreatedTokenTransactionReceipt()
		return nil
	case tokenleaf.EdgeLeafSpentTokenTransactionReceipt:
		m.ClearLeafSpentTokenTransactionReceipt()
		return nil
	}
	return fmt.Errorf("unknown TokenLeaf unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenLeafMutation) ResetEdge(name string) error {
	switch name {
	case tokenleaf.EdgeRevocationKeyshare:
		m.ResetRevocationKeyshare()
		return nil
	case tokenleaf.EdgeLeafCreatedTokenTransactionReceipt:
		m.ResetLeafCreatedTokenTransactionReceipt()
		return nil
	case tokenleaf.EdgeLeafSpentTokenTransactionReceipt:
		m.ResetLeafSpentTokenTransactionReceipt()
		return nil
	}
	return fmt.Errorf("unknown TokenLeaf edge %s", name)
}

// TokenTransactionReceiptMutation represents an operation that mutates the TokenTransactionReceipt nodes in the graph.
type TokenTransactionReceiptMutation struct {
	config
	op                               Op
	typ                              string
	id                               *uuid.UUID
	create_time                      *time.Time
	update_time                      *time.Time
	partial_token_transaction_hash   *[]byte
	finalized_token_transaction_hash *[]byte
	clearedFields                    map[string]struct{}
	spent_leaf                       map[uuid.UUID]struct{}
	removedspent_leaf                map[uuid.UUID]struct{}
	clearedspent_leaf                bool
	created_leaf                     map[uuid.UUID]struct{}
	removedcreated_leaf              map[uuid.UUID]struct{}
	clearedcreated_leaf              bool
	issuance                         *uuid.UUID
	clearedissuance                  bool
	done                             bool
	oldValue                         func(context.Context) (*TokenTransactionReceipt, error)
	predicates                       []predicate.TokenTransactionReceipt
}

var _ ent.Mutation = (*TokenTransactionReceiptMutation)(nil)

// tokentransactionreceiptOption allows management of the mutation configuration using functional options.
type tokentransactionreceiptOption func(*TokenTransactionReceiptMutation)

// newTokenTransactionReceiptMutation creates new mutation for the TokenTransactionReceipt entity.
func newTokenTransactionReceiptMutation(c config, op Op, opts ...tokentransactionreceiptOption) *TokenTransactionReceiptMutation {
	m := &TokenTransactionReceiptMutation{
		config:        c,
		op:            op,
		typ:           TypeTokenTransactionReceipt,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenTransactionReceiptID sets the ID field of the mutation.
func withTokenTransactionReceiptID(id uuid.UUID) tokentransactionreceiptOption {
	return func(m *TokenTransactionReceiptMutation) {
		var (
			err   error
			once  sync.Once
			value *TokenTransactionReceipt
		)
		m.oldValue = func(ctx context.Context) (*TokenTransactionReceipt, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TokenTransactionReceipt.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTokenTransactionReceipt sets the old TokenTransactionReceipt of the mutation.
func withTokenTransactionReceipt(node *TokenTransactionReceipt) tokentransactionreceiptOption {
	return func(m *TokenTransactionReceiptMutation) {
		m.oldValue = func(context.Context) (*TokenTransactionReceipt, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenTransactionReceiptMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenTransactionReceiptMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TokenTransactionReceipt entities.
func (m *TokenTransactionReceiptMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenTransactionReceiptMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenTransactionReceiptMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TokenTransactionReceipt.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TokenTransactionReceiptMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TokenTransactionReceiptMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TokenTransactionReceipt entity.
// If the TokenTransactionReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenTransactionReceiptMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TokenTransactionReceiptMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TokenTransactionReceiptMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TokenTransactionReceiptMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TokenTransactionReceipt entity.
// If the TokenTransactionReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenTransactionReceiptMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TokenTransactionReceiptMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetPartialTokenTransactionHash sets the "partial_token_transaction_hash" field.
func (m *TokenTransactionReceiptMutation) SetPartialTokenTransactionHash(b []byte) {
	m.partial_token_transaction_hash = &b
}

// PartialTokenTransactionHash returns the value of the "partial_token_transaction_hash" field in the mutation.
func (m *TokenTransactionReceiptMutation) PartialTokenTransactionHash() (r []byte, exists bool) {
	v := m.partial_token_transaction_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPartialTokenTransactionHash returns the old "partial_token_transaction_hash" field's value of the TokenTransactionReceipt entity.
// If the TokenTransactionReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenTransactionReceiptMutation) OldPartialTokenTransactionHash(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPartialTokenTransactionHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPartialTokenTransactionHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPartialTokenTransactionHash: %w", err)
	}
	return oldValue.PartialTokenTransactionHash, nil
}

// ResetPartialTokenTransactionHash resets all changes to the "partial_token_transaction_hash" field.
func (m *TokenTransactionReceiptMutation) ResetPartialTokenTransactionHash() {
	m.partial_token_transaction_hash = nil
}

// SetFinalizedTokenTransactionHash sets the "finalized_token_transaction_hash" field.
func (m *TokenTransactionReceiptMutation) SetFinalizedTokenTransactionHash(b []byte) {
	m.finalized_token_transaction_hash = &b
}

// FinalizedTokenTransactionHash returns the value of the "finalized_token_transaction_hash" field in the mutation.
func (m *TokenTransactionReceiptMutation) FinalizedTokenTransactionHash() (r []byte, exists bool) {
	v := m.finalized_token_transaction_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldFinalizedTokenTransactionHash returns the old "finalized_token_transaction_hash" field's value of the TokenTransactionReceipt entity.
// If the TokenTransactionReceipt object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenTransactionReceiptMutation) OldFinalizedTokenTransactionHash(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinalizedTokenTransactionHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinalizedTokenTransactionHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinalizedTokenTransactionHash: %w", err)
	}
	return oldValue.FinalizedTokenTransactionHash, nil
}

// ClearFinalizedTokenTransactionHash clears the value of the "finalized_token_transaction_hash" field.
func (m *TokenTransactionReceiptMutation) ClearFinalizedTokenTransactionHash() {
	m.finalized_token_transaction_hash = nil
	m.clearedFields[tokentransactionreceipt.FieldFinalizedTokenTransactionHash] = struct{}{}
}

// FinalizedTokenTransactionHashCleared returns if the "finalized_token_transaction_hash" field was cleared in this mutation.
func (m *TokenTransactionReceiptMutation) FinalizedTokenTransactionHashCleared() bool {
	_, ok := m.clearedFields[tokentransactionreceipt.FieldFinalizedTokenTransactionHash]
	return ok
}

// ResetFinalizedTokenTransactionHash resets all changes to the "finalized_token_transaction_hash" field.
func (m *TokenTransactionReceiptMutation) ResetFinalizedTokenTransactionHash() {
	m.finalized_token_transaction_hash = nil
	delete(m.clearedFields, tokentransactionreceipt.FieldFinalizedTokenTransactionHash)
}

// AddSpentLeafIDs adds the "spent_leaf" edge to the TokenLeaf entity by ids.
func (m *TokenTransactionReceiptMutation) AddSpentLeafIDs(ids ...uuid.UUID) {
	if m.spent_leaf == nil {
		m.spent_leaf = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.spent_leaf[ids[i]] = struct{}{}
	}
}

// ClearSpentLeaf clears the "spent_leaf" edge to the TokenLeaf entity.
func (m *TokenTransactionReceiptMutation) ClearSpentLeaf() {
	m.clearedspent_leaf = true
}

// SpentLeafCleared reports if the "spent_leaf" edge to the TokenLeaf entity was cleared.
func (m *TokenTransactionReceiptMutation) SpentLeafCleared() bool {
	return m.clearedspent_leaf
}

// RemoveSpentLeafIDs removes the "spent_leaf" edge to the TokenLeaf entity by IDs.
func (m *TokenTransactionReceiptMutation) RemoveSpentLeafIDs(ids ...uuid.UUID) {
	if m.removedspent_leaf == nil {
		m.removedspent_leaf = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.spent_leaf, ids[i])
		m.removedspent_leaf[ids[i]] = struct{}{}
	}
}

// RemovedSpentLeaf returns the removed IDs of the "spent_leaf" edge to the TokenLeaf entity.
func (m *TokenTransactionReceiptMutation) RemovedSpentLeafIDs() (ids []uuid.UUID) {
	for id := range m.removedspent_leaf {
		ids = append(ids, id)
	}
	return
}

// SpentLeafIDs returns the "spent_leaf" edge IDs in the mutation.
func (m *TokenTransactionReceiptMutation) SpentLeafIDs() (ids []uuid.UUID) {
	for id := range m.spent_leaf {
		ids = append(ids, id)
	}
	return
}

// ResetSpentLeaf resets all changes to the "spent_leaf" edge.
func (m *TokenTransactionReceiptMutation) ResetSpentLeaf() {
	m.spent_leaf = nil
	m.clearedspent_leaf = false
	m.removedspent_leaf = nil
}

// AddCreatedLeafIDs adds the "created_leaf" edge to the TokenLeaf entity by ids.
func (m *TokenTransactionReceiptMutation) AddCreatedLeafIDs(ids ...uuid.UUID) {
	if m.created_leaf == nil {
		m.created_leaf = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.created_leaf[ids[i]] = struct{}{}
	}
}

// ClearCreatedLeaf clears the "created_leaf" edge to the TokenLeaf entity.
func (m *TokenTransactionReceiptMutation) ClearCreatedLeaf() {
	m.clearedcreated_leaf = true
}

// CreatedLeafCleared reports if the "created_leaf" edge to the TokenLeaf entity was cleared.
func (m *TokenTransactionReceiptMutation) CreatedLeafCleared() bool {
	return m.clearedcreated_leaf
}

// RemoveCreatedLeafIDs removes the "created_leaf" edge to the TokenLeaf entity by IDs.
func (m *TokenTransactionReceiptMutation) RemoveCreatedLeafIDs(ids ...uuid.UUID) {
	if m.removedcreated_leaf == nil {
		m.removedcreated_leaf = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.created_leaf, ids[i])
		m.removedcreated_leaf[ids[i]] = struct{}{}
	}
}

// RemovedCreatedLeaf returns the removed IDs of the "created_leaf" edge to the TokenLeaf entity.
func (m *TokenTransactionReceiptMutation) RemovedCreatedLeafIDs() (ids []uuid.UUID) {
	for id := range m.removedcreated_leaf {
		ids = append(ids, id)
	}
	return
}

// CreatedLeafIDs returns the "created_leaf" edge IDs in the mutation.
func (m *TokenTransactionReceiptMutation) CreatedLeafIDs() (ids []uuid.UUID) {
	for id := range m.created_leaf {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedLeaf resets all changes to the "created_leaf" edge.
func (m *TokenTransactionReceiptMutation) ResetCreatedLeaf() {
	m.created_leaf = nil
	m.clearedcreated_leaf = false
	m.removedcreated_leaf = nil
}

// SetIssuanceID sets the "issuance" edge to the TokenIssuance entity by id.
func (m *TokenTransactionReceiptMutation) SetIssuanceID(id uuid.UUID) {
	m.issuance = &id
}

// ClearIssuance clears the "issuance" edge to the TokenIssuance entity.
func (m *TokenTransactionReceiptMutation) ClearIssuance() {
	m.clearedissuance = true
}

// IssuanceCleared reports if the "issuance" edge to the TokenIssuance entity was cleared.
func (m *TokenTransactionReceiptMutation) IssuanceCleared() bool {
	return m.clearedissuance
}

// IssuanceID returns the "issuance" edge ID in the mutation.
func (m *TokenTransactionReceiptMutation) IssuanceID() (id uuid.UUID, exists bool) {
	if m.issuance != nil {
		return *m.issuance, true
	}
	return
}

// IssuanceIDs returns the "issuance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IssuanceID instead. It exists only for internal usage by the builders.
func (m *TokenTransactionReceiptMutation) IssuanceIDs() (ids []uuid.UUID) {
	if id := m.issuance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIssuance resets all changes to the "issuance" edge.
func (m *TokenTransactionReceiptMutation) ResetIssuance() {
	m.issuance = nil
	m.clearedissuance = false
}

// Where appends a list predicates to the TokenTransactionReceiptMutation builder.
func (m *TokenTransactionReceiptMutation) Where(ps ...predicate.TokenTransactionReceipt) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenTransactionReceiptMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenTransactionReceiptMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TokenTransactionReceipt, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenTransactionReceiptMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenTransactionReceiptMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TokenTransactionReceipt).
func (m *TokenTransactionReceiptMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenTransactionReceiptMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, tokentransactionreceipt.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tokentransactionreceipt.FieldUpdateTime)
	}
	if m.partial_token_transaction_hash != nil {
		fields = append(fields, tokentransactionreceipt.FieldPartialTokenTransactionHash)
	}
	if m.finalized_token_transaction_hash != nil {
		fields = append(fields, tokentransactionreceipt.FieldFinalizedTokenTransactionHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenTransactionReceiptMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tokentransactionreceipt.FieldCreateTime:
		return m.CreateTime()
	case tokentransactionreceipt.FieldUpdateTime:
		return m.UpdateTime()
	case tokentransactionreceipt.FieldPartialTokenTransactionHash:
		return m.PartialTokenTransactionHash()
	case tokentransactionreceipt.FieldFinalizedTokenTransactionHash:
		return m.FinalizedTokenTransactionHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenTransactionReceiptMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tokentransactionreceipt.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tokentransactionreceipt.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tokentransactionreceipt.FieldPartialTokenTransactionHash:
		return m.OldPartialTokenTransactionHash(ctx)
	case tokentransactionreceipt.FieldFinalizedTokenTransactionHash:
		return m.OldFinalizedTokenTransactionHash(ctx)
	}
	return nil, fmt.Errorf("unknown TokenTransactionReceipt field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenTransactionReceiptMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tokentransactionreceipt.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tokentransactionreceipt.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tokentransactionreceipt.FieldPartialTokenTransactionHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPartialTokenTransactionHash(v)
		return nil
	case tokentransactionreceipt.FieldFinalizedTokenTransactionHash:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinalizedTokenTransactionHash(v)
		return nil
	}
	return fmt.Errorf("unknown TokenTransactionReceipt field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenTransactionReceiptMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenTransactionReceiptMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenTransactionReceiptMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TokenTransactionReceipt numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenTransactionReceiptMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tokentransactionreceipt.FieldFinalizedTokenTransactionHash) {
		fields = append(fields, tokentransactionreceipt.FieldFinalizedTokenTransactionHash)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenTransactionReceiptMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenTransactionReceiptMutation) ClearField(name string) error {
	switch name {
	case tokentransactionreceipt.FieldFinalizedTokenTransactionHash:
		m.ClearFinalizedTokenTransactionHash()
		return nil
	}
	return fmt.Errorf("unknown TokenTransactionReceipt nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenTransactionReceiptMutation) ResetField(name string) error {
	switch name {
	case tokentransactionreceipt.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tokentransactionreceipt.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tokentransactionreceipt.FieldPartialTokenTransactionHash:
		m.ResetPartialTokenTransactionHash()
		return nil
	case tokentransactionreceipt.FieldFinalizedTokenTransactionHash:
		m.ResetFinalizedTokenTransactionHash()
		return nil
	}
	return fmt.Errorf("unknown TokenTransactionReceipt field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenTransactionReceiptMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.spent_leaf != nil {
		edges = append(edges, tokentransactionreceipt.EdgeSpentLeaf)
	}
	if m.created_leaf != nil {
		edges = append(edges, tokentransactionreceipt.EdgeCreatedLeaf)
	}
	if m.issuance != nil {
		edges = append(edges, tokentransactionreceipt.EdgeIssuance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenTransactionReceiptMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tokentransactionreceipt.EdgeSpentLeaf:
		ids := make([]ent.Value, 0, len(m.spent_leaf))
		for id := range m.spent_leaf {
			ids = append(ids, id)
		}
		return ids
	case tokentransactionreceipt.EdgeCreatedLeaf:
		ids := make([]ent.Value, 0, len(m.created_leaf))
		for id := range m.created_leaf {
			ids = append(ids, id)
		}
		return ids
	case tokentransactionreceipt.EdgeIssuance:
		if id := m.issuance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenTransactionReceiptMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedspent_leaf != nil {
		edges = append(edges, tokentransactionreceipt.EdgeSpentLeaf)
	}
	if m.removedcreated_leaf != nil {
		edges = append(edges, tokentransactionreceipt.EdgeCreatedLeaf)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenTransactionReceiptMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tokentransactionreceipt.EdgeSpentLeaf:
		ids := make([]ent.Value, 0, len(m.removedspent_leaf))
		for id := range m.removedspent_leaf {
			ids = append(ids, id)
		}
		return ids
	case tokentransactionreceipt.EdgeCreatedLeaf:
		ids := make([]ent.Value, 0, len(m.removedcreated_leaf))
		for id := range m.removedcreated_leaf {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenTransactionReceiptMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedspent_leaf {
		edges = append(edges, tokentransactionreceipt.EdgeSpentLeaf)
	}
	if m.clearedcreated_leaf {
		edges = append(edges, tokentransactionreceipt.EdgeCreatedLeaf)
	}
	if m.clearedissuance {
		edges = append(edges, tokentransactionreceipt.EdgeIssuance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenTransactionReceiptMutation) EdgeCleared(name string) bool {
	switch name {
	case tokentransactionreceipt.EdgeSpentLeaf:
		return m.clearedspent_leaf
	case tokentransactionreceipt.EdgeCreatedLeaf:
		return m.clearedcreated_leaf
	case tokentransactionreceipt.EdgeIssuance:
		return m.clearedissuance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenTransactionReceiptMutation) ClearEdge(name string) error {
	switch name {
	case tokentransactionreceipt.EdgeIssuance:
		m.ClearIssuance()
		return nil
	}
	return fmt.Errorf("unknown TokenTransactionReceipt unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenTransactionReceiptMutation) ResetEdge(name string) error {
	switch name {
	case tokentransactionreceipt.EdgeSpentLeaf:
		m.ResetSpentLeaf()
		return nil
	case tokentransactionreceipt.EdgeCreatedLeaf:
		m.ResetCreatedLeaf()
		return nil
	case tokentransactionreceipt.EdgeIssuance:
		m.ResetIssuance()
		return nil
	}
	return fmt.Errorf("unknown TokenTransactionReceipt edge %s", name)
}

// TransferMutation represents an operation that mutates the Transfer nodes in the graph.
type TransferMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	create_time              *time.Time
	update_time              *time.Time
	sender_identity_pubkey   *[]byte
	receiver_identity_pubkey *[]byte
	total_value              *uint64
	addtotal_value           *int64
	status                   *schema.TransferStatus
	_type                    *schema.TransferType
	expiry_time              *time.Time
	completion_time          *time.Time
	clearedFields            map[string]struct{}
	transfer_leaves          map[uuid.UUID]struct{}
	removedtransfer_leaves   map[uuid.UUID]struct{}
	clearedtransfer_leaves   bool
	done                     bool
	oldValue                 func(context.Context) (*Transfer, error)
	predicates               []predicate.Transfer
}

var _ ent.Mutation = (*TransferMutation)(nil)

// transferOption allows management of the mutation configuration using functional options.
type transferOption func(*TransferMutation)

// newTransferMutation creates new mutation for the Transfer entity.
func newTransferMutation(c config, op Op, opts ...transferOption) *TransferMutation {
	m := &TransferMutation{
		config:        c,
		op:            op,
		typ:           TypeTransfer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransferID sets the ID field of the mutation.
func withTransferID(id uuid.UUID) transferOption {
	return func(m *TransferMutation) {
		var (
			err   error
			once  sync.Once
			value *Transfer
		)
		m.oldValue = func(ctx context.Context) (*Transfer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transfer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransfer sets the old Transfer of the mutation.
func withTransfer(node *Transfer) transferOption {
	return func(m *TransferMutation) {
		m.oldValue = func(context.Context) (*Transfer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransferMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransferMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transfer entities.
func (m *TransferMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransferMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransferMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Transfer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TransferMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TransferMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TransferMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TransferMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TransferMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TransferMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetSenderIdentityPubkey sets the "sender_identity_pubkey" field.
func (m *TransferMutation) SetSenderIdentityPubkey(b []byte) {
	m.sender_identity_pubkey = &b
}

// SenderIdentityPubkey returns the value of the "sender_identity_pubkey" field in the mutation.
func (m *TransferMutation) SenderIdentityPubkey() (r []byte, exists bool) {
	v := m.sender_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderIdentityPubkey returns the old "sender_identity_pubkey" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldSenderIdentityPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderIdentityPubkey: %w", err)
	}
	return oldValue.SenderIdentityPubkey, nil
}

// ResetSenderIdentityPubkey resets all changes to the "sender_identity_pubkey" field.
func (m *TransferMutation) ResetSenderIdentityPubkey() {
	m.sender_identity_pubkey = nil
}

// SetReceiverIdentityPubkey sets the "receiver_identity_pubkey" field.
func (m *TransferMutation) SetReceiverIdentityPubkey(b []byte) {
	m.receiver_identity_pubkey = &b
}

// ReceiverIdentityPubkey returns the value of the "receiver_identity_pubkey" field in the mutation.
func (m *TransferMutation) ReceiverIdentityPubkey() (r []byte, exists bool) {
	v := m.receiver_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverIdentityPubkey returns the old "receiver_identity_pubkey" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldReceiverIdentityPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverIdentityPubkey: %w", err)
	}
	return oldValue.ReceiverIdentityPubkey, nil
}

// ResetReceiverIdentityPubkey resets all changes to the "receiver_identity_pubkey" field.
func (m *TransferMutation) ResetReceiverIdentityPubkey() {
	m.receiver_identity_pubkey = nil
}

// SetTotalValue sets the "total_value" field.
func (m *TransferMutation) SetTotalValue(u uint64) {
	m.total_value = &u
	m.addtotal_value = nil
}

// TotalValue returns the value of the "total_value" field in the mutation.
func (m *TransferMutation) TotalValue() (r uint64, exists bool) {
	v := m.total_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalValue returns the old "total_value" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldTotalValue(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalValue: %w", err)
	}
	return oldValue.TotalValue, nil
}

// AddTotalValue adds u to the "total_value" field.
func (m *TransferMutation) AddTotalValue(u int64) {
	if m.addtotal_value != nil {
		*m.addtotal_value += u
	} else {
		m.addtotal_value = &u
	}
}

// AddedTotalValue returns the value that was added to the "total_value" field in this mutation.
func (m *TransferMutation) AddedTotalValue() (r int64, exists bool) {
	v := m.addtotal_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalValue resets all changes to the "total_value" field.
func (m *TransferMutation) ResetTotalValue() {
	m.total_value = nil
	m.addtotal_value = nil
}

// SetStatus sets the "status" field.
func (m *TransferMutation) SetStatus(ss schema.TransferStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *TransferMutation) Status() (r schema.TransferStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldStatus(ctx context.Context) (v schema.TransferStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TransferMutation) ResetStatus() {
	m.status = nil
}

// SetType sets the "type" field.
func (m *TransferMutation) SetType(st schema.TransferType) {
	m._type = &st
}

// GetType returns the value of the "type" field in the mutation.
func (m *TransferMutation) GetType() (r schema.TransferType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldType(ctx context.Context) (v schema.TransferType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TransferMutation) ResetType() {
	m._type = nil
}

// SetExpiryTime sets the "expiry_time" field.
func (m *TransferMutation) SetExpiryTime(t time.Time) {
	m.expiry_time = &t
}

// ExpiryTime returns the value of the "expiry_time" field in the mutation.
func (m *TransferMutation) ExpiryTime() (r time.Time, exists bool) {
	v := m.expiry_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiryTime returns the old "expiry_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldExpiryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiryTime: %w", err)
	}
	return oldValue.ExpiryTime, nil
}

// ResetExpiryTime resets all changes to the "expiry_time" field.
func (m *TransferMutation) ResetExpiryTime() {
	m.expiry_time = nil
}

// SetCompletionTime sets the "completion_time" field.
func (m *TransferMutation) SetCompletionTime(t time.Time) {
	m.completion_time = &t
}

// CompletionTime returns the value of the "completion_time" field in the mutation.
func (m *TransferMutation) CompletionTime() (r time.Time, exists bool) {
	v := m.completion_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionTime returns the old "completion_time" field's value of the Transfer entity.
// If the Transfer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferMutation) OldCompletionTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionTime: %w", err)
	}
	return oldValue.CompletionTime, nil
}

// ClearCompletionTime clears the value of the "completion_time" field.
func (m *TransferMutation) ClearCompletionTime() {
	m.completion_time = nil
	m.clearedFields[transfer.FieldCompletionTime] = struct{}{}
}

// CompletionTimeCleared returns if the "completion_time" field was cleared in this mutation.
func (m *TransferMutation) CompletionTimeCleared() bool {
	_, ok := m.clearedFields[transfer.FieldCompletionTime]
	return ok
}

// ResetCompletionTime resets all changes to the "completion_time" field.
func (m *TransferMutation) ResetCompletionTime() {
	m.completion_time = nil
	delete(m.clearedFields, transfer.FieldCompletionTime)
}

// AddTransferLeafeIDs adds the "transfer_leaves" edge to the TransferLeaf entity by ids.
func (m *TransferMutation) AddTransferLeafeIDs(ids ...uuid.UUID) {
	if m.transfer_leaves == nil {
		m.transfer_leaves = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.transfer_leaves[ids[i]] = struct{}{}
	}
}

// ClearTransferLeaves clears the "transfer_leaves" edge to the TransferLeaf entity.
func (m *TransferMutation) ClearTransferLeaves() {
	m.clearedtransfer_leaves = true
}

// TransferLeavesCleared reports if the "transfer_leaves" edge to the TransferLeaf entity was cleared.
func (m *TransferMutation) TransferLeavesCleared() bool {
	return m.clearedtransfer_leaves
}

// RemoveTransferLeafeIDs removes the "transfer_leaves" edge to the TransferLeaf entity by IDs.
func (m *TransferMutation) RemoveTransferLeafeIDs(ids ...uuid.UUID) {
	if m.removedtransfer_leaves == nil {
		m.removedtransfer_leaves = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.transfer_leaves, ids[i])
		m.removedtransfer_leaves[ids[i]] = struct{}{}
	}
}

// RemovedTransferLeaves returns the removed IDs of the "transfer_leaves" edge to the TransferLeaf entity.
func (m *TransferMutation) RemovedTransferLeavesIDs() (ids []uuid.UUID) {
	for id := range m.removedtransfer_leaves {
		ids = append(ids, id)
	}
	return
}

// TransferLeavesIDs returns the "transfer_leaves" edge IDs in the mutation.
func (m *TransferMutation) TransferLeavesIDs() (ids []uuid.UUID) {
	for id := range m.transfer_leaves {
		ids = append(ids, id)
	}
	return
}

// ResetTransferLeaves resets all changes to the "transfer_leaves" edge.
func (m *TransferMutation) ResetTransferLeaves() {
	m.transfer_leaves = nil
	m.clearedtransfer_leaves = false
	m.removedtransfer_leaves = nil
}

// Where appends a list predicates to the TransferMutation builder.
func (m *TransferMutation) Where(ps ...predicate.Transfer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransferMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransferMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Transfer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransferMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransferMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Transfer).
func (m *TransferMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransferMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, transfer.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, transfer.FieldUpdateTime)
	}
	if m.sender_identity_pubkey != nil {
		fields = append(fields, transfer.FieldSenderIdentityPubkey)
	}
	if m.receiver_identity_pubkey != nil {
		fields = append(fields, transfer.FieldReceiverIdentityPubkey)
	}
	if m.total_value != nil {
		fields = append(fields, transfer.FieldTotalValue)
	}
	if m.status != nil {
		fields = append(fields, transfer.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, transfer.FieldType)
	}
	if m.expiry_time != nil {
		fields = append(fields, transfer.FieldExpiryTime)
	}
	if m.completion_time != nil {
		fields = append(fields, transfer.FieldCompletionTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransferMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transfer.FieldCreateTime:
		return m.CreateTime()
	case transfer.FieldUpdateTime:
		return m.UpdateTime()
	case transfer.FieldSenderIdentityPubkey:
		return m.SenderIdentityPubkey()
	case transfer.FieldReceiverIdentityPubkey:
		return m.ReceiverIdentityPubkey()
	case transfer.FieldTotalValue:
		return m.TotalValue()
	case transfer.FieldStatus:
		return m.Status()
	case transfer.FieldType:
		return m.GetType()
	case transfer.FieldExpiryTime:
		return m.ExpiryTime()
	case transfer.FieldCompletionTime:
		return m.CompletionTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransferMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transfer.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case transfer.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case transfer.FieldSenderIdentityPubkey:
		return m.OldSenderIdentityPubkey(ctx)
	case transfer.FieldReceiverIdentityPubkey:
		return m.OldReceiverIdentityPubkey(ctx)
	case transfer.FieldTotalValue:
		return m.OldTotalValue(ctx)
	case transfer.FieldStatus:
		return m.OldStatus(ctx)
	case transfer.FieldType:
		return m.OldType(ctx)
	case transfer.FieldExpiryTime:
		return m.OldExpiryTime(ctx)
	case transfer.FieldCompletionTime:
		return m.OldCompletionTime(ctx)
	}
	return nil, fmt.Errorf("unknown Transfer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transfer.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case transfer.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case transfer.FieldSenderIdentityPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderIdentityPubkey(v)
		return nil
	case transfer.FieldReceiverIdentityPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverIdentityPubkey(v)
		return nil
	case transfer.FieldTotalValue:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalValue(v)
		return nil
	case transfer.FieldStatus:
		v, ok := value.(schema.TransferStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case transfer.FieldType:
		v, ok := value.(schema.TransferType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case transfer.FieldExpiryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiryTime(v)
		return nil
	case transfer.FieldCompletionTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionTime(v)
		return nil
	}
	return fmt.Errorf("unknown Transfer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransferMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_value != nil {
		fields = append(fields, transfer.FieldTotalValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransferMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transfer.FieldTotalValue:
		return m.AddedTotalValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transfer.FieldTotalValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalValue(v)
		return nil
	}
	return fmt.Errorf("unknown Transfer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransferMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transfer.FieldCompletionTime) {
		fields = append(fields, transfer.FieldCompletionTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransferMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransferMutation) ClearField(name string) error {
	switch name {
	case transfer.FieldCompletionTime:
		m.ClearCompletionTime()
		return nil
	}
	return fmt.Errorf("unknown Transfer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransferMutation) ResetField(name string) error {
	switch name {
	case transfer.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case transfer.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case transfer.FieldSenderIdentityPubkey:
		m.ResetSenderIdentityPubkey()
		return nil
	case transfer.FieldReceiverIdentityPubkey:
		m.ResetReceiverIdentityPubkey()
		return nil
	case transfer.FieldTotalValue:
		m.ResetTotalValue()
		return nil
	case transfer.FieldStatus:
		m.ResetStatus()
		return nil
	case transfer.FieldType:
		m.ResetType()
		return nil
	case transfer.FieldExpiryTime:
		m.ResetExpiryTime()
		return nil
	case transfer.FieldCompletionTime:
		m.ResetCompletionTime()
		return nil
	}
	return fmt.Errorf("unknown Transfer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransferMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transfer_leaves != nil {
		edges = append(edges, transfer.EdgeTransferLeaves)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransferMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transfer.EdgeTransferLeaves:
		ids := make([]ent.Value, 0, len(m.transfer_leaves))
		for id := range m.transfer_leaves {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransferMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtransfer_leaves != nil {
		edges = append(edges, transfer.EdgeTransferLeaves)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransferMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transfer.EdgeTransferLeaves:
		ids := make([]ent.Value, 0, len(m.removedtransfer_leaves))
		for id := range m.removedtransfer_leaves {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransferMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtransfer_leaves {
		edges = append(edges, transfer.EdgeTransferLeaves)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransferMutation) EdgeCleared(name string) bool {
	switch name {
	case transfer.EdgeTransferLeaves:
		return m.clearedtransfer_leaves
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransferMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Transfer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransferMutation) ResetEdge(name string) error {
	switch name {
	case transfer.EdgeTransferLeaves:
		m.ResetTransferLeaves()
		return nil
	}
	return fmt.Errorf("unknown Transfer edge %s", name)
}

// TransferLeafMutation represents an operation that mutates the TransferLeaf nodes in the graph.
type TransferLeafMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	create_time            *time.Time
	update_time            *time.Time
	secret_cipher          *[]byte
	signature              *[]byte
	previous_refund_tx     *[]byte
	intermediate_refund_tx *[]byte
	key_tweak              *[]byte
	clearedFields          map[string]struct{}
	transfer               *uuid.UUID
	clearedtransfer        bool
	leaf                   *uuid.UUID
	clearedleaf            bool
	done                   bool
	oldValue               func(context.Context) (*TransferLeaf, error)
	predicates             []predicate.TransferLeaf
}

var _ ent.Mutation = (*TransferLeafMutation)(nil)

// transferleafOption allows management of the mutation configuration using functional options.
type transferleafOption func(*TransferLeafMutation)

// newTransferLeafMutation creates new mutation for the TransferLeaf entity.
func newTransferLeafMutation(c config, op Op, opts ...transferleafOption) *TransferLeafMutation {
	m := &TransferLeafMutation{
		config:        c,
		op:            op,
		typ:           TypeTransferLeaf,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransferLeafID sets the ID field of the mutation.
func withTransferLeafID(id uuid.UUID) transferleafOption {
	return func(m *TransferLeafMutation) {
		var (
			err   error
			once  sync.Once
			value *TransferLeaf
		)
		m.oldValue = func(ctx context.Context) (*TransferLeaf, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TransferLeaf.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransferLeaf sets the old TransferLeaf of the mutation.
func withTransferLeaf(node *TransferLeaf) transferleafOption {
	return func(m *TransferLeafMutation) {
		m.oldValue = func(context.Context) (*TransferLeaf, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransferLeafMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransferLeafMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TransferLeaf entities.
func (m *TransferLeafMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TransferLeafMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TransferLeafMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TransferLeaf.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TransferLeafMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TransferLeafMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TransferLeafMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TransferLeafMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TransferLeafMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TransferLeafMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetSecretCipher sets the "secret_cipher" field.
func (m *TransferLeafMutation) SetSecretCipher(b []byte) {
	m.secret_cipher = &b
}

// SecretCipher returns the value of the "secret_cipher" field in the mutation.
func (m *TransferLeafMutation) SecretCipher() (r []byte, exists bool) {
	v := m.secret_cipher
	if v == nil {
		return
	}
	return *v, true
}

// OldSecretCipher returns the old "secret_cipher" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldSecretCipher(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecretCipher is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecretCipher requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecretCipher: %w", err)
	}
	return oldValue.SecretCipher, nil
}

// ClearSecretCipher clears the value of the "secret_cipher" field.
func (m *TransferLeafMutation) ClearSecretCipher() {
	m.secret_cipher = nil
	m.clearedFields[transferleaf.FieldSecretCipher] = struct{}{}
}

// SecretCipherCleared returns if the "secret_cipher" field was cleared in this mutation.
func (m *TransferLeafMutation) SecretCipherCleared() bool {
	_, ok := m.clearedFields[transferleaf.FieldSecretCipher]
	return ok
}

// ResetSecretCipher resets all changes to the "secret_cipher" field.
func (m *TransferLeafMutation) ResetSecretCipher() {
	m.secret_cipher = nil
	delete(m.clearedFields, transferleaf.FieldSecretCipher)
}

// SetSignature sets the "signature" field.
func (m *TransferLeafMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *TransferLeafMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *TransferLeafMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[transferleaf.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *TransferLeafMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[transferleaf.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *TransferLeafMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, transferleaf.FieldSignature)
}

// SetPreviousRefundTx sets the "previous_refund_tx" field.
func (m *TransferLeafMutation) SetPreviousRefundTx(b []byte) {
	m.previous_refund_tx = &b
}

// PreviousRefundTx returns the value of the "previous_refund_tx" field in the mutation.
func (m *TransferLeafMutation) PreviousRefundTx() (r []byte, exists bool) {
	v := m.previous_refund_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviousRefundTx returns the old "previous_refund_tx" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldPreviousRefundTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviousRefundTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviousRefundTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviousRefundTx: %w", err)
	}
	return oldValue.PreviousRefundTx, nil
}

// ResetPreviousRefundTx resets all changes to the "previous_refund_tx" field.
func (m *TransferLeafMutation) ResetPreviousRefundTx() {
	m.previous_refund_tx = nil
}

// SetIntermediateRefundTx sets the "intermediate_refund_tx" field.
func (m *TransferLeafMutation) SetIntermediateRefundTx(b []byte) {
	m.intermediate_refund_tx = &b
}

// IntermediateRefundTx returns the value of the "intermediate_refund_tx" field in the mutation.
func (m *TransferLeafMutation) IntermediateRefundTx() (r []byte, exists bool) {
	v := m.intermediate_refund_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldIntermediateRefundTx returns the old "intermediate_refund_tx" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldIntermediateRefundTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntermediateRefundTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntermediateRefundTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntermediateRefundTx: %w", err)
	}
	return oldValue.IntermediateRefundTx, nil
}

// ResetIntermediateRefundTx resets all changes to the "intermediate_refund_tx" field.
func (m *TransferLeafMutation) ResetIntermediateRefundTx() {
	m.intermediate_refund_tx = nil
}

// SetKeyTweak sets the "key_tweak" field.
func (m *TransferLeafMutation) SetKeyTweak(b []byte) {
	m.key_tweak = &b
}

// KeyTweak returns the value of the "key_tweak" field in the mutation.
func (m *TransferLeafMutation) KeyTweak() (r []byte, exists bool) {
	v := m.key_tweak
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyTweak returns the old "key_tweak" field's value of the TransferLeaf entity.
// If the TransferLeaf object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransferLeafMutation) OldKeyTweak(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyTweak is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyTweak requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyTweak: %w", err)
	}
	return oldValue.KeyTweak, nil
}

// ClearKeyTweak clears the value of the "key_tweak" field.
func (m *TransferLeafMutation) ClearKeyTweak() {
	m.key_tweak = nil
	m.clearedFields[transferleaf.FieldKeyTweak] = struct{}{}
}

// KeyTweakCleared returns if the "key_tweak" field was cleared in this mutation.
func (m *TransferLeafMutation) KeyTweakCleared() bool {
	_, ok := m.clearedFields[transferleaf.FieldKeyTweak]
	return ok
}

// ResetKeyTweak resets all changes to the "key_tweak" field.
func (m *TransferLeafMutation) ResetKeyTweak() {
	m.key_tweak = nil
	delete(m.clearedFields, transferleaf.FieldKeyTweak)
}

// SetTransferID sets the "transfer" edge to the Transfer entity by id.
func (m *TransferLeafMutation) SetTransferID(id uuid.UUID) {
	m.transfer = &id
}

// ClearTransfer clears the "transfer" edge to the Transfer entity.
func (m *TransferLeafMutation) ClearTransfer() {
	m.clearedtransfer = true
}

// TransferCleared reports if the "transfer" edge to the Transfer entity was cleared.
func (m *TransferLeafMutation) TransferCleared() bool {
	return m.clearedtransfer
}

// TransferID returns the "transfer" edge ID in the mutation.
func (m *TransferLeafMutation) TransferID() (id uuid.UUID, exists bool) {
	if m.transfer != nil {
		return *m.transfer, true
	}
	return
}

// TransferIDs returns the "transfer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransferID instead. It exists only for internal usage by the builders.
func (m *TransferLeafMutation) TransferIDs() (ids []uuid.UUID) {
	if id := m.transfer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransfer resets all changes to the "transfer" edge.
func (m *TransferLeafMutation) ResetTransfer() {
	m.transfer = nil
	m.clearedtransfer = false
}

// SetLeafID sets the "leaf" edge to the TreeNode entity by id.
func (m *TransferLeafMutation) SetLeafID(id uuid.UUID) {
	m.leaf = &id
}

// ClearLeaf clears the "leaf" edge to the TreeNode entity.
func (m *TransferLeafMutation) ClearLeaf() {
	m.clearedleaf = true
}

// LeafCleared reports if the "leaf" edge to the TreeNode entity was cleared.
func (m *TransferLeafMutation) LeafCleared() bool {
	return m.clearedleaf
}

// LeafID returns the "leaf" edge ID in the mutation.
func (m *TransferLeafMutation) LeafID() (id uuid.UUID, exists bool) {
	if m.leaf != nil {
		return *m.leaf, true
	}
	return
}

// LeafIDs returns the "leaf" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeafID instead. It exists only for internal usage by the builders.
func (m *TransferLeafMutation) LeafIDs() (ids []uuid.UUID) {
	if id := m.leaf; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeaf resets all changes to the "leaf" edge.
func (m *TransferLeafMutation) ResetLeaf() {
	m.leaf = nil
	m.clearedleaf = false
}

// Where appends a list predicates to the TransferLeafMutation builder.
func (m *TransferLeafMutation) Where(ps ...predicate.TransferLeaf) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TransferLeafMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TransferLeafMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TransferLeaf, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TransferLeafMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TransferLeafMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TransferLeaf).
func (m *TransferLeafMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransferLeafMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, transferleaf.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, transferleaf.FieldUpdateTime)
	}
	if m.secret_cipher != nil {
		fields = append(fields, transferleaf.FieldSecretCipher)
	}
	if m.signature != nil {
		fields = append(fields, transferleaf.FieldSignature)
	}
	if m.previous_refund_tx != nil {
		fields = append(fields, transferleaf.FieldPreviousRefundTx)
	}
	if m.intermediate_refund_tx != nil {
		fields = append(fields, transferleaf.FieldIntermediateRefundTx)
	}
	if m.key_tweak != nil {
		fields = append(fields, transferleaf.FieldKeyTweak)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransferLeafMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transferleaf.FieldCreateTime:
		return m.CreateTime()
	case transferleaf.FieldUpdateTime:
		return m.UpdateTime()
	case transferleaf.FieldSecretCipher:
		return m.SecretCipher()
	case transferleaf.FieldSignature:
		return m.Signature()
	case transferleaf.FieldPreviousRefundTx:
		return m.PreviousRefundTx()
	case transferleaf.FieldIntermediateRefundTx:
		return m.IntermediateRefundTx()
	case transferleaf.FieldKeyTweak:
		return m.KeyTweak()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransferLeafMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transferleaf.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case transferleaf.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case transferleaf.FieldSecretCipher:
		return m.OldSecretCipher(ctx)
	case transferleaf.FieldSignature:
		return m.OldSignature(ctx)
	case transferleaf.FieldPreviousRefundTx:
		return m.OldPreviousRefundTx(ctx)
	case transferleaf.FieldIntermediateRefundTx:
		return m.OldIntermediateRefundTx(ctx)
	case transferleaf.FieldKeyTweak:
		return m.OldKeyTweak(ctx)
	}
	return nil, fmt.Errorf("unknown TransferLeaf field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferLeafMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transferleaf.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case transferleaf.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case transferleaf.FieldSecretCipher:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecretCipher(v)
		return nil
	case transferleaf.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case transferleaf.FieldPreviousRefundTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviousRefundTx(v)
		return nil
	case transferleaf.FieldIntermediateRefundTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntermediateRefundTx(v)
		return nil
	case transferleaf.FieldKeyTweak:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyTweak(v)
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransferLeafMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransferLeafMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransferLeafMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TransferLeaf numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransferLeafMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transferleaf.FieldSecretCipher) {
		fields = append(fields, transferleaf.FieldSecretCipher)
	}
	if m.FieldCleared(transferleaf.FieldSignature) {
		fields = append(fields, transferleaf.FieldSignature)
	}
	if m.FieldCleared(transferleaf.FieldKeyTweak) {
		fields = append(fields, transferleaf.FieldKeyTweak)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransferLeafMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransferLeafMutation) ClearField(name string) error {
	switch name {
	case transferleaf.FieldSecretCipher:
		m.ClearSecretCipher()
		return nil
	case transferleaf.FieldSignature:
		m.ClearSignature()
		return nil
	case transferleaf.FieldKeyTweak:
		m.ClearKeyTweak()
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransferLeafMutation) ResetField(name string) error {
	switch name {
	case transferleaf.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case transferleaf.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case transferleaf.FieldSecretCipher:
		m.ResetSecretCipher()
		return nil
	case transferleaf.FieldSignature:
		m.ResetSignature()
		return nil
	case transferleaf.FieldPreviousRefundTx:
		m.ResetPreviousRefundTx()
		return nil
	case transferleaf.FieldIntermediateRefundTx:
		m.ResetIntermediateRefundTx()
		return nil
	case transferleaf.FieldKeyTweak:
		m.ResetKeyTweak()
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransferLeafMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.transfer != nil {
		edges = append(edges, transferleaf.EdgeTransfer)
	}
	if m.leaf != nil {
		edges = append(edges, transferleaf.EdgeLeaf)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransferLeafMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transferleaf.EdgeTransfer:
		if id := m.transfer; id != nil {
			return []ent.Value{*id}
		}
	case transferleaf.EdgeLeaf:
		if id := m.leaf; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransferLeafMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransferLeafMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransferLeafMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtransfer {
		edges = append(edges, transferleaf.EdgeTransfer)
	}
	if m.clearedleaf {
		edges = append(edges, transferleaf.EdgeLeaf)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransferLeafMutation) EdgeCleared(name string) bool {
	switch name {
	case transferleaf.EdgeTransfer:
		return m.clearedtransfer
	case transferleaf.EdgeLeaf:
		return m.clearedleaf
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransferLeafMutation) ClearEdge(name string) error {
	switch name {
	case transferleaf.EdgeTransfer:
		m.ClearTransfer()
		return nil
	case transferleaf.EdgeLeaf:
		m.ClearLeaf()
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransferLeafMutation) ResetEdge(name string) error {
	switch name {
	case transferleaf.EdgeTransfer:
		m.ResetTransfer()
		return nil
	case transferleaf.EdgeLeaf:
		m.ResetLeaf()
		return nil
	}
	return fmt.Errorf("unknown TransferLeaf edge %s", name)
}

// TreeMutation represents an operation that mutates the Tree nodes in the graph.
type TreeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	create_time           *time.Time
	update_time           *time.Time
	owner_identity_pubkey *[]byte
	status                *schema.TreeStatus
	network               *schema.Network
	clearedFields         map[string]struct{}
	root                  *uuid.UUID
	clearedroot           bool
	nodes                 map[uuid.UUID]struct{}
	removednodes          map[uuid.UUID]struct{}
	clearednodes          bool
	done                  bool
	oldValue              func(context.Context) (*Tree, error)
	predicates            []predicate.Tree
}

var _ ent.Mutation = (*TreeMutation)(nil)

// treeOption allows management of the mutation configuration using functional options.
type treeOption func(*TreeMutation)

// newTreeMutation creates new mutation for the Tree entity.
func newTreeMutation(c config, op Op, opts ...treeOption) *TreeMutation {
	m := &TreeMutation{
		config:        c,
		op:            op,
		typ:           TypeTree,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreeID sets the ID field of the mutation.
func withTreeID(id uuid.UUID) treeOption {
	return func(m *TreeMutation) {
		var (
			err   error
			once  sync.Once
			value *Tree
		)
		m.oldValue = func(ctx context.Context) (*Tree, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tree.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTree sets the old Tree of the mutation.
func withTree(node *Tree) treeOption {
	return func(m *TreeMutation) {
		m.oldValue = func(context.Context) (*Tree, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tree entities.
func (m *TreeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TreeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TreeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tree.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TreeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TreeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TreeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TreeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TreeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TreeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetOwnerIdentityPubkey sets the "owner_identity_pubkey" field.
func (m *TreeMutation) SetOwnerIdentityPubkey(b []byte) {
	m.owner_identity_pubkey = &b
}

// OwnerIdentityPubkey returns the value of the "owner_identity_pubkey" field in the mutation.
func (m *TreeMutation) OwnerIdentityPubkey() (r []byte, exists bool) {
	v := m.owner_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerIdentityPubkey returns the old "owner_identity_pubkey" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldOwnerIdentityPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerIdentityPubkey: %w", err)
	}
	return oldValue.OwnerIdentityPubkey, nil
}

// ResetOwnerIdentityPubkey resets all changes to the "owner_identity_pubkey" field.
func (m *TreeMutation) ResetOwnerIdentityPubkey() {
	m.owner_identity_pubkey = nil
}

// SetStatus sets the "status" field.
func (m *TreeMutation) SetStatus(ss schema.TreeStatus) {
	m.status = &ss
}

// Status returns the value of the "status" field in the mutation.
func (m *TreeMutation) Status() (r schema.TreeStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldStatus(ctx context.Context) (v schema.TreeStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TreeMutation) ResetStatus() {
	m.status = nil
}

// SetNetwork sets the "network" field.
func (m *TreeMutation) SetNetwork(s schema.Network) {
	m.network = &s
}

// Network returns the value of the "network" field in the mutation.
func (m *TreeMutation) Network() (r schema.Network, exists bool) {
	v := m.network
	if v == nil {
		return
	}
	return *v, true
}

// OldNetwork returns the old "network" field's value of the Tree entity.
// If the Tree object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeMutation) OldNetwork(ctx context.Context) (v schema.Network, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNetwork is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNetwork requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetwork: %w", err)
	}
	return oldValue.Network, nil
}

// ResetNetwork resets all changes to the "network" field.
func (m *TreeMutation) ResetNetwork() {
	m.network = nil
}

// SetRootID sets the "root" edge to the TreeNode entity by id.
func (m *TreeMutation) SetRootID(id uuid.UUID) {
	m.root = &id
}

// ClearRoot clears the "root" edge to the TreeNode entity.
func (m *TreeMutation) ClearRoot() {
	m.clearedroot = true
}

// RootCleared reports if the "root" edge to the TreeNode entity was cleared.
func (m *TreeMutation) RootCleared() bool {
	return m.clearedroot
}

// RootID returns the "root" edge ID in the mutation.
func (m *TreeMutation) RootID() (id uuid.UUID, exists bool) {
	if m.root != nil {
		return *m.root, true
	}
	return
}

// RootIDs returns the "root" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RootID instead. It exists only for internal usage by the builders.
func (m *TreeMutation) RootIDs() (ids []uuid.UUID) {
	if id := m.root; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoot resets all changes to the "root" edge.
func (m *TreeMutation) ResetRoot() {
	m.root = nil
	m.clearedroot = false
}

// AddNodeIDs adds the "nodes" edge to the TreeNode entity by ids.
func (m *TreeMutation) AddNodeIDs(ids ...uuid.UUID) {
	if m.nodes == nil {
		m.nodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.nodes[ids[i]] = struct{}{}
	}
}

// ClearNodes clears the "nodes" edge to the TreeNode entity.
func (m *TreeMutation) ClearNodes() {
	m.clearednodes = true
}

// NodesCleared reports if the "nodes" edge to the TreeNode entity was cleared.
func (m *TreeMutation) NodesCleared() bool {
	return m.clearednodes
}

// RemoveNodeIDs removes the "nodes" edge to the TreeNode entity by IDs.
func (m *TreeMutation) RemoveNodeIDs(ids ...uuid.UUID) {
	if m.removednodes == nil {
		m.removednodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.nodes, ids[i])
		m.removednodes[ids[i]] = struct{}{}
	}
}

// RemovedNodes returns the removed IDs of the "nodes" edge to the TreeNode entity.
func (m *TreeMutation) RemovedNodesIDs() (ids []uuid.UUID) {
	for id := range m.removednodes {
		ids = append(ids, id)
	}
	return
}

// NodesIDs returns the "nodes" edge IDs in the mutation.
func (m *TreeMutation) NodesIDs() (ids []uuid.UUID) {
	for id := range m.nodes {
		ids = append(ids, id)
	}
	return
}

// ResetNodes resets all changes to the "nodes" edge.
func (m *TreeMutation) ResetNodes() {
	m.nodes = nil
	m.clearednodes = false
	m.removednodes = nil
}

// Where appends a list predicates to the TreeMutation builder.
func (m *TreeMutation) Where(ps ...predicate.Tree) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TreeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TreeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tree, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TreeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TreeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tree).
func (m *TreeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TreeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, tree.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tree.FieldUpdateTime)
	}
	if m.owner_identity_pubkey != nil {
		fields = append(fields, tree.FieldOwnerIdentityPubkey)
	}
	if m.status != nil {
		fields = append(fields, tree.FieldStatus)
	}
	if m.network != nil {
		fields = append(fields, tree.FieldNetwork)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TreeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tree.FieldCreateTime:
		return m.CreateTime()
	case tree.FieldUpdateTime:
		return m.UpdateTime()
	case tree.FieldOwnerIdentityPubkey:
		return m.OwnerIdentityPubkey()
	case tree.FieldStatus:
		return m.Status()
	case tree.FieldNetwork:
		return m.Network()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TreeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tree.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tree.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tree.FieldOwnerIdentityPubkey:
		return m.OldOwnerIdentityPubkey(ctx)
	case tree.FieldStatus:
		return m.OldStatus(ctx)
	case tree.FieldNetwork:
		return m.OldNetwork(ctx)
	}
	return nil, fmt.Errorf("unknown Tree field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tree.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tree.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tree.FieldOwnerIdentityPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerIdentityPubkey(v)
		return nil
	case tree.FieldStatus:
		v, ok := value.(schema.TreeStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tree.FieldNetwork:
		v, ok := value.(schema.Network)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetwork(v)
		return nil
	}
	return fmt.Errorf("unknown Tree field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TreeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TreeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tree numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TreeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TreeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tree nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TreeMutation) ResetField(name string) error {
	switch name {
	case tree.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tree.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tree.FieldOwnerIdentityPubkey:
		m.ResetOwnerIdentityPubkey()
		return nil
	case tree.FieldStatus:
		m.ResetStatus()
		return nil
	case tree.FieldNetwork:
		m.ResetNetwork()
		return nil
	}
	return fmt.Errorf("unknown Tree field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TreeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.root != nil {
		edges = append(edges, tree.EdgeRoot)
	}
	if m.nodes != nil {
		edges = append(edges, tree.EdgeNodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TreeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tree.EdgeRoot:
		if id := m.root; id != nil {
			return []ent.Value{*id}
		}
	case tree.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.nodes))
		for id := range m.nodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TreeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removednodes != nil {
		edges = append(edges, tree.EdgeNodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TreeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tree.EdgeNodes:
		ids := make([]ent.Value, 0, len(m.removednodes))
		for id := range m.removednodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TreeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedroot {
		edges = append(edges, tree.EdgeRoot)
	}
	if m.clearednodes {
		edges = append(edges, tree.EdgeNodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TreeMutation) EdgeCleared(name string) bool {
	switch name {
	case tree.EdgeRoot:
		return m.clearedroot
	case tree.EdgeNodes:
		return m.clearednodes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TreeMutation) ClearEdge(name string) error {
	switch name {
	case tree.EdgeRoot:
		m.ClearRoot()
		return nil
	}
	return fmt.Errorf("unknown Tree unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TreeMutation) ResetEdge(name string) error {
	switch name {
	case tree.EdgeRoot:
		m.ResetRoot()
		return nil
	case tree.EdgeNodes:
		m.ResetNodes()
		return nil
	}
	return fmt.Errorf("unknown Tree edge %s", name)
}

// TreeNodeMutation represents an operation that mutates the TreeNode nodes in the graph.
type TreeNodeMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	create_time             *time.Time
	update_time             *time.Time
	value                   *uint64
	addvalue                *int64
	status                  *schema.TreeNodeStatus
	verifying_pubkey        *[]byte
	owner_identity_pubkey   *[]byte
	owner_signing_pubkey    *[]byte
	raw_tx                  *[]byte
	vout                    *uint16
	addvout                 *int16
	raw_refund_tx           *[]byte
	clearedFields           map[string]struct{}
	tree                    *uuid.UUID
	clearedtree             bool
	parent                  *uuid.UUID
	clearedparent           bool
	signing_keyshare        *uuid.UUID
	clearedsigning_keyshare bool
	children                map[uuid.UUID]struct{}
	removedchildren         map[uuid.UUID]struct{}
	clearedchildren         bool
	done                    bool
	oldValue                func(context.Context) (*TreeNode, error)
	predicates              []predicate.TreeNode
}

var _ ent.Mutation = (*TreeNodeMutation)(nil)

// treenodeOption allows management of the mutation configuration using functional options.
type treenodeOption func(*TreeNodeMutation)

// newTreeNodeMutation creates new mutation for the TreeNode entity.
func newTreeNodeMutation(c config, op Op, opts ...treenodeOption) *TreeNodeMutation {
	m := &TreeNodeMutation{
		config:        c,
		op:            op,
		typ:           TypeTreeNode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTreeNodeID sets the ID field of the mutation.
func withTreeNodeID(id uuid.UUID) treenodeOption {
	return func(m *TreeNodeMutation) {
		var (
			err   error
			once  sync.Once
			value *TreeNode
		)
		m.oldValue = func(ctx context.Context) (*TreeNode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TreeNode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTreeNode sets the old TreeNode of the mutation.
func withTreeNode(node *TreeNode) treenodeOption {
	return func(m *TreeNodeMutation) {
		m.oldValue = func(context.Context) (*TreeNode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TreeNodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TreeNodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TreeNode entities.
func (m *TreeNodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TreeNodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TreeNodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TreeNode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TreeNodeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TreeNodeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TreeNodeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TreeNodeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TreeNodeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TreeNodeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetValue sets the "value" field.
func (m *TreeNodeMutation) SetValue(u uint64) {
	m.value = &u
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *TreeNodeMutation) Value() (r uint64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldValue(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds u to the "value" field.
func (m *TreeNodeMutation) AddValue(u int64) {
	if m.addvalue != nil {
		*m.addvalue += u
	} else {
		m.addvalue = &u
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *TreeNodeMutation) AddedValue() (r int64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *TreeNodeMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetStatus sets the "status" field.
func (m *TreeNodeMutation) SetStatus(sns schema.TreeNodeStatus) {
	m.status = &sns
}

// Status returns the value of the "status" field in the mutation.
func (m *TreeNodeMutation) Status() (r schema.TreeNodeStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldStatus(ctx context.Context) (v schema.TreeNodeStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TreeNodeMutation) ResetStatus() {
	m.status = nil
}

// SetVerifyingPubkey sets the "verifying_pubkey" field.
func (m *TreeNodeMutation) SetVerifyingPubkey(b []byte) {
	m.verifying_pubkey = &b
}

// VerifyingPubkey returns the value of the "verifying_pubkey" field in the mutation.
func (m *TreeNodeMutation) VerifyingPubkey() (r []byte, exists bool) {
	v := m.verifying_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifyingPubkey returns the old "verifying_pubkey" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldVerifyingPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifyingPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifyingPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifyingPubkey: %w", err)
	}
	return oldValue.VerifyingPubkey, nil
}

// ResetVerifyingPubkey resets all changes to the "verifying_pubkey" field.
func (m *TreeNodeMutation) ResetVerifyingPubkey() {
	m.verifying_pubkey = nil
}

// SetOwnerIdentityPubkey sets the "owner_identity_pubkey" field.
func (m *TreeNodeMutation) SetOwnerIdentityPubkey(b []byte) {
	m.owner_identity_pubkey = &b
}

// OwnerIdentityPubkey returns the value of the "owner_identity_pubkey" field in the mutation.
func (m *TreeNodeMutation) OwnerIdentityPubkey() (r []byte, exists bool) {
	v := m.owner_identity_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerIdentityPubkey returns the old "owner_identity_pubkey" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldOwnerIdentityPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerIdentityPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerIdentityPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerIdentityPubkey: %w", err)
	}
	return oldValue.OwnerIdentityPubkey, nil
}

// ResetOwnerIdentityPubkey resets all changes to the "owner_identity_pubkey" field.
func (m *TreeNodeMutation) ResetOwnerIdentityPubkey() {
	m.owner_identity_pubkey = nil
}

// SetOwnerSigningPubkey sets the "owner_signing_pubkey" field.
func (m *TreeNodeMutation) SetOwnerSigningPubkey(b []byte) {
	m.owner_signing_pubkey = &b
}

// OwnerSigningPubkey returns the value of the "owner_signing_pubkey" field in the mutation.
func (m *TreeNodeMutation) OwnerSigningPubkey() (r []byte, exists bool) {
	v := m.owner_signing_pubkey
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerSigningPubkey returns the old "owner_signing_pubkey" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldOwnerSigningPubkey(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerSigningPubkey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerSigningPubkey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerSigningPubkey: %w", err)
	}
	return oldValue.OwnerSigningPubkey, nil
}

// ResetOwnerSigningPubkey resets all changes to the "owner_signing_pubkey" field.
func (m *TreeNodeMutation) ResetOwnerSigningPubkey() {
	m.owner_signing_pubkey = nil
}

// SetRawTx sets the "raw_tx" field.
func (m *TreeNodeMutation) SetRawTx(b []byte) {
	m.raw_tx = &b
}

// RawTx returns the value of the "raw_tx" field in the mutation.
func (m *TreeNodeMutation) RawTx() (r []byte, exists bool) {
	v := m.raw_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldRawTx returns the old "raw_tx" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldRawTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawTx: %w", err)
	}
	return oldValue.RawTx, nil
}

// ResetRawTx resets all changes to the "raw_tx" field.
func (m *TreeNodeMutation) ResetRawTx() {
	m.raw_tx = nil
}

// SetVout sets the "vout" field.
func (m *TreeNodeMutation) SetVout(u uint16) {
	m.vout = &u
	m.addvout = nil
}

// Vout returns the value of the "vout" field in the mutation.
func (m *TreeNodeMutation) Vout() (r uint16, exists bool) {
	v := m.vout
	if v == nil {
		return
	}
	return *v, true
}

// OldVout returns the old "vout" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldVout(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVout: %w", err)
	}
	return oldValue.Vout, nil
}

// AddVout adds u to the "vout" field.
func (m *TreeNodeMutation) AddVout(u int16) {
	if m.addvout != nil {
		*m.addvout += u
	} else {
		m.addvout = &u
	}
}

// AddedVout returns the value that was added to the "vout" field in this mutation.
func (m *TreeNodeMutation) AddedVout() (r int16, exists bool) {
	v := m.addvout
	if v == nil {
		return
	}
	return *v, true
}

// ResetVout resets all changes to the "vout" field.
func (m *TreeNodeMutation) ResetVout() {
	m.vout = nil
	m.addvout = nil
}

// SetRawRefundTx sets the "raw_refund_tx" field.
func (m *TreeNodeMutation) SetRawRefundTx(b []byte) {
	m.raw_refund_tx = &b
}

// RawRefundTx returns the value of the "raw_refund_tx" field in the mutation.
func (m *TreeNodeMutation) RawRefundTx() (r []byte, exists bool) {
	v := m.raw_refund_tx
	if v == nil {
		return
	}
	return *v, true
}

// OldRawRefundTx returns the old "raw_refund_tx" field's value of the TreeNode entity.
// If the TreeNode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TreeNodeMutation) OldRawRefundTx(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawRefundTx is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawRefundTx requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawRefundTx: %w", err)
	}
	return oldValue.RawRefundTx, nil
}

// ClearRawRefundTx clears the value of the "raw_refund_tx" field.
func (m *TreeNodeMutation) ClearRawRefundTx() {
	m.raw_refund_tx = nil
	m.clearedFields[treenode.FieldRawRefundTx] = struct{}{}
}

// RawRefundTxCleared returns if the "raw_refund_tx" field was cleared in this mutation.
func (m *TreeNodeMutation) RawRefundTxCleared() bool {
	_, ok := m.clearedFields[treenode.FieldRawRefundTx]
	return ok
}

// ResetRawRefundTx resets all changes to the "raw_refund_tx" field.
func (m *TreeNodeMutation) ResetRawRefundTx() {
	m.raw_refund_tx = nil
	delete(m.clearedFields, treenode.FieldRawRefundTx)
}

// SetTreeID sets the "tree" edge to the Tree entity by id.
func (m *TreeNodeMutation) SetTreeID(id uuid.UUID) {
	m.tree = &id
}

// ClearTree clears the "tree" edge to the Tree entity.
func (m *TreeNodeMutation) ClearTree() {
	m.clearedtree = true
}

// TreeCleared reports if the "tree" edge to the Tree entity was cleared.
func (m *TreeNodeMutation) TreeCleared() bool {
	return m.clearedtree
}

// TreeID returns the "tree" edge ID in the mutation.
func (m *TreeNodeMutation) TreeID() (id uuid.UUID, exists bool) {
	if m.tree != nil {
		return *m.tree, true
	}
	return
}

// TreeIDs returns the "tree" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TreeID instead. It exists only for internal usage by the builders.
func (m *TreeNodeMutation) TreeIDs() (ids []uuid.UUID) {
	if id := m.tree; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTree resets all changes to the "tree" edge.
func (m *TreeNodeMutation) ResetTree() {
	m.tree = nil
	m.clearedtree = false
}

// SetParentID sets the "parent" edge to the TreeNode entity by id.
func (m *TreeNodeMutation) SetParentID(id uuid.UUID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the TreeNode entity.
func (m *TreeNodeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the TreeNode entity was cleared.
func (m *TreeNodeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *TreeNodeMutation) ParentID() (id uuid.UUID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *TreeNodeMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *TreeNodeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// SetSigningKeyshareID sets the "signing_keyshare" edge to the SigningKeyshare entity by id.
func (m *TreeNodeMutation) SetSigningKeyshareID(id uuid.UUID) {
	m.signing_keyshare = &id
}

// ClearSigningKeyshare clears the "signing_keyshare" edge to the SigningKeyshare entity.
func (m *TreeNodeMutation) ClearSigningKeyshare() {
	m.clearedsigning_keyshare = true
}

// SigningKeyshareCleared reports if the "signing_keyshare" edge to the SigningKeyshare entity was cleared.
func (m *TreeNodeMutation) SigningKeyshareCleared() bool {
	return m.clearedsigning_keyshare
}

// SigningKeyshareID returns the "signing_keyshare" edge ID in the mutation.
func (m *TreeNodeMutation) SigningKeyshareID() (id uuid.UUID, exists bool) {
	if m.signing_keyshare != nil {
		return *m.signing_keyshare, true
	}
	return
}

// SigningKeyshareIDs returns the "signing_keyshare" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SigningKeyshareID instead. It exists only for internal usage by the builders.
func (m *TreeNodeMutation) SigningKeyshareIDs() (ids []uuid.UUID) {
	if id := m.signing_keyshare; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSigningKeyshare resets all changes to the "signing_keyshare" edge.
func (m *TreeNodeMutation) ResetSigningKeyshare() {
	m.signing_keyshare = nil
	m.clearedsigning_keyshare = false
}

// AddChildIDs adds the "children" edge to the TreeNode entity by ids.
func (m *TreeNodeMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the TreeNode entity.
func (m *TreeNodeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the TreeNode entity was cleared.
func (m *TreeNodeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the TreeNode entity by IDs.
func (m *TreeNodeMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the TreeNode entity.
func (m *TreeNodeMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *TreeNodeMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *TreeNodeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the TreeNodeMutation builder.
func (m *TreeNodeMutation) Where(ps ...predicate.TreeNode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TreeNodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TreeNodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TreeNode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TreeNodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TreeNodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TreeNode).
func (m *TreeNodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TreeNodeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, treenode.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, treenode.FieldUpdateTime)
	}
	if m.value != nil {
		fields = append(fields, treenode.FieldValue)
	}
	if m.status != nil {
		fields = append(fields, treenode.FieldStatus)
	}
	if m.verifying_pubkey != nil {
		fields = append(fields, treenode.FieldVerifyingPubkey)
	}
	if m.owner_identity_pubkey != nil {
		fields = append(fields, treenode.FieldOwnerIdentityPubkey)
	}
	if m.owner_signing_pubkey != nil {
		fields = append(fields, treenode.FieldOwnerSigningPubkey)
	}
	if m.raw_tx != nil {
		fields = append(fields, treenode.FieldRawTx)
	}
	if m.vout != nil {
		fields = append(fields, treenode.FieldVout)
	}
	if m.raw_refund_tx != nil {
		fields = append(fields, treenode.FieldRawRefundTx)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TreeNodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case treenode.FieldCreateTime:
		return m.CreateTime()
	case treenode.FieldUpdateTime:
		return m.UpdateTime()
	case treenode.FieldValue:
		return m.Value()
	case treenode.FieldStatus:
		return m.Status()
	case treenode.FieldVerifyingPubkey:
		return m.VerifyingPubkey()
	case treenode.FieldOwnerIdentityPubkey:
		return m.OwnerIdentityPubkey()
	case treenode.FieldOwnerSigningPubkey:
		return m.OwnerSigningPubkey()
	case treenode.FieldRawTx:
		return m.RawTx()
	case treenode.FieldVout:
		return m.Vout()
	case treenode.FieldRawRefundTx:
		return m.RawRefundTx()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TreeNodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case treenode.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case treenode.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case treenode.FieldValue:
		return m.OldValue(ctx)
	case treenode.FieldStatus:
		return m.OldStatus(ctx)
	case treenode.FieldVerifyingPubkey:
		return m.OldVerifyingPubkey(ctx)
	case treenode.FieldOwnerIdentityPubkey:
		return m.OldOwnerIdentityPubkey(ctx)
	case treenode.FieldOwnerSigningPubkey:
		return m.OldOwnerSigningPubkey(ctx)
	case treenode.FieldRawTx:
		return m.OldRawTx(ctx)
	case treenode.FieldVout:
		return m.OldVout(ctx)
	case treenode.FieldRawRefundTx:
		return m.OldRawRefundTx(ctx)
	}
	return nil, fmt.Errorf("unknown TreeNode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreeNodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case treenode.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case treenode.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case treenode.FieldValue:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case treenode.FieldStatus:
		v, ok := value.(schema.TreeNodeStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case treenode.FieldVerifyingPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifyingPubkey(v)
		return nil
	case treenode.FieldOwnerIdentityPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerIdentityPubkey(v)
		return nil
	case treenode.FieldOwnerSigningPubkey:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerSigningPubkey(v)
		return nil
	case treenode.FieldRawTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawTx(v)
		return nil
	case treenode.FieldVout:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVout(v)
		return nil
	case treenode.FieldRawRefundTx:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawRefundTx(v)
		return nil
	}
	return fmt.Errorf("unknown TreeNode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TreeNodeMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, treenode.FieldValue)
	}
	if m.addvout != nil {
		fields = append(fields, treenode.FieldVout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TreeNodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case treenode.FieldValue:
		return m.AddedValue()
	case treenode.FieldVout:
		return m.AddedVout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TreeNodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case treenode.FieldValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case treenode.FieldVout:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVout(v)
		return nil
	}
	return fmt.Errorf("unknown TreeNode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TreeNodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(treenode.FieldRawRefundTx) {
		fields = append(fields, treenode.FieldRawRefundTx)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TreeNodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TreeNodeMutation) ClearField(name string) error {
	switch name {
	case treenode.FieldRawRefundTx:
		m.ClearRawRefundTx()
		return nil
	}
	return fmt.Errorf("unknown TreeNode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TreeNodeMutation) ResetField(name string) error {
	switch name {
	case treenode.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case treenode.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case treenode.FieldValue:
		m.ResetValue()
		return nil
	case treenode.FieldStatus:
		m.ResetStatus()
		return nil
	case treenode.FieldVerifyingPubkey:
		m.ResetVerifyingPubkey()
		return nil
	case treenode.FieldOwnerIdentityPubkey:
		m.ResetOwnerIdentityPubkey()
		return nil
	case treenode.FieldOwnerSigningPubkey:
		m.ResetOwnerSigningPubkey()
		return nil
	case treenode.FieldRawTx:
		m.ResetRawTx()
		return nil
	case treenode.FieldVout:
		m.ResetVout()
		return nil
	case treenode.FieldRawRefundTx:
		m.ResetRawRefundTx()
		return nil
	}
	return fmt.Errorf("unknown TreeNode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TreeNodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tree != nil {
		edges = append(edges, treenode.EdgeTree)
	}
	if m.parent != nil {
		edges = append(edges, treenode.EdgeParent)
	}
	if m.signing_keyshare != nil {
		edges = append(edges, treenode.EdgeSigningKeyshare)
	}
	if m.children != nil {
		edges = append(edges, treenode.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TreeNodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case treenode.EdgeTree:
		if id := m.tree; id != nil {
			return []ent.Value{*id}
		}
	case treenode.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case treenode.EdgeSigningKeyshare:
		if id := m.signing_keyshare; id != nil {
			return []ent.Value{*id}
		}
	case treenode.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TreeNodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, treenode.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TreeNodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case treenode.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TreeNodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtree {
		edges = append(edges, treenode.EdgeTree)
	}
	if m.clearedparent {
		edges = append(edges, treenode.EdgeParent)
	}
	if m.clearedsigning_keyshare {
		edges = append(edges, treenode.EdgeSigningKeyshare)
	}
	if m.clearedchildren {
		edges = append(edges, treenode.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TreeNodeMutation) EdgeCleared(name string) bool {
	switch name {
	case treenode.EdgeTree:
		return m.clearedtree
	case treenode.EdgeParent:
		return m.clearedparent
	case treenode.EdgeSigningKeyshare:
		return m.clearedsigning_keyshare
	case treenode.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TreeNodeMutation) ClearEdge(name string) error {
	switch name {
	case treenode.EdgeTree:
		m.ClearTree()
		return nil
	case treenode.EdgeParent:
		m.ClearParent()
		return nil
	case treenode.EdgeSigningKeyshare:
		m.ClearSigningKeyshare()
		return nil
	}
	return fmt.Errorf("unknown TreeNode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TreeNodeMutation) ResetEdge(name string) error {
	switch name {
	case treenode.EdgeTree:
		m.ResetTree()
		return nil
	case treenode.EdgeParent:
		m.ResetParent()
		return nil
	case treenode.EdgeSigningKeyshare:
		m.ResetSigningKeyshare()
		return nil
	case treenode.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown TreeNode edge %s", name)
}

// UserSignedTransactionMutation represents an operation that mutates the UserSignedTransaction nodes in the graph.
type UserSignedTransactionMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	create_time               *time.Time
	update_time               *time.Time
	transaction               *[]byte
	user_signature            *[]byte
	signing_commitments       *[]byte
	user_signature_commitment *[]byte
	clearedFields             map[string]struct{}
	tree_node                 *uuid.UUID
	clearedtree_node          bool
	preimage_request          *uuid.UUID
	clearedpreimage_request   bool
	done                      bool
	oldValue                  func(context.Context) (*UserSignedTransaction, error)
	predicates                []predicate.UserSignedTransaction
}

var _ ent.Mutation = (*UserSignedTransactionMutation)(nil)

// usersignedtransactionOption allows management of the mutation configuration using functional options.
type usersignedtransactionOption func(*UserSignedTransactionMutation)

// newUserSignedTransactionMutation creates new mutation for the UserSignedTransaction entity.
func newUserSignedTransactionMutation(c config, op Op, opts ...usersignedtransactionOption) *UserSignedTransactionMutation {
	m := &UserSignedTransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSignedTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSignedTransactionID sets the ID field of the mutation.
func withUserSignedTransactionID(id uuid.UUID) usersignedtransactionOption {
	return func(m *UserSignedTransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSignedTransaction
		)
		m.oldValue = func(ctx context.Context) (*UserSignedTransaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSignedTransaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSignedTransaction sets the old UserSignedTransaction of the mutation.
func withUserSignedTransaction(node *UserSignedTransaction) usersignedtransactionOption {
	return func(m *UserSignedTransactionMutation) {
		m.oldValue = func(context.Context) (*UserSignedTransaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSignedTransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSignedTransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSignedTransaction entities.
func (m *UserSignedTransactionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSignedTransactionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSignedTransactionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSignedTransaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserSignedTransactionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserSignedTransactionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserSignedTransaction entity.
// If the UserSignedTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSignedTransactionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserSignedTransactionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserSignedTransactionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserSignedTransactionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserSignedTransaction entity.
// If the UserSignedTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSignedTransactionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserSignedTransactionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetTransaction sets the "transaction" field.
func (m *UserSignedTransactionMutation) SetTransaction(b []byte) {
	m.transaction = &b
}

// Transaction returns the value of the "transaction" field in the mutation.
func (m *UserSignedTransactionMutation) Transaction() (r []byte, exists bool) {
	v := m.transaction
	if v == nil {
		return
	}
	return *v, true
}

// OldTransaction returns the old "transaction" field's value of the UserSignedTransaction entity.
// If the UserSignedTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSignedTransactionMutation) OldTransaction(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransaction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransaction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransaction: %w", err)
	}
	return oldValue.Transaction, nil
}

// ResetTransaction resets all changes to the "transaction" field.
func (m *UserSignedTransactionMutation) ResetTransaction() {
	m.transaction = nil
}

// SetUserSignature sets the "user_signature" field.
func (m *UserSignedTransactionMutation) SetUserSignature(b []byte) {
	m.user_signature = &b
}

// UserSignature returns the value of the "user_signature" field in the mutation.
func (m *UserSignedTransactionMutation) UserSignature() (r []byte, exists bool) {
	v := m.user_signature
	if v == nil {
		return
	}
	return *v, true
}

// OldUserSignature returns the old "user_signature" field's value of the UserSignedTransaction entity.
// If the UserSignedTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSignedTransactionMutation) OldUserSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserSignature: %w", err)
	}
	return oldValue.UserSignature, nil
}

// ResetUserSignature resets all changes to the "user_signature" field.
func (m *UserSignedTransactionMutation) ResetUserSignature() {
	m.user_signature = nil
}

// SetSigningCommitments sets the "signing_commitments" field.
func (m *UserSignedTransactionMutation) SetSigningCommitments(b []byte) {
	m.signing_commitments = &b
}

// SigningCommitments returns the value of the "signing_commitments" field in the mutation.
func (m *UserSignedTransactionMutation) SigningCommitments() (r []byte, exists bool) {
	v := m.signing_commitments
	if v == nil {
		return
	}
	return *v, true
}

// OldSigningCommitments returns the old "signing_commitments" field's value of the UserSignedTransaction entity.
// If the UserSignedTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSignedTransactionMutation) OldSigningCommitments(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSigningCommitments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSigningCommitments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSigningCommitments: %w", err)
	}
	return oldValue.SigningCommitments, nil
}

// ResetSigningCommitments resets all changes to the "signing_commitments" field.
func (m *UserSignedTransactionMutation) ResetSigningCommitments() {
	m.signing_commitments = nil
}

// SetUserSignatureCommitment sets the "user_signature_commitment" field.
func (m *UserSignedTransactionMutation) SetUserSignatureCommitment(b []byte) {
	m.user_signature_commitment = &b
}

// UserSignatureCommitment returns the value of the "user_signature_commitment" field in the mutation.
func (m *UserSignedTransactionMutation) UserSignatureCommitment() (r []byte, exists bool) {
	v := m.user_signature_commitment
	if v == nil {
		return
	}
	return *v, true
}

// OldUserSignatureCommitment returns the old "user_signature_commitment" field's value of the UserSignedTransaction entity.
// If the UserSignedTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSignedTransactionMutation) OldUserSignatureCommitment(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserSignatureCommitment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserSignatureCommitment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserSignatureCommitment: %w", err)
	}
	return oldValue.UserSignatureCommitment, nil
}

// ResetUserSignatureCommitment resets all changes to the "user_signature_commitment" field.
func (m *UserSignedTransactionMutation) ResetUserSignatureCommitment() {
	m.user_signature_commitment = nil
}

// SetTreeNodeID sets the "tree_node" edge to the TreeNode entity by id.
func (m *UserSignedTransactionMutation) SetTreeNodeID(id uuid.UUID) {
	m.tree_node = &id
}

// ClearTreeNode clears the "tree_node" edge to the TreeNode entity.
func (m *UserSignedTransactionMutation) ClearTreeNode() {
	m.clearedtree_node = true
}

// TreeNodeCleared reports if the "tree_node" edge to the TreeNode entity was cleared.
func (m *UserSignedTransactionMutation) TreeNodeCleared() bool {
	return m.clearedtree_node
}

// TreeNodeID returns the "tree_node" edge ID in the mutation.
func (m *UserSignedTransactionMutation) TreeNodeID() (id uuid.UUID, exists bool) {
	if m.tree_node != nil {
		return *m.tree_node, true
	}
	return
}

// TreeNodeIDs returns the "tree_node" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TreeNodeID instead. It exists only for internal usage by the builders.
func (m *UserSignedTransactionMutation) TreeNodeIDs() (ids []uuid.UUID) {
	if id := m.tree_node; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTreeNode resets all changes to the "tree_node" edge.
func (m *UserSignedTransactionMutation) ResetTreeNode() {
	m.tree_node = nil
	m.clearedtree_node = false
}

// SetPreimageRequestID sets the "preimage_request" edge to the PreimageRequest entity by id.
func (m *UserSignedTransactionMutation) SetPreimageRequestID(id uuid.UUID) {
	m.preimage_request = &id
}

// ClearPreimageRequest clears the "preimage_request" edge to the PreimageRequest entity.
func (m *UserSignedTransactionMutation) ClearPreimageRequest() {
	m.clearedpreimage_request = true
}

// PreimageRequestCleared reports if the "preimage_request" edge to the PreimageRequest entity was cleared.
func (m *UserSignedTransactionMutation) PreimageRequestCleared() bool {
	return m.clearedpreimage_request
}

// PreimageRequestID returns the "preimage_request" edge ID in the mutation.
func (m *UserSignedTransactionMutation) PreimageRequestID() (id uuid.UUID, exists bool) {
	if m.preimage_request != nil {
		return *m.preimage_request, true
	}
	return
}

// PreimageRequestIDs returns the "preimage_request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PreimageRequestID instead. It exists only for internal usage by the builders.
func (m *UserSignedTransactionMutation) PreimageRequestIDs() (ids []uuid.UUID) {
	if id := m.preimage_request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPreimageRequest resets all changes to the "preimage_request" edge.
func (m *UserSignedTransactionMutation) ResetPreimageRequest() {
	m.preimage_request = nil
	m.clearedpreimage_request = false
}

// Where appends a list predicates to the UserSignedTransactionMutation builder.
func (m *UserSignedTransactionMutation) Where(ps ...predicate.UserSignedTransaction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSignedTransactionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSignedTransactionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSignedTransaction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSignedTransactionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSignedTransactionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSignedTransaction).
func (m *UserSignedTransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSignedTransactionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, usersignedtransaction.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, usersignedtransaction.FieldUpdateTime)
	}
	if m.transaction != nil {
		fields = append(fields, usersignedtransaction.FieldTransaction)
	}
	if m.user_signature != nil {
		fields = append(fields, usersignedtransaction.FieldUserSignature)
	}
	if m.signing_commitments != nil {
		fields = append(fields, usersignedtransaction.FieldSigningCommitments)
	}
	if m.user_signature_commitment != nil {
		fields = append(fields, usersignedtransaction.FieldUserSignatureCommitment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSignedTransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersignedtransaction.FieldCreateTime:
		return m.CreateTime()
	case usersignedtransaction.FieldUpdateTime:
		return m.UpdateTime()
	case usersignedtransaction.FieldTransaction:
		return m.Transaction()
	case usersignedtransaction.FieldUserSignature:
		return m.UserSignature()
	case usersignedtransaction.FieldSigningCommitments:
		return m.SigningCommitments()
	case usersignedtransaction.FieldUserSignatureCommitment:
		return m.UserSignatureCommitment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSignedTransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersignedtransaction.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case usersignedtransaction.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case usersignedtransaction.FieldTransaction:
		return m.OldTransaction(ctx)
	case usersignedtransaction.FieldUserSignature:
		return m.OldUserSignature(ctx)
	case usersignedtransaction.FieldSigningCommitments:
		return m.OldSigningCommitments(ctx)
	case usersignedtransaction.FieldUserSignatureCommitment:
		return m.OldUserSignatureCommitment(ctx)
	}
	return nil, fmt.Errorf("unknown UserSignedTransaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSignedTransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersignedtransaction.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case usersignedtransaction.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case usersignedtransaction.FieldTransaction:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransaction(v)
		return nil
	case usersignedtransaction.FieldUserSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserSignature(v)
		return nil
	case usersignedtransaction.FieldSigningCommitments:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSigningCommitments(v)
		return nil
	case usersignedtransaction.FieldUserSignatureCommitment:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserSignatureCommitment(v)
		return nil
	}
	return fmt.Errorf("unknown UserSignedTransaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSignedTransactionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSignedTransactionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSignedTransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSignedTransaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSignedTransactionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSignedTransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSignedTransactionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserSignedTransaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSignedTransactionMutation) ResetField(name string) error {
	switch name {
	case usersignedtransaction.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case usersignedtransaction.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case usersignedtransaction.FieldTransaction:
		m.ResetTransaction()
		return nil
	case usersignedtransaction.FieldUserSignature:
		m.ResetUserSignature()
		return nil
	case usersignedtransaction.FieldSigningCommitments:
		m.ResetSigningCommitments()
		return nil
	case usersignedtransaction.FieldUserSignatureCommitment:
		m.ResetUserSignatureCommitment()
		return nil
	}
	return fmt.Errorf("unknown UserSignedTransaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSignedTransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tree_node != nil {
		edges = append(edges, usersignedtransaction.EdgeTreeNode)
	}
	if m.preimage_request != nil {
		edges = append(edges, usersignedtransaction.EdgePreimageRequest)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSignedTransactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersignedtransaction.EdgeTreeNode:
		if id := m.tree_node; id != nil {
			return []ent.Value{*id}
		}
	case usersignedtransaction.EdgePreimageRequest:
		if id := m.preimage_request; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSignedTransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSignedTransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSignedTransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtree_node {
		edges = append(edges, usersignedtransaction.EdgeTreeNode)
	}
	if m.clearedpreimage_request {
		edges = append(edges, usersignedtransaction.EdgePreimageRequest)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSignedTransactionMutation) EdgeCleared(name string) bool {
	switch name {
	case usersignedtransaction.EdgeTreeNode:
		return m.clearedtree_node
	case usersignedtransaction.EdgePreimageRequest:
		return m.clearedpreimage_request
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSignedTransactionMutation) ClearEdge(name string) error {
	switch name {
	case usersignedtransaction.EdgeTreeNode:
		m.ClearTreeNode()
		return nil
	case usersignedtransaction.EdgePreimageRequest:
		m.ClearPreimageRequest()
		return nil
	}
	return fmt.Errorf("unknown UserSignedTransaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSignedTransactionMutation) ResetEdge(name string) error {
	switch name {
	case usersignedtransaction.EdgeTreeNode:
		m.ResetTreeNode()
		return nil
	case usersignedtransaction.EdgePreimageRequest:
		m.ResetPreimageRequest()
		return nil
	}
	return fmt.Errorf("unknown UserSignedTransaction edge %s", name)
}
