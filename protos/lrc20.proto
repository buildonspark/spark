syntax = "proto3";

package rpc.v1;

option go_package = "github.com/lightsparkdev/spark-go/proto/lrc20";
import "google/protobuf/empty.proto";
import "spark.proto";

service SparkService {
  rpc SendSparkTx(SendSparkTxRequest) returns (google.protobuf.Empty);
  rpc SendSparkSignature(SendSparkSignatureRequest) returns (google.protobuf.Empty);
  rpc ListSparkTxs(ListSparkTxsRequest) returns (ListSparkTxsResponse);
  rpc GetSparkTx(GetSparkTxRequest) returns (GetSparkTxResponse);
  rpc VerifySparkTx(VerifySparkTxRequest) returns (VerifySparkTxResponse);
  rpc FreezeTokens(spark.FreezeTokensRequest) returns (spark.FreezeTokensResponse);
}

message SendSparkTxRequest {
  bytes identity_public_key = 1;
  spark.TokenTransaction final_token_transaction = 2;
}

message SendSparkSignatureRequest {
  SparkSignatureData signature_data = 1;
}

message SparkSignatureData {
  bytes spark_operator_signature = 1;
  bytes spark_operator_identity_public_key = 2;
  repeated SparkSignatureLeafData leaves_to_spend_data = 3;

  spark.TokenTransaction final_token_transaction = 4;
}

message SparkSignatureLeafData {
  uint32 spent_leaf_index = 1;
  optional bytes revocation_private_key = 2;
}

message GetSparkTxRequest {
  bytes final_token_transaction_hash = 1;
}

message VerifySparkTxRequest {
  spark.TokenTransaction final_token_transaction = 1;
}

message ListSparkTxsRequest {
  optional bytes page_token = 1;
  optional uint32 page_size = 2;
}

message VerifySparkTxResponse {
  bool is_valid = 1;
}

message ListSparkTxsResponse {
  repeated TokenTransactionResponse token_transactions = 1;
  optional bytes next_page_token = 2;
}

message GetSparkTxResponse {
  spark.TokenTransaction final_token_transaction = 1;
}

message TokenTransactionResponse {
  bool finalized = 1;
  spark.TokenTransaction final_token_transaction = 2;
}